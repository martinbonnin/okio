{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Okio \u00b6 Okio is a library that complements java.io and java.nio to make it much easier to access, store, and process your data. It started as a component of OkHttp , the capable HTTP client included in Android. It\u2019s well-exercised and ready to solve new problems. ByteStrings and Buffers \u00b6 Okio is built around two types that pack a lot of capability into a straightforward API: ByteString is an immutable sequence of bytes. For character data, String is fundamental. ByteString is String\u2019s long-lost brother, making it easy to treat binary data as a value. This class is ergonomic: it knows how to encode and decode itself as hex, base64, and UTF-8. Buffer is a mutable sequence of bytes. Like ArrayList , you don\u2019t need to size your buffer in advance. You read and write buffers as a queue: write data to the end and read it from the front. There\u2019s no obligation to manage positions, limits, or capacities. Internally, ByteString and Buffer do some clever things to save CPU and memory. If you encode a UTF-8 string as a ByteString , it caches a reference to that string so that if you decode it later, there\u2019s no work to do. Buffer is implemented as a linked list of segments. When you move data from one buffer to another, it reassigns ownership of the segments rather than copying the data across. This approach is particularly helpful for multithreaded programs: a thread that talks to the network can exchange data with a worker thread without any copying or ceremony. Sources and Sinks \u00b6 An elegant part of the java.io design is how streams can be layered for transformations like encryption and compression. Okio includes its own stream types called Source and Sink that work like InputStream and OutputStream , but with some key differences: Timeouts. The streams provide access to the timeouts of the underlying I/O mechanism. Unlike the java.io socket streams, both read() and write() calls honor timeouts. Easy to implement. Source declares three methods: read() , close() , and timeout() . There are no hazards like available() or single-byte reads that cause correctness and performance surprises. Easy to use. Although implementations of Source and Sink have only three methods to write, callers are given a rich API with the BufferedSource and BufferedSink interfaces. These interfaces give you everything you need in one place. No artificial distinction between byte streams and char streams. It\u2019s all data. Read and write it as bytes, UTF-8 strings, big-endian 32-bit integers, little-endian shorts; whatever you want. No more InputStreamReader ! Easy to test. The Buffer class implements both BufferedSource and BufferedSink so your test code is simple and clear. Sources and sinks interoperate with InputStream and OutputStream . You can view any Source as an InputStream , and you can view any InputStream as a Source . Similarly for Sink and OutputStream . Presentations \u00b6 A Few \u201cOk\u201d Libraries ( slides ): An introduction to Okio and three libraries written with it. Decoding the Secrets of Binary Data ( slides ): How data encoding works and how Okio does it. Ok Multiplatform! ( slides ): How we changed Okio\u2019s implementation language from Java to Kotlin. Recipes \u00b6 We\u2019ve written some recipes that demonstrate how to solve common problems with Okio. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that\u2019s what they\u2019re for. Read a text file line-by-line ( Java / Kotlin ) \u00b6 Use Okio.source(File) to open a source stream to read a file. The returned Source interface is very small and has limited uses. Instead we wrap the source with a buffer. This has two benefits: It makes the API more powerful. Instead of the basic methods offered by Source , BufferedSource has dozens of methods to address most common problems concisely. It makes your program run faster. Buffering allows Okio to get more done with fewer I/O operations. Each Source that is opened needs to be closed. The code that opens the stream is responsible for making sure it is closed. Here we use Java\u2019s try blocks to close our sources automatically. public void readLines ( File file ) throws IOException { try ( Source fileSource = Okio . source ( file ); BufferedSource bufferedSource = Okio . buffer ( fileSource )) { while ( true ) { String line = bufferedSource . readUtf8Line (); if ( line == null ) break ; if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } Below is the same example written in Kotlin. Note that static Okio methods become extension functions ( Okio.source(file) => file.source() ), and use is used to automatically close the streams: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). use { fileSource -> fileSource . buffer (). use { bufferedFileSource -> while ( true ) { val line = bufferedFileSource . readUtf8Line () ?: break if ( \"square\" in line ) { println ( line ) } } } } } The readUtf8Line() API reads all of the data until the next line delimiter \u2013 either \\n , \\r\\n , or the end of the file. It returns that data as a string, omitting the delimiter at the end. When it encounters empty lines the method will return an empty string. If there isn\u2019t any more data to read it will return null. The above program can be written more compactly by inlining the fileSource variable and by using a fancy for loop instead of a while : public void readLines ( File file ) throws IOException { try ( BufferedSource source = Okio . buffer ( Okio . source ( file ))) { for ( String line ; ( line = source . readUtf8Line ()) != null ; ) { if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } In Kotlin, we can wrap invocations of source.readUtf8Line() into the generateSequence builder to create a sequence of lines that will end once null is returned. Plus, transforming streams is easy thanks to the extension functions: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). buffer (). use { source -> generateSequence { source . readUtf8Line () } . filter { line -> \"square\" in line } . forEach ( :: println ) } } The readUtf8Line() method is suitable for parsing most files. For certain use-cases you may also consider readUtf8LineStrict() . It is similar but it requires that each line is terminated by \\n or \\r\\n . If it encounters the end of the file before that it will throw an EOFException . The strict variant also permits a byte limit to defend against malformed input. public void readLines ( File file ) throws IOException { try ( BufferedSource source = Okio . buffer ( Okio . source ( file ))) { while ( ! source . exhausted ()) { String line = source . readUtf8LineStrict ( 1024L ); if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } Here\u2019s a similar example written in Kotlin: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). buffer (). use { source -> while (! source . exhausted ()) { val line = source . readUtf8LineStrict ( 1024 ) if ( \"square\" in line ) { println ( line ) } } } } Write a text file ( Java / Kotlin ) \u00b6 Above we used a Source and a BufferedSource to read a file. To write, we use a Sink and a BufferedSink . The advantages of buffering are the same: a more capable API and better performance. public void writeEnv ( File file ) throws IOException { try ( Sink fileSink = Okio . sink ( file ); BufferedSink bufferedSink = Okio . buffer ( fileSink )) { for ( Map . Entry < String , String > entry : System . getenv (). entrySet ()) { bufferedSink . writeUtf8 ( entry . getKey ()); bufferedSink . writeUtf8 ( \"=\" ); bufferedSink . writeUtf8 ( entry . getValue ()); bufferedSink . writeUtf8 ( \"\\n\" ); } } } There isn\u2019t an API to write a line of input; instead we manually insert our own newline character. Most programs should hardcode \"\\n\" as the newline character. In rare situations you may use System.lineSeparator() instead of \"\\n\" : it returns \"\\r\\n\" on Windows and \"\\n\" everywhere else. We can write the above program more compactly by inlining the fileSink variable and by taking advantage of method chaining: ```Java tab= public void writeEnv(File file) throws IOException { try (BufferedSink sink = Okio.buffer(Okio.sink(file))) { for (Map.Entry entry : System.getenv().entrySet()) { sink.writeUtf8(entry.getKey()) .writeUtf8(\u201c=\u201d) .writeUtf8(entry.getValue()) .writeUtf8(\u201c\\n\u201d); } } } ```Kotlin tab= @Throws(IOException::class) fun writeEnv(file: File) { file.sink().buffer().use { sink -> for ((key, value) in System.getenv()) { sink.writeUtf8(key) sink.writeUtf8(\"=\") sink.writeUtf8(value) sink.writeUtf8(\"\\n\") } } } In the above code we make four calls to writeUtf8() . Making four calls is more efficient than the code below because the VM doesn\u2019t have to create and garbage collect a temporary string. sink . writeUtf8 ( entry . getKey () + \"=\" + entry . getValue () + \"\\n\" ); // Slower! UTF-8 ( Java / Kotlin ) \u00b6 In the above APIs you can see that Okio really likes UTF-8. Early computer systems suffered many incompatible character encodings: ISO-8859-1, ShiftJIS, ASCII, EBCDIC, etc. Writing software to support multiple character sets was awful and we didn\u2019t even have emoji! Today we\u2019re lucky that the world has standardized on UTF-8 everywhere, with some rare uses of other charsets in legacy systems. If you need another character set, readString() and writeString() are there for you. These methods require that you specify a character set. Otherwise you may accidentally create data that is only readable by the local computer. Most programs should use the UTF-8 methods only. When encoding strings you need to be mindful of the different ways that strings are represented and encoded. When a glyph has an accent or another adornment it may be represented as a single complex code point ( \u00e9 ) or as a simple code point ( e ) followed by its modifiers ( \u00b4 ). When the entire glyph is a single code point that\u2019s called NFC ; when it\u2019s multiple it\u2019s NFD . Though we use UTF-8 whenever we read or write strings in I/O, when they are in memory Java Strings use an obsolete character encoding called UTF-16. It is a bad encoding because it uses a 16-bit char for most characters, but some don\u2019t fit. In particular, most emoji use two Java chars. This is problematic because String.length() returns a surprising result: the number of UTF-16 chars and not the natural number of glyphs. Caf\u00e9 \ud83c\udf69 Cafe\u0301 \ud83c\udf69 Form NFC NFD Code Points c a f \u00e9 \u2423 \ud83c\udf69 c a f e \u00b4 \u2423 \ud83c\udf69 UTF-8 bytes 43 61 66 c3a9 20 f09f8da9 43 61 66 65 cc81 20 f09f8da9 String.codePointCount 6 7 String.length 7 8 Utf8.size 10 11 For the most part Okio lets you ignore these problems and focus on your data. But when you need them, there are convenient APIs for dealing with low-level UTF-8 strings. Use Utf8.size() to count the number of bytes required to encode a string as UTF-8 without actually encoding it. This is handy in length-prefixed encodings like protocol buffers. Use BufferedSource.readUtf8CodePoint() to read a single variable-length code point, and BufferedSink.writeUtf8CodePoint() to write one. Golden Values ( Java / Kotlin ) \u00b6 Okio likes testing. The library itself is heavily tested, and it has features that are often helpful when testing application code. One pattern we\u2019ve found to be quite useful is \u201cgolden value\u201d testing. The goal of such tests is to confirm that data encoded with earlier versions of a program can safely be decoded by the current program. We\u2019ll illustrate this by encoding a value using Java Serialization. Though we must disclaim that Java Serialization is an awful encoding system and most programs should prefer other formats like JSON or protobuf! In any case, here\u2019s a method that takes an object, serializes it, and returns the result as a ByteString : ```Java tab= private ByteString serialize(Object o) throws IOException { Buffer buffer = new Buffer(); try (ObjectOutputStream objectOut = new ObjectOutputStream(buffer.outputStream())) { objectOut.writeObject(o); } return buffer.readByteString(); } ```Kotlin tab= @Throws(IOException::class) private fun serialize(o: Any?): ByteString { val buffer = Buffer() ObjectOutputStream(buffer.outputStream()).use { objectOut -> objectOut.writeObject(o) } return buffer.readByteString() } There\u2019s a lot going on here. We create a buffer as a holding space for our serialized data. It\u2019s a convenient replacement for ByteArrayOutputStream . We ask the buffer for its output stream. Writes to a buffer or its output stream always append data to the end of the buffer. We create an ObjectOutputStream (the encoding API for Java serialization) and write our object. The try block takes care of closing the stream for us. Note that closing a buffer has no effect. Finally we read a byte string from the buffer. The readByteString() method allows us to specify how many bytes to read; here we don\u2019t specify a count in order to read the entire thing. Reads from a buffer always consume data from the front of the buffer. With our serialize() method handy we are ready to compute and print a golden value. ```Java tab= Point point = new Point(8.0, 15.0); ByteString pointBytes = serialize(point); System.out.println(pointBytes.base64()); ```Kotlin tab= val point = Point(8.0, 15.0) val pointBytes = serialize(point) println(pointBytes.base64()) We print the ByteString as base64 because it\u2019s a compact format that\u2019s suitable for embedding in a test case. The program prints this: ```Java tab= rO0ABXNyAB5va2lvLnNhbXBsZXMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA ```Kotlin tab= rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA That\u2019s our golden value! We can embed it in our test case using base64 again to convert it back into a ByteString : ```Java tab= ByteString goldenBytes = ByteString.decodeBase64(\u201crO0ABXNyAB5va2lvLnNhbXBsZ\u201d + \u201cXMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuA\u201d + \u201cAAAAAAA\u201d); ```Kotlin tab= val goldenBytes = (\"rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAA\" + \"kQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA\").decodeBase64() The next step is to deserialize the ByteString back into our value class. This method reverses the serialize() method above: we append a byte string to a buffer then consume it using an ObjectInputStream : ```Java tab= private Object deserialize(ByteString byteString) throws IOException, ClassNotFoundException { Buffer buffer = new Buffer(); buffer.write(byteString); try (ObjectInputStream objectIn = new ObjectInputStream(buffer.inputStream())) { return objectIn.readObject(); } } ```Kotlin tab= @Throws(IOException::class, ClassNotFoundException::class) private fun deserialize(byteString: ByteString): Any? { val buffer = Buffer() buffer.write(byteString) ObjectInputStream(buffer.inputStream()).use { objectIn -> return objectIn.readObject() } } Now we can test the decoder against the golden value: ```Java tab= ByteString goldenBytes = ByteString.decodeBase64(\u201crO0ABXNyAB5va2lvLnNhbXBsZ\u201d + \u201cXMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuA\u201d + \u201cAAAAAAA\u201d); Point decoded = (Point) deserialize(goldenBytes); assertEquals(new Point(8.0, 15.0), decoded); ```Kotlin tab= val goldenBytes = (\"rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAA\" + \"kQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA\").decodeBase64()!! val decoded = deserialize(goldenBytes) as Point assertEquals(point, decoded) With this test we can change the serialization of the Point class without breaking compatibility. Write a binary file ( Java / Kotlin ) \u00b6 Encoding a binary file is not unlike encoding a text file. Okio uses the same BufferedSink and BufferedSource bytes for both. This is handy for binary formats that include both byte and character data. Writing binary data is more hazardous than text because if you make a mistake it is often quite difficult to diagnose. Avoid such mistakes by being careful around these traps: The width of each field. This is the number of bytes used. Okio doesn\u2019t include a mechanism to emit partial bytes. If you need that, you\u2019ll need to do your own bit shifting and masking before writing. The endianness of each field. All fields that have more than one byte have endianness : whether the bytes are ordered most-significant to least (big endian) or least-significant to most (little endian). Okio uses the Le suffix for little-endian methods; methods without a suffix are big-endian. Signed vs. Unsigned. Java doesn\u2019t have unsigned primitive types (except for char !) so coping with this is often something that happens at the application layer. To make this a little easier Okio accepts int types for writeByte() and writeShort() . You can pass an \u201cunsigned\u201d byte like 255 and Okio will do the right thing. Method Width Endianness Value Encoded Value writeByte 1 3 03 writeShort 2 big 3 00 03 writeInt 4 big 3 00 00 00 03 writeLong 8 big 3 00 00 00 00 00 00 00 03 writeShortLe 2 little 3 03 00 writeIntLe 4 little 3 03 00 00 00 writeLongLe 8 little 3 03 00 00 00 00 00 00 00 writeByte 1 Byte.MAX_VALUE 7f writeShort 2 big Short.MAX_VALUE 7f ff writeInt 4 big Int.MAX_VALUE 7f ff ff ff writeLong 8 big Long.MAX_VALUE 7f ff ff ff ff ff ff ff writeShortLe 2 little Short.MAX_VALUE ff 7f writeIntLe 4 little Int.MAX_VALUE ff ff ff 7f writeLongLe 8 little Long.MAX_VALUE ff ff ff ff ff ff ff 7f This code encodes a bitmap following the BMP file format . ```Java tab= void encode(Bitmap bitmap, BufferedSink sink) throws IOException { int height = bitmap.height(); int width = bitmap.width(); int bytesPerPixel = 3; int rowByteCountWithoutPadding = (bytesPerPixel * width); int rowByteCount = ((rowByteCountWithoutPadding + 3) / 4) * 4; int pixelDataSize = rowByteCount * height; int bmpHeaderSize = 14; int dibHeaderSize = 40; // BMP Header sink.writeUtf8(\u201cBM\u201d); // ID. sink.writeIntLe(bmpHeaderSize + dibHeaderSize + pixelDataSize); // File size. sink.writeShortLe(0); // Unused. sink.writeShortLe(0); // Unused. sink.writeIntLe(bmpHeaderSize + dibHeaderSize); // Offset of pixel data. // DIB Header sink.writeIntLe(dibHeaderSize); sink.writeIntLe(width); sink.writeIntLe(height); sink.writeShortLe(1); // Color plane count. sink.writeShortLe(bytesPerPixel * Byte.SIZE); sink.writeIntLe(0); // No compression. sink.writeIntLe(16); // Size of bitmap data including padding. sink.writeIntLe(2835); // Horizontal print resolution in pixels/meter. (72 dpi). sink.writeIntLe(2835); // Vertical print resolution in pixels/meter. (72 dpi). sink.writeIntLe(0); // Palette color count. sink.writeIntLe(0); // 0 important colors. // Pixel data. for (int y = height - 1; y >= 0; y\u2013) { for (int x = 0; x < width; x++) { sink.writeByte(bitmap.blue(x, y)); sink.writeByte(bitmap.green(x, y)); sink.writeByte(bitmap.red(x, y)); } // Padding for 4-byte alignment. for (int p = rowByteCountWithoutPadding; p < rowByteCount; p++) { sink.writeByte(0); } } } Kotlin tab= @Throws(IOException::class) fun encode(bitmap: Bitmap, sink: BufferedSink) { val height = bitmap.height val width = bitmap.width val bytesPerPixel = 3 val rowByteCountWithoutPadding = bytesPerPixel * width val rowByteCount = (rowByteCountWithoutPadding + 3) / 4 * 4 val pixelDataSize = rowByteCount * height val bmpHeaderSize = 14 val dibHeaderSize = 40 // BMP Header sink.writeUtf8(\u201cBM\u201d) // ID. sink.writeIntLe(bmpHeaderSize + dibHeaderSize + pixelDataSize) // File size. sink.writeShortLe(0) // Unused. sink.writeShortLe(0) // Unused. sink.writeIntLe(bmpHeaderSize + dibHeaderSize) // Offset of pixel data. // DIB Header sink.writeIntLe(dibHeaderSize) sink.writeIntLe(width) sink.writeIntLe(height) sink.writeShortLe(1) // Color plane count. sink.writeShortLe(bytesPerPixel * Byte.SIZE_BITS) sink.writeIntLe(0) // No compression. sink.writeIntLe(16) // Size of bitmap data including padding. sink.writeIntLe(2835) // Horizontal print resolution in pixels/meter. (72 dpi). sink.writeIntLe(2835) // Vertical print resolution in pixels/meter. (72 dpi). sink.writeIntLe(0) // Palette color count. sink.writeIntLe(0) // 0 important colors. // Pixel data. for (y in height - 1 downTo 0) { for (x in 0 until width) { sink.writeByte(bitmap.blue(x, y)) sink.writeByte(bitmap.green(x, y)) sink.writeByte(bitmap.red(x, y)) } // Padding for 4-byte alignment. for (p in rowByteCountWithoutPadding until rowByteCount) { sink.writeByte(0) } } } ``` The trickiest part of this program is the format\u2019s required padding. The BMP format expects each row to begin on a 4-byte boundary so it is necessary to add zeros to maintain the alignment. Encoding other binary formats is usually quite similar. Some tips: Write tests with golden values! Confirming that your program emits the expected result can make debugging easier. Use Utf8.size() to compute the number of bytes of an encoded string. This is essential for length-prefixed formats. Use Float.floatToIntBits() and Double.doubleToLongBits() to encode floating point values. Communicate on a Socket ( Java / Kotlin ) \u00b6 Sending and receiving data over the network is a bit like writing and reading files. We use BufferedSink to encode output and BufferedSource to decode input. Like files, network protocols can be text, binary, or a mix of both. But there are also some substantial differences between the network and the filesystem. With a file you\u2019re either reading or writing but with the network you can do both! Some protocols handle this by taking turns: write a request, read a response, repeat. You can implement this kind of protocol with a single thread. In other protocols you may read and write simultaneously. Typically you\u2019ll want one dedicated thread for reading. For writing you can use either a dedicated thread or use synchronized so that multiple threads can share a sink. Okio\u2019s streams are not safe for concurrent use. Sinks buffer outbound data to minimize I/O operations. This is efficient but it means you must manually call flush() to transmit data. Typically message-oriented protocols flush after each message. Note that Okio will automatically flush when the buffered data exceeds some threshold. This is intended to save memory and you shouldn\u2019t rely on it for interactive protocols. Okio builds on java.io.Socket for connectivity. Create your socket as a server or as a client, then use Okio.source(Socket) to read and Okio.sink(Socket) to write. These APIs also work with SSLSocket . You should use SSL unless you have a very good reason not to! Cancel a socket from any thread by calling Socket.close() ; this will cause its sources and sinks to immediately fail with an IOException . You can also configure timeouts for all socket operations. You don\u2019t need a reference to the socket to adjust timeouts: Source and Sink expose timeouts directly. This API works even if the streams are decorated. As a complete example of networking with Okio we wrote a basic SOCKS proxy server. Some highlights: ```Java tab= Socket fromSocket = \u2026 BufferedSource fromSource = Okio.buffer(Okio.source(fromSocket)); BufferedSink fromSink = Okio.buffer(Okio.sink(fromSocket)); ```Kotlin tab= val fromSocket: Socket = ... val fromSource = fromSocket.source().buffer() val fromSink = fromSocket.sink().buffer() Creating sources and sinks for sockets is the same as creating them for files. Once you create a Source or Sink for a socket you must not use its InputStream or OutputStream , respectively. ```Java tab= Buffer buffer = new Buffer(); for (long byteCount; (byteCount = source.read(buffer, 8192L)) != -1; ) { sink.write(buffer, byteCount); sink.flush(); } ```Kotlin tab= val buffer = Buffer() var byteCount: Long while (source.read(buffer, 8192L).also { byteCount = it } != -1L) { sink.write(buffer, byteCount) sink.flush() } The above loop copies data from the source to the sink, flushing after each read. If we didn\u2019t need the flushing we could replace this loop with a single call to BufferedSink.writeAll(Source) . The 8192 argument to read() is the maximum number of bytes to read before returning. We could have passed any value here, but we like 8 KiB because that\u2019s the largest value Okio can do in a single system call. Most of the time application code doesn\u2019t need to deal with such limits! ```Java tab= int addressType = fromSource.readByte() & 0xff; int port = fromSource.readShort() & 0xffff; ```Kotlin tab= val addressType = fromSource.readByte().toInt() and 0xff val port = fromSource.readShort().toInt() and 0xffff Okio uses signed types like byte and short , but often protocols want unsigned values. The bitwise & operator is Java\u2019s preferred idiom to convert a signed value into an unsigned value. Here\u2019s a cheat sheet for bytes, shorts, and ints: Type Signed Range Unsigned Range Signed to Unsigned byte -128..127 0..255 int u = s & 0xff; short -32,768..32,767 0..65,535 int u = s & 0xffff; int -2,147,483,648..2,147,483,647 0..4,294,967,295 long u = s & 0xffffffffL; Java has no primitive type that can represent unsigned longs. Hashing ( Java / Kotlin ) \u00b6 We\u2019re bombarded by hashing in our lives as Java programmers. Early on we\u2019re introduced to the hashCode() method, something we know we need to override otherwise unforeseen bad things happen. Later we\u2019re shown LinkedHashMap and its friends. These build on that hashCode() method to organize data for fast retrieval. Elsewhere we have cryptographic hash functions. These get used all over the place. HTTPS certificates, Git commits, BitTorrent integrity checking, and Blockchain blocks all use cryptographic hashes. Good use of hashes can improve the performance, privacy, security, and simplicity of an application. Each cryptographic hash function accepts a variable-length stream of input bytes and produces a fixed-length byte string value called the \u201chash\u201d. Hash functions have these important qualities: Deterministic: each input always produces the same output. Uniform: each output byte string is equally likely. It is very difficult to find or create pairs of different inputs that yield the same output. This is called a \u201ccollision\u201d. Non-reversible: knowing an output doesn\u2019t help you to find the input. Note that if you know some possible inputs you can hash them to see if their hashes match. Well-known: the hash is implemented everywhere and rigorously understood. Good hash functions are very cheap to compute (dozens of microseconds) and expensive to reverse (quintillions of millenia). Steady advances in computing and mathematics have caused once-great hash functions to become inexpensive to reverse. When choosing a hash function, beware that not all are created equal! Okio supports these well-known cryptographic hash functions: MD5 : a 128-bit (16 byte) cryptographic hash. It is both insecure and obsolete because it is inexpensive to reverse! This hash is offered because it is popular and convenient for use in legacy systems that are not security-sensitive. SHA-1 : a 160-bit (20 byte) cryptographic hash. It was recently demonstrated that it is feasible to create SHA-1 collisions. Consider upgrading from SHA-1 to SHA-256. SHA-256 : a 256-bit (32 byte) cryptographic hash. SHA-256 is widely understood and expensive to reverse. This is the hash most systems should use. SHA-512 : a 512-bit (64 byte) cryptographic hash. It is expensive to reverse. Each hash creates a ByteString of the specified length. Use hex() to get the conventional human-readable form. Or leave it as a ByteString because that\u2019s a convenient model type! Okio can produce cryptographic hashes from byte strings: ```Java tab= ByteString byteString = readByteString(new File(\u201cREADME.md\u201d)); System.out.println(\u201d md5: \u201d + byteString.md5().hex()); System.out.println(\u201d sha1: \u201d + byteString.sha1().hex()); System.out.println(\u201csha256: \u201d + byteString.sha256().hex()); System.out.println(\u201csha512: \u201d + byteString.sha512().hex()); ```Kotlin tab= val byteString = readByteString(File(\"README.md\")) println(\" md5: \" + byteString.md5().hex()) println(\" sha1: \" + byteString.sha1().hex()) println(\" sha256: \" + byteString.sha256().hex()) println(\" sha512: \" + byteString.sha512().hex()) From buffers: ```Java tab= Buffer buffer = readBuffer(new File(\u201cREADME.md\u201d)); System.out.println(\u201d md5: \u201d + buffer.md5().hex()); System.out.println(\u201d sha1: \u201d + buffer.sha1().hex()); System.out.println(\u201csha256: \u201d + buffer.sha256().hex()); System.out.println(\u201csha512: \u201d + buffer.sha512().hex()); ```Kotlin tab= val buffer = readBuffer(File(\"README.md\")) println(\" md5: \" + buffer.md5().hex()) println(\" sha1: \" + buffer.sha1().hex()) println(\" sha256: \" + buffer.sha256().hex()) println(\" sha512: \" + buffer.sha512().hex()) While streaming from a source: ```Java tab= try (HashingSink hashingSink = HashingSink.sha256(Okio.blackhole()); BufferedSource source = Okio.buffer(Okio.source(file))) { source.readAll(hashingSink); System.out.println(\u201csha256: \u201d + hashingSink.hash().hex()); } ```Kotlin tab= sha256(blackholeSink()).use { hashingSink -> file.source().buffer().use { source -> source.readAll(hashingSink) println(\" sha256: \" + hashingSink.hash.hex()) } } While streaming to a sink: ```Java tab= try (HashingSink hashingSink = HashingSink.sha256(Okio.blackhole()); BufferedSink sink = Okio.buffer(hashingSink); Source source = Okio.source(file)) { sink.writeAll(source); sink.close(); // Emit anything buffered. System.out.println(\u201csha256: \u201d + hashingSink.hash().hex()); } ```Kotlin tab= sha256(blackholeSink()).use { hashingSink -> hashingSink.buffer().use { sink -> file.source().use { source -> sink.writeAll(source) sink.close() // Emit anything buffered. println(\" sha256: \" + hashingSink.hash.hex()) } } } Okio also supports HMAC (Hash Message Authentication Code) which combines a secret and a hash. Applications use HMAC for data integrity and authentication. ```Java tab= ByteString secret = ByteString.decodeHex(\u201c7065616e7574627574746572\u201d); System.out.println(\u201chmacSha256: \u201d + byteString.hmacSha256(secret).hex()); ```Kotlin tab= val secret = \"7065616e7574627574746572\".decodeHex() println(\"hmacSha256: \" + byteString.hmacSha256(secret).hex()) As with hashing, you can generate an HMAC from a ByteString , Buffer , HashingSource , and HashingSink . Note that Okio doesn\u2019t implement HMAC for MD5. Okio uses Java\u2019s java.security.MessageDigest for cryptographic hashes and javax.crypto.Mac for HMAC. Releases \u00b6 Our change log has release history. implementation ( \"com.squareup.okio:okio:2.7.0\" ) Snapshot builds are also available repositories { maven { url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots/\" ) } } dependencies { implementation ( \"com.squareup.okio:okio:2.7.0\" ) } R8 / ProGuard \u00b6 If you are using R8 or ProGuard add the options from this file . License \u00b6 Copyright 2013 Square, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#okio","text":"Okio is a library that complements java.io and java.nio to make it much easier to access, store, and process your data. It started as a component of OkHttp , the capable HTTP client included in Android. It\u2019s well-exercised and ready to solve new problems.","title":"Okio"},{"location":"#bytestrings-and-buffers","text":"Okio is built around two types that pack a lot of capability into a straightforward API: ByteString is an immutable sequence of bytes. For character data, String is fundamental. ByteString is String\u2019s long-lost brother, making it easy to treat binary data as a value. This class is ergonomic: it knows how to encode and decode itself as hex, base64, and UTF-8. Buffer is a mutable sequence of bytes. Like ArrayList , you don\u2019t need to size your buffer in advance. You read and write buffers as a queue: write data to the end and read it from the front. There\u2019s no obligation to manage positions, limits, or capacities. Internally, ByteString and Buffer do some clever things to save CPU and memory. If you encode a UTF-8 string as a ByteString , it caches a reference to that string so that if you decode it later, there\u2019s no work to do. Buffer is implemented as a linked list of segments. When you move data from one buffer to another, it reassigns ownership of the segments rather than copying the data across. This approach is particularly helpful for multithreaded programs: a thread that talks to the network can exchange data with a worker thread without any copying or ceremony.","title":"ByteStrings and Buffers"},{"location":"#sources-and-sinks","text":"An elegant part of the java.io design is how streams can be layered for transformations like encryption and compression. Okio includes its own stream types called Source and Sink that work like InputStream and OutputStream , but with some key differences: Timeouts. The streams provide access to the timeouts of the underlying I/O mechanism. Unlike the java.io socket streams, both read() and write() calls honor timeouts. Easy to implement. Source declares three methods: read() , close() , and timeout() . There are no hazards like available() or single-byte reads that cause correctness and performance surprises. Easy to use. Although implementations of Source and Sink have only three methods to write, callers are given a rich API with the BufferedSource and BufferedSink interfaces. These interfaces give you everything you need in one place. No artificial distinction between byte streams and char streams. It\u2019s all data. Read and write it as bytes, UTF-8 strings, big-endian 32-bit integers, little-endian shorts; whatever you want. No more InputStreamReader ! Easy to test. The Buffer class implements both BufferedSource and BufferedSink so your test code is simple and clear. Sources and sinks interoperate with InputStream and OutputStream . You can view any Source as an InputStream , and you can view any InputStream as a Source . Similarly for Sink and OutputStream .","title":"Sources and Sinks"},{"location":"#presentations","text":"A Few \u201cOk\u201d Libraries ( slides ): An introduction to Okio and three libraries written with it. Decoding the Secrets of Binary Data ( slides ): How data encoding works and how Okio does it. Ok Multiplatform! ( slides ): How we changed Okio\u2019s implementation language from Java to Kotlin.","title":"Presentations"},{"location":"#recipes","text":"We\u2019ve written some recipes that demonstrate how to solve common problems with Okio. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that\u2019s what they\u2019re for.","title":"Recipes"},{"location":"#read-a-text-file-line-by-line-javakotlin","text":"Use Okio.source(File) to open a source stream to read a file. The returned Source interface is very small and has limited uses. Instead we wrap the source with a buffer. This has two benefits: It makes the API more powerful. Instead of the basic methods offered by Source , BufferedSource has dozens of methods to address most common problems concisely. It makes your program run faster. Buffering allows Okio to get more done with fewer I/O operations. Each Source that is opened needs to be closed. The code that opens the stream is responsible for making sure it is closed. Here we use Java\u2019s try blocks to close our sources automatically. public void readLines ( File file ) throws IOException { try ( Source fileSource = Okio . source ( file ); BufferedSource bufferedSource = Okio . buffer ( fileSource )) { while ( true ) { String line = bufferedSource . readUtf8Line (); if ( line == null ) break ; if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } Below is the same example written in Kotlin. Note that static Okio methods become extension functions ( Okio.source(file) => file.source() ), and use is used to automatically close the streams: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). use { fileSource -> fileSource . buffer (). use { bufferedFileSource -> while ( true ) { val line = bufferedFileSource . readUtf8Line () ?: break if ( \"square\" in line ) { println ( line ) } } } } } The readUtf8Line() API reads all of the data until the next line delimiter \u2013 either \\n , \\r\\n , or the end of the file. It returns that data as a string, omitting the delimiter at the end. When it encounters empty lines the method will return an empty string. If there isn\u2019t any more data to read it will return null. The above program can be written more compactly by inlining the fileSource variable and by using a fancy for loop instead of a while : public void readLines ( File file ) throws IOException { try ( BufferedSource source = Okio . buffer ( Okio . source ( file ))) { for ( String line ; ( line = source . readUtf8Line ()) != null ; ) { if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } In Kotlin, we can wrap invocations of source.readUtf8Line() into the generateSequence builder to create a sequence of lines that will end once null is returned. Plus, transforming streams is easy thanks to the extension functions: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). buffer (). use { source -> generateSequence { source . readUtf8Line () } . filter { line -> \"square\" in line } . forEach ( :: println ) } } The readUtf8Line() method is suitable for parsing most files. For certain use-cases you may also consider readUtf8LineStrict() . It is similar but it requires that each line is terminated by \\n or \\r\\n . If it encounters the end of the file before that it will throw an EOFException . The strict variant also permits a byte limit to defend against malformed input. public void readLines ( File file ) throws IOException { try ( BufferedSource source = Okio . buffer ( Okio . source ( file ))) { while ( ! source . exhausted ()) { String line = source . readUtf8LineStrict ( 1024L ); if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } Here\u2019s a similar example written in Kotlin: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). buffer (). use { source -> while (! source . exhausted ()) { val line = source . readUtf8LineStrict ( 1024 ) if ( \"square\" in line ) { println ( line ) } } } }","title":"Read a text file line-by-line (Java/Kotlin)"},{"location":"#write-a-text-file-javakotlin","text":"Above we used a Source and a BufferedSource to read a file. To write, we use a Sink and a BufferedSink . The advantages of buffering are the same: a more capable API and better performance. public void writeEnv ( File file ) throws IOException { try ( Sink fileSink = Okio . sink ( file ); BufferedSink bufferedSink = Okio . buffer ( fileSink )) { for ( Map . Entry < String , String > entry : System . getenv (). entrySet ()) { bufferedSink . writeUtf8 ( entry . getKey ()); bufferedSink . writeUtf8 ( \"=\" ); bufferedSink . writeUtf8 ( entry . getValue ()); bufferedSink . writeUtf8 ( \"\\n\" ); } } } There isn\u2019t an API to write a line of input; instead we manually insert our own newline character. Most programs should hardcode \"\\n\" as the newline character. In rare situations you may use System.lineSeparator() instead of \"\\n\" : it returns \"\\r\\n\" on Windows and \"\\n\" everywhere else. We can write the above program more compactly by inlining the fileSink variable and by taking advantage of method chaining: ```Java tab= public void writeEnv(File file) throws IOException { try (BufferedSink sink = Okio.buffer(Okio.sink(file))) { for (Map.Entry entry : System.getenv().entrySet()) { sink.writeUtf8(entry.getKey()) .writeUtf8(\u201c=\u201d) .writeUtf8(entry.getValue()) .writeUtf8(\u201c\\n\u201d); } } } ```Kotlin tab= @Throws(IOException::class) fun writeEnv(file: File) { file.sink().buffer().use { sink -> for ((key, value) in System.getenv()) { sink.writeUtf8(key) sink.writeUtf8(\"=\") sink.writeUtf8(value) sink.writeUtf8(\"\\n\") } } } In the above code we make four calls to writeUtf8() . Making four calls is more efficient than the code below because the VM doesn\u2019t have to create and garbage collect a temporary string. sink . writeUtf8 ( entry . getKey () + \"=\" + entry . getValue () + \"\\n\" ); // Slower!","title":"Write a text file (Java/Kotlin)"},{"location":"#utf-8-javakotlin","text":"In the above APIs you can see that Okio really likes UTF-8. Early computer systems suffered many incompatible character encodings: ISO-8859-1, ShiftJIS, ASCII, EBCDIC, etc. Writing software to support multiple character sets was awful and we didn\u2019t even have emoji! Today we\u2019re lucky that the world has standardized on UTF-8 everywhere, with some rare uses of other charsets in legacy systems. If you need another character set, readString() and writeString() are there for you. These methods require that you specify a character set. Otherwise you may accidentally create data that is only readable by the local computer. Most programs should use the UTF-8 methods only. When encoding strings you need to be mindful of the different ways that strings are represented and encoded. When a glyph has an accent or another adornment it may be represented as a single complex code point ( \u00e9 ) or as a simple code point ( e ) followed by its modifiers ( \u00b4 ). When the entire glyph is a single code point that\u2019s called NFC ; when it\u2019s multiple it\u2019s NFD . Though we use UTF-8 whenever we read or write strings in I/O, when they are in memory Java Strings use an obsolete character encoding called UTF-16. It is a bad encoding because it uses a 16-bit char for most characters, but some don\u2019t fit. In particular, most emoji use two Java chars. This is problematic because String.length() returns a surprising result: the number of UTF-16 chars and not the natural number of glyphs. Caf\u00e9 \ud83c\udf69 Cafe\u0301 \ud83c\udf69 Form NFC NFD Code Points c a f \u00e9 \u2423 \ud83c\udf69 c a f e \u00b4 \u2423 \ud83c\udf69 UTF-8 bytes 43 61 66 c3a9 20 f09f8da9 43 61 66 65 cc81 20 f09f8da9 String.codePointCount 6 7 String.length 7 8 Utf8.size 10 11 For the most part Okio lets you ignore these problems and focus on your data. But when you need them, there are convenient APIs for dealing with low-level UTF-8 strings. Use Utf8.size() to count the number of bytes required to encode a string as UTF-8 without actually encoding it. This is handy in length-prefixed encodings like protocol buffers. Use BufferedSource.readUtf8CodePoint() to read a single variable-length code point, and BufferedSink.writeUtf8CodePoint() to write one.","title":"UTF-8 (Java/Kotlin)"},{"location":"#golden-values-javakotlin","text":"Okio likes testing. The library itself is heavily tested, and it has features that are often helpful when testing application code. One pattern we\u2019ve found to be quite useful is \u201cgolden value\u201d testing. The goal of such tests is to confirm that data encoded with earlier versions of a program can safely be decoded by the current program. We\u2019ll illustrate this by encoding a value using Java Serialization. Though we must disclaim that Java Serialization is an awful encoding system and most programs should prefer other formats like JSON or protobuf! In any case, here\u2019s a method that takes an object, serializes it, and returns the result as a ByteString : ```Java tab= private ByteString serialize(Object o) throws IOException { Buffer buffer = new Buffer(); try (ObjectOutputStream objectOut = new ObjectOutputStream(buffer.outputStream())) { objectOut.writeObject(o); } return buffer.readByteString(); } ```Kotlin tab= @Throws(IOException::class) private fun serialize(o: Any?): ByteString { val buffer = Buffer() ObjectOutputStream(buffer.outputStream()).use { objectOut -> objectOut.writeObject(o) } return buffer.readByteString() } There\u2019s a lot going on here. We create a buffer as a holding space for our serialized data. It\u2019s a convenient replacement for ByteArrayOutputStream . We ask the buffer for its output stream. Writes to a buffer or its output stream always append data to the end of the buffer. We create an ObjectOutputStream (the encoding API for Java serialization) and write our object. The try block takes care of closing the stream for us. Note that closing a buffer has no effect. Finally we read a byte string from the buffer. The readByteString() method allows us to specify how many bytes to read; here we don\u2019t specify a count in order to read the entire thing. Reads from a buffer always consume data from the front of the buffer. With our serialize() method handy we are ready to compute and print a golden value. ```Java tab= Point point = new Point(8.0, 15.0); ByteString pointBytes = serialize(point); System.out.println(pointBytes.base64()); ```Kotlin tab= val point = Point(8.0, 15.0) val pointBytes = serialize(point) println(pointBytes.base64()) We print the ByteString as base64 because it\u2019s a compact format that\u2019s suitable for embedding in a test case. The program prints this: ```Java tab= rO0ABXNyAB5va2lvLnNhbXBsZXMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA ```Kotlin tab= rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA That\u2019s our golden value! We can embed it in our test case using base64 again to convert it back into a ByteString : ```Java tab= ByteString goldenBytes = ByteString.decodeBase64(\u201crO0ABXNyAB5va2lvLnNhbXBsZ\u201d + \u201cXMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuA\u201d + \u201cAAAAAAA\u201d); ```Kotlin tab= val goldenBytes = (\"rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAA\" + \"kQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA\").decodeBase64() The next step is to deserialize the ByteString back into our value class. This method reverses the serialize() method above: we append a byte string to a buffer then consume it using an ObjectInputStream : ```Java tab= private Object deserialize(ByteString byteString) throws IOException, ClassNotFoundException { Buffer buffer = new Buffer(); buffer.write(byteString); try (ObjectInputStream objectIn = new ObjectInputStream(buffer.inputStream())) { return objectIn.readObject(); } } ```Kotlin tab= @Throws(IOException::class, ClassNotFoundException::class) private fun deserialize(byteString: ByteString): Any? { val buffer = Buffer() buffer.write(byteString) ObjectInputStream(buffer.inputStream()).use { objectIn -> return objectIn.readObject() } } Now we can test the decoder against the golden value: ```Java tab= ByteString goldenBytes = ByteString.decodeBase64(\u201crO0ABXNyAB5va2lvLnNhbXBsZ\u201d + \u201cXMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuA\u201d + \u201cAAAAAAA\u201d); Point decoded = (Point) deserialize(goldenBytes); assertEquals(new Point(8.0, 15.0), decoded); ```Kotlin tab= val goldenBytes = (\"rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAA\" + \"kQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA\").decodeBase64()!! val decoded = deserialize(goldenBytes) as Point assertEquals(point, decoded) With this test we can change the serialization of the Point class without breaking compatibility.","title":"Golden Values (Java/Kotlin)"},{"location":"#write-a-binary-file-javakotlin","text":"Encoding a binary file is not unlike encoding a text file. Okio uses the same BufferedSink and BufferedSource bytes for both. This is handy for binary formats that include both byte and character data. Writing binary data is more hazardous than text because if you make a mistake it is often quite difficult to diagnose. Avoid such mistakes by being careful around these traps: The width of each field. This is the number of bytes used. Okio doesn\u2019t include a mechanism to emit partial bytes. If you need that, you\u2019ll need to do your own bit shifting and masking before writing. The endianness of each field. All fields that have more than one byte have endianness : whether the bytes are ordered most-significant to least (big endian) or least-significant to most (little endian). Okio uses the Le suffix for little-endian methods; methods without a suffix are big-endian. Signed vs. Unsigned. Java doesn\u2019t have unsigned primitive types (except for char !) so coping with this is often something that happens at the application layer. To make this a little easier Okio accepts int types for writeByte() and writeShort() . You can pass an \u201cunsigned\u201d byte like 255 and Okio will do the right thing. Method Width Endianness Value Encoded Value writeByte 1 3 03 writeShort 2 big 3 00 03 writeInt 4 big 3 00 00 00 03 writeLong 8 big 3 00 00 00 00 00 00 00 03 writeShortLe 2 little 3 03 00 writeIntLe 4 little 3 03 00 00 00 writeLongLe 8 little 3 03 00 00 00 00 00 00 00 writeByte 1 Byte.MAX_VALUE 7f writeShort 2 big Short.MAX_VALUE 7f ff writeInt 4 big Int.MAX_VALUE 7f ff ff ff writeLong 8 big Long.MAX_VALUE 7f ff ff ff ff ff ff ff writeShortLe 2 little Short.MAX_VALUE ff 7f writeIntLe 4 little Int.MAX_VALUE ff ff ff 7f writeLongLe 8 little Long.MAX_VALUE ff ff ff ff ff ff ff 7f This code encodes a bitmap following the BMP file format . ```Java tab= void encode(Bitmap bitmap, BufferedSink sink) throws IOException { int height = bitmap.height(); int width = bitmap.width(); int bytesPerPixel = 3; int rowByteCountWithoutPadding = (bytesPerPixel * width); int rowByteCount = ((rowByteCountWithoutPadding + 3) / 4) * 4; int pixelDataSize = rowByteCount * height; int bmpHeaderSize = 14; int dibHeaderSize = 40; // BMP Header sink.writeUtf8(\u201cBM\u201d); // ID. sink.writeIntLe(bmpHeaderSize + dibHeaderSize + pixelDataSize); // File size. sink.writeShortLe(0); // Unused. sink.writeShortLe(0); // Unused. sink.writeIntLe(bmpHeaderSize + dibHeaderSize); // Offset of pixel data. // DIB Header sink.writeIntLe(dibHeaderSize); sink.writeIntLe(width); sink.writeIntLe(height); sink.writeShortLe(1); // Color plane count. sink.writeShortLe(bytesPerPixel * Byte.SIZE); sink.writeIntLe(0); // No compression. sink.writeIntLe(16); // Size of bitmap data including padding. sink.writeIntLe(2835); // Horizontal print resolution in pixels/meter. (72 dpi). sink.writeIntLe(2835); // Vertical print resolution in pixels/meter. (72 dpi). sink.writeIntLe(0); // Palette color count. sink.writeIntLe(0); // 0 important colors. // Pixel data. for (int y = height - 1; y >= 0; y\u2013) { for (int x = 0; x < width; x++) { sink.writeByte(bitmap.blue(x, y)); sink.writeByte(bitmap.green(x, y)); sink.writeByte(bitmap.red(x, y)); } // Padding for 4-byte alignment. for (int p = rowByteCountWithoutPadding; p < rowByteCount; p++) { sink.writeByte(0); } } } Kotlin tab= @Throws(IOException::class) fun encode(bitmap: Bitmap, sink: BufferedSink) { val height = bitmap.height val width = bitmap.width val bytesPerPixel = 3 val rowByteCountWithoutPadding = bytesPerPixel * width val rowByteCount = (rowByteCountWithoutPadding + 3) / 4 * 4 val pixelDataSize = rowByteCount * height val bmpHeaderSize = 14 val dibHeaderSize = 40 // BMP Header sink.writeUtf8(\u201cBM\u201d) // ID. sink.writeIntLe(bmpHeaderSize + dibHeaderSize + pixelDataSize) // File size. sink.writeShortLe(0) // Unused. sink.writeShortLe(0) // Unused. sink.writeIntLe(bmpHeaderSize + dibHeaderSize) // Offset of pixel data. // DIB Header sink.writeIntLe(dibHeaderSize) sink.writeIntLe(width) sink.writeIntLe(height) sink.writeShortLe(1) // Color plane count. sink.writeShortLe(bytesPerPixel * Byte.SIZE_BITS) sink.writeIntLe(0) // No compression. sink.writeIntLe(16) // Size of bitmap data including padding. sink.writeIntLe(2835) // Horizontal print resolution in pixels/meter. (72 dpi). sink.writeIntLe(2835) // Vertical print resolution in pixels/meter. (72 dpi). sink.writeIntLe(0) // Palette color count. sink.writeIntLe(0) // 0 important colors. // Pixel data. for (y in height - 1 downTo 0) { for (x in 0 until width) { sink.writeByte(bitmap.blue(x, y)) sink.writeByte(bitmap.green(x, y)) sink.writeByte(bitmap.red(x, y)) } // Padding for 4-byte alignment. for (p in rowByteCountWithoutPadding until rowByteCount) { sink.writeByte(0) } } } ``` The trickiest part of this program is the format\u2019s required padding. The BMP format expects each row to begin on a 4-byte boundary so it is necessary to add zeros to maintain the alignment. Encoding other binary formats is usually quite similar. Some tips: Write tests with golden values! Confirming that your program emits the expected result can make debugging easier. Use Utf8.size() to compute the number of bytes of an encoded string. This is essential for length-prefixed formats. Use Float.floatToIntBits() and Double.doubleToLongBits() to encode floating point values.","title":"Write a binary file (Java/Kotlin)"},{"location":"#communicate-on-a-socket-javakotlin","text":"Sending and receiving data over the network is a bit like writing and reading files. We use BufferedSink to encode output and BufferedSource to decode input. Like files, network protocols can be text, binary, or a mix of both. But there are also some substantial differences between the network and the filesystem. With a file you\u2019re either reading or writing but with the network you can do both! Some protocols handle this by taking turns: write a request, read a response, repeat. You can implement this kind of protocol with a single thread. In other protocols you may read and write simultaneously. Typically you\u2019ll want one dedicated thread for reading. For writing you can use either a dedicated thread or use synchronized so that multiple threads can share a sink. Okio\u2019s streams are not safe for concurrent use. Sinks buffer outbound data to minimize I/O operations. This is efficient but it means you must manually call flush() to transmit data. Typically message-oriented protocols flush after each message. Note that Okio will automatically flush when the buffered data exceeds some threshold. This is intended to save memory and you shouldn\u2019t rely on it for interactive protocols. Okio builds on java.io.Socket for connectivity. Create your socket as a server or as a client, then use Okio.source(Socket) to read and Okio.sink(Socket) to write. These APIs also work with SSLSocket . You should use SSL unless you have a very good reason not to! Cancel a socket from any thread by calling Socket.close() ; this will cause its sources and sinks to immediately fail with an IOException . You can also configure timeouts for all socket operations. You don\u2019t need a reference to the socket to adjust timeouts: Source and Sink expose timeouts directly. This API works even if the streams are decorated. As a complete example of networking with Okio we wrote a basic SOCKS proxy server. Some highlights: ```Java tab= Socket fromSocket = \u2026 BufferedSource fromSource = Okio.buffer(Okio.source(fromSocket)); BufferedSink fromSink = Okio.buffer(Okio.sink(fromSocket)); ```Kotlin tab= val fromSocket: Socket = ... val fromSource = fromSocket.source().buffer() val fromSink = fromSocket.sink().buffer() Creating sources and sinks for sockets is the same as creating them for files. Once you create a Source or Sink for a socket you must not use its InputStream or OutputStream , respectively. ```Java tab= Buffer buffer = new Buffer(); for (long byteCount; (byteCount = source.read(buffer, 8192L)) != -1; ) { sink.write(buffer, byteCount); sink.flush(); } ```Kotlin tab= val buffer = Buffer() var byteCount: Long while (source.read(buffer, 8192L).also { byteCount = it } != -1L) { sink.write(buffer, byteCount) sink.flush() } The above loop copies data from the source to the sink, flushing after each read. If we didn\u2019t need the flushing we could replace this loop with a single call to BufferedSink.writeAll(Source) . The 8192 argument to read() is the maximum number of bytes to read before returning. We could have passed any value here, but we like 8 KiB because that\u2019s the largest value Okio can do in a single system call. Most of the time application code doesn\u2019t need to deal with such limits! ```Java tab= int addressType = fromSource.readByte() & 0xff; int port = fromSource.readShort() & 0xffff; ```Kotlin tab= val addressType = fromSource.readByte().toInt() and 0xff val port = fromSource.readShort().toInt() and 0xffff Okio uses signed types like byte and short , but often protocols want unsigned values. The bitwise & operator is Java\u2019s preferred idiom to convert a signed value into an unsigned value. Here\u2019s a cheat sheet for bytes, shorts, and ints: Type Signed Range Unsigned Range Signed to Unsigned byte -128..127 0..255 int u = s & 0xff; short -32,768..32,767 0..65,535 int u = s & 0xffff; int -2,147,483,648..2,147,483,647 0..4,294,967,295 long u = s & 0xffffffffL; Java has no primitive type that can represent unsigned longs.","title":"Communicate on a Socket (Java/Kotlin)"},{"location":"#hashing-javakotlin","text":"We\u2019re bombarded by hashing in our lives as Java programmers. Early on we\u2019re introduced to the hashCode() method, something we know we need to override otherwise unforeseen bad things happen. Later we\u2019re shown LinkedHashMap and its friends. These build on that hashCode() method to organize data for fast retrieval. Elsewhere we have cryptographic hash functions. These get used all over the place. HTTPS certificates, Git commits, BitTorrent integrity checking, and Blockchain blocks all use cryptographic hashes. Good use of hashes can improve the performance, privacy, security, and simplicity of an application. Each cryptographic hash function accepts a variable-length stream of input bytes and produces a fixed-length byte string value called the \u201chash\u201d. Hash functions have these important qualities: Deterministic: each input always produces the same output. Uniform: each output byte string is equally likely. It is very difficult to find or create pairs of different inputs that yield the same output. This is called a \u201ccollision\u201d. Non-reversible: knowing an output doesn\u2019t help you to find the input. Note that if you know some possible inputs you can hash them to see if their hashes match. Well-known: the hash is implemented everywhere and rigorously understood. Good hash functions are very cheap to compute (dozens of microseconds) and expensive to reverse (quintillions of millenia). Steady advances in computing and mathematics have caused once-great hash functions to become inexpensive to reverse. When choosing a hash function, beware that not all are created equal! Okio supports these well-known cryptographic hash functions: MD5 : a 128-bit (16 byte) cryptographic hash. It is both insecure and obsolete because it is inexpensive to reverse! This hash is offered because it is popular and convenient for use in legacy systems that are not security-sensitive. SHA-1 : a 160-bit (20 byte) cryptographic hash. It was recently demonstrated that it is feasible to create SHA-1 collisions. Consider upgrading from SHA-1 to SHA-256. SHA-256 : a 256-bit (32 byte) cryptographic hash. SHA-256 is widely understood and expensive to reverse. This is the hash most systems should use. SHA-512 : a 512-bit (64 byte) cryptographic hash. It is expensive to reverse. Each hash creates a ByteString of the specified length. Use hex() to get the conventional human-readable form. Or leave it as a ByteString because that\u2019s a convenient model type! Okio can produce cryptographic hashes from byte strings: ```Java tab= ByteString byteString = readByteString(new File(\u201cREADME.md\u201d)); System.out.println(\u201d md5: \u201d + byteString.md5().hex()); System.out.println(\u201d sha1: \u201d + byteString.sha1().hex()); System.out.println(\u201csha256: \u201d + byteString.sha256().hex()); System.out.println(\u201csha512: \u201d + byteString.sha512().hex()); ```Kotlin tab= val byteString = readByteString(File(\"README.md\")) println(\" md5: \" + byteString.md5().hex()) println(\" sha1: \" + byteString.sha1().hex()) println(\" sha256: \" + byteString.sha256().hex()) println(\" sha512: \" + byteString.sha512().hex()) From buffers: ```Java tab= Buffer buffer = readBuffer(new File(\u201cREADME.md\u201d)); System.out.println(\u201d md5: \u201d + buffer.md5().hex()); System.out.println(\u201d sha1: \u201d + buffer.sha1().hex()); System.out.println(\u201csha256: \u201d + buffer.sha256().hex()); System.out.println(\u201csha512: \u201d + buffer.sha512().hex()); ```Kotlin tab= val buffer = readBuffer(File(\"README.md\")) println(\" md5: \" + buffer.md5().hex()) println(\" sha1: \" + buffer.sha1().hex()) println(\" sha256: \" + buffer.sha256().hex()) println(\" sha512: \" + buffer.sha512().hex()) While streaming from a source: ```Java tab= try (HashingSink hashingSink = HashingSink.sha256(Okio.blackhole()); BufferedSource source = Okio.buffer(Okio.source(file))) { source.readAll(hashingSink); System.out.println(\u201csha256: \u201d + hashingSink.hash().hex()); } ```Kotlin tab= sha256(blackholeSink()).use { hashingSink -> file.source().buffer().use { source -> source.readAll(hashingSink) println(\" sha256: \" + hashingSink.hash.hex()) } } While streaming to a sink: ```Java tab= try (HashingSink hashingSink = HashingSink.sha256(Okio.blackhole()); BufferedSink sink = Okio.buffer(hashingSink); Source source = Okio.source(file)) { sink.writeAll(source); sink.close(); // Emit anything buffered. System.out.println(\u201csha256: \u201d + hashingSink.hash().hex()); } ```Kotlin tab= sha256(blackholeSink()).use { hashingSink -> hashingSink.buffer().use { sink -> file.source().use { source -> sink.writeAll(source) sink.close() // Emit anything buffered. println(\" sha256: \" + hashingSink.hash.hex()) } } } Okio also supports HMAC (Hash Message Authentication Code) which combines a secret and a hash. Applications use HMAC for data integrity and authentication. ```Java tab= ByteString secret = ByteString.decodeHex(\u201c7065616e7574627574746572\u201d); System.out.println(\u201chmacSha256: \u201d + byteString.hmacSha256(secret).hex()); ```Kotlin tab= val secret = \"7065616e7574627574746572\".decodeHex() println(\"hmacSha256: \" + byteString.hmacSha256(secret).hex()) As with hashing, you can generate an HMAC from a ByteString , Buffer , HashingSource , and HashingSink . Note that Okio doesn\u2019t implement HMAC for MD5. Okio uses Java\u2019s java.security.MessageDigest for cryptographic hashes and javax.crypto.Mac for HMAC.","title":"Hashing (Java/Kotlin)"},{"location":"#releases","text":"Our change log has release history. implementation ( \"com.squareup.okio:okio:2.7.0\" ) Snapshot builds are also available repositories { maven { url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots/\" ) } } dependencies { implementation ( \"com.squareup.okio:okio:2.7.0\" ) }","title":"Releases"},{"location":"#r8-proguard","text":"If you are using R8 or ProGuard add the options from this file .","title":"R8 / ProGuard"},{"location":"#license","text":"Copyright 2013 Square, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Change Log \u00b6 Version 2.7.0 \u00b6 2020-07-07 New: Pipe.cancel() causes in-progress and future reads and writes on the pipe to immediately fail with an IOException . The streams may still be canceled normally. New: Enlarge Okio\u2019s internal segment pool from a fixed 64 KiB total to 64 KiB per processor. For example, on an Intel i9 8-core/16-thread machine the segment pool now uses up to 1 MiB of memory. New: Migrate from synchronized to lock-free when accessing the segment pool. Combined with the change above we saw throughput increase 3x on a synthetic benchmark designed to create contention. Version 2.6.0 \u00b6 2020-04-22 New: InflaterSource.readOrInflate() is like InflaterSource.read() , except it will return 0 if consuming deflated bytes from the underlying stream did not produce new inflated bytes. Version 2.5.0 \u00b6 2020-03-20 New: Upgrade to Kotlin 1.3.70. Version 2.4.3 \u00b6 2019-12-20 New: Upgrade to Kotlin 1.3.61. Version 2.4.2 \u00b6 2019-12-11 Fix: Don\u2019t crash when an InputStream source is exhausted exactly at a buffer segment boundary. We had a bug where a sequence of reads could violate a buffer\u2019s invariants, and this could result in a crash when subsequent reads encountered an unexpected empty segment. Version 1.17.5 \u00b6 2019-12-11 Fix: Don\u2019t crash when an InputStream source is exhausted exactly at a buffer segment boundary. We had a bug where a sequence of reads could violate a buffer\u2019s invariants, and this could result in a crash when subsequent reads encountered an unexpected empty segment. Version 2.4.1 \u00b6 2019-10-04 Fix: Don\u2019t cache hash code and UTF-8 string in ByteString on Kotlin/Native which prevented freezing. Version 2.4.0 \u00b6 2019-08-26 New: Upgrade to Kotlin 1.3.50. Version 2.3.0 \u00b6 2019-07-29 This release changes our build from Kotlin-JVM to Kotlin-multiplatform (which includes JVM). Both native and JavaScript platforms are unstable preview releases and subject to backwards-incompatible changes in forthcoming releases. To try Okio in a multiplatform project use this Maven coordinate: api ( ' com . squareup . okio : okio - multiplatform : 2.3 . 0 ' ) You\u2019ll also need to enable Gradle metadata in your project\u2019s settings. The artifact name for JVM projects has not changed. New: Upgrade to Kotlin 1.3.40. Fix: Use Gradle api instead of implementation for the kotlin-stdlib dependency. Fix: Don\u2019t block unless strictly necessary in BufferedSource.peek() . Version 1.17.4 \u00b6 2019-04-29 Fix: Don\u2019t block unless strictly necessary in BufferedSource.peek() . Version 2.2.2 \u00b6 2019-01-28 Fix: Make Pipe.fold() close the underlying sink when necessary. Version 1.17.3 \u00b6 2019-01-28 Fix: Make Pipe.fold() close the underlying sink when necessary. Version 1.17.2 \u00b6 2019-01-17 Fix: Make Pipe.fold() flush the underlying sink. Version 2.2.1 \u00b6 2019-01-17 Fix: Make Pipe.fold() flush the underlying sink. Version 2.2.0 \u00b6 2019-01-16 New: Throttler limits sources and sinks to a maximum desired throughput. Multiple sources and sinks can be attached to the same throttler and their combined throughput will not exceed the desired throughput. Multiple throttlers can also be used on the same source or sink and they will all be honored. New: Pipe.fold() replaces the actively-readable Source with a passively-writable Sink . This can be used to forward one sink to a target that is initially undetermined. New: Optimize performance of ByteStrings created with Buffer.snapshot() . Version 1.17.1 \u00b6 2019-01-16 Fix: Make the newly-backported Pipe.fold() public. Version 1.17.0 \u00b6 2019-01-16 New: Backport Pipe.fold() to Okio 1.x. Version 1.16.0 \u00b6 2018-10-08 New: Backport BufferedSource.peek() and BufferedSource.getBuffer() to Okio 1.x. Fix: Enforce timeouts when closing AsyncTimeout sources. Version 2.1.0 \u00b6 2018-09-22 New: BufferedSource.peek() returns another BufferedSource that reads ahead on the current source. Use this to process the same data multiple times. New: Deprecate BufferedSource.buffer() , replacing it with either BufferedSource.getBuffer() (in Java) or BufferedSource.buffer (in Kotlin). We have done likewise for BufferedSink . When we introduced the new extension method Source.buffer() in Okio 2.0 we inadvertently collided with an existing method. This fixes that. New: Improve performance of Buffer.writeUtf8() . This comes alongside initial implementation of UTF-8 encoding and decoding in JavaScript which uses XOR masks for great performance. Version 2.0.0 \u00b6 2018-08-27 This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice on upgrading from 1.x to 2.x. We\u2019ve also added APIs to ease migration for Kotlin users. They use Kotlin\u2019s @Deprecated annotation to help you change call sites from the 1.x style to the 2.x style. Version 2.0.0-RC1 \u00b6 2018-07-26 Okio 2 is a major release that upgrades the library\u2019s implementation language from Java to Kotlin. Okio 2.x is binary-compatible with Okio 1.x and does not change any behavior. Classes and .jar files compiled against 1.x can be used with 2.x without recompiling. Okio 2.x is .java source compatible with Okio 1.x in all but one corner case. In Okio 1.x Buffer would throw an unchecked IllegalStateException when attempting to read more bytes than available. Okio 2.x now throws a checked EOFException in this case. This is now consistent with the behavior of its BufferedSource interface. Java callers that don\u2019t already catch IOException will now need to. Okio 2.x is .kt source-incompatible with Okio 1.x. This release adopts Kotlin idioms where they are available. Java Kotlin Idiom Buffer.getByte() operator fun Buffer.get() operator function Buffer.size() val Buffer.size val ByteString.decodeBase64(String) fun String.decodeBase64() extension function ByteString.decodeHex(String) fun String.decodeHex() extension function ByteString.encodeString(String, Charset) fun String.encode(Charset) extension function ByteString.encodeUtf8(String) fun String.encodeUtf8() extension function ByteString.getByte() operator fun ByteString.get() operator function ByteString.of(ByteBuffer) fun ByteBuffer.toByteString() extension function ByteString.of(byte[], int, int) fun ByteArray.toByteString() extension function ByteString.read(InputStream, int) fun InputStream.readByteString(Int) extension function ByteString.size() val ByteString.size val DeflaterSink(Sink) fun Sink.deflater() extension function ForwardingSink.delegate() val ForwardingSink.delegate val ForwardingSource.delegate() val ForwardingSource.delegate val GzipSink(Sink, Deflater) fun Sink.gzip() extension function GzipSink.deflater() val GzipSink.deflater val GzipSource(Source) fun Source.gzip() extension function HashingSink.hash() val HashingSink.hash val HashingSource.hash() val HashingSource.hash val InflaterSink(Source) fun Source.inflater() extension function Okio.appendingSink(File) fun File.appendingSink() extension function Okio.blackhole() fun blackholeSink() top level function Okio.buffer(Sink) fun Sink.buffer() extension function Okio.buffer(Source) fun Source.buffer() extension function Okio.sink(File) fun File.sink() extension function Okio.sink(OutputStream) fun OutputStream.sink() extension function Okio.sink(Path) fun Path.sink() extension function Okio.sink(Socket) fun Socket.sink() extension function Okio.source(File) fun File.source() extension function Okio.source(InputStream) fun InputStream.source() extension function Okio.source(Path) fun Path.source() extension function Okio.source(Socket) fun Socket.source() extension function Pipe.sink() val Pipe.sink val Pipe.source() val Pipe.source val Utf8.size(String) fun String.utf8Size() extension function Okio 2.x has similar performance to Okio 1.x. We benchmarked both versions to find potential performance regressions. We found one regression and fixed it: we were using == instead of === . Other changes in this release: New: Add a dependency on kotlin-stdlib. Okio\u2019s transitive dependencies grow from none in 1.x to three in 2.x. These are kotlin-stdlib (939 KiB), kotlin-stdlib-common (104 KiB), and JetBrains\u2019 annotations (17 KiB). New: Change Okio to build with Gradle instead of Maven. Version 1.15.0 \u00b6 2018-07-18 New: Trie-based Buffer.select() . This improves performance when selecting among large lists of options. Fix: Retain interrupted state when throwing InterruptedIOException . Version 1.14.0 \u00b6 2018-02-11 New: Buffer.UnsafeCursor provides direct access to Okio internals. This API is like Okio\u2019s version of Java reflection: it\u2019s a very powerful API that can be used for great things and dangerous things alike. The documentation is extensive and anyone using it should review it carefully before proceeding! New: Change BufferedSource to implement java.nio.ReadableByteChannel and BufferedSink to implement java.nio.WritableByteChannel . Now it\u2019s a little easier to interop between Okio and NIO. New: Automatic module name of okio for use with the Java Platform Module System. New: Optimize Buffer.getByte() to search backwards when doing so will be more efficient. Fix: Honor the requested byte count in InflaterSource . Previously this class could return more bytes than requested. Fix: Improve a performance bug in AsyncTimeout.sink().write() . Version 1.13.0 \u00b6 2017-05-12 Okio now uses @Nullable to annotate all possibly-null values. We\u2019ve added a compile-time dependency on the JSR 305 annotations. This is a provided dependency and does not need to be included in your build configuration, .jar file, or .apk . We use @ParametersAreNonnullByDefault and all parameters and return types are never null unless explicitly annotated @Nullable . Warning: this release is source-incompatible for Kotlin users. Nullability was previously ambiguous and lenient but now the compiler will enforce strict null checks. Version 1.12.0 \u00b6 2017-04-11 Fix: Change Pipe\u2019s sink.flush() to not block. Previously closing a pipe\u2019s sink would block until the source had been exhausted. In practice this blocked the caller for no benefit. Fix: Change writeUtf8CodePoint() to emit ? for partial surrogates. The previous behavior was inconsistent: given a malformed string with a partial surrogate, writeUtf8() emitted ? but writeUtf8CodePoint() threw an IllegalArgumentException . Most applications will never encounter partial surrogates, but for those that do this behavior was unexpected. New: Allow length of readUtf8LineStrict() to be limited. New: Utf8.size() method to get the number of bytes required to encode a string as UTF-8. This may be useful for length-prefixed encodings. New: SHA-512 hash and HMAC APIs. Version 1.11.0 \u00b6 2016-10-11 Fix: The four-argument overload of Buffer.writeString() had a major bug where it didn\u2019t respect offsets if the specified charset was UTF-8. This was because our short-circuit optimization omitted necessary offset parameters. New: HMAC support in HashingSource , HashingSink , ByteString , and Buffer . This makes it easy to create a keyed-hash message authentication code (HMAC) wherever your data is. Unlike the other hashes, HMAC uses a ByteString secret key for authentication. New: ByteString.of(ByteBuffer) makes it easier to mix NIO with Okio. Version 1.10.0 \u00b6 2016-08-28 Fix: Support reading files larger than 2 GiB with GzipSource . Previously attempting to decompress such files would fail due to an overflow when validating the total length. Fix: Exit the watchdog thread after being idle for 60 seconds. This should make it possible for class unloaders to fully unload Okio. New: Okio.blackhole() returns a sink where all bytes written are discarded. This is Okio\u2019s equivalent of /dev/null . New: Encode a string with any charset using ByteString.encodeString() and decode strings in any charset using ByteString.string() . Most applications should prefer ByteString.encodeUtf8() and ByteString.utf8() unless it\u2019s necessary to support a legacy charset. New: GzipSink.deflater() makes it possible to configure the compression level. Version 1.9.0 \u00b6 2016-07-01 New: Pipe makes it easy to connect a producer thread to a consumer thread. Reads block until data is available to read. Writes block if the pipe\u2019s is full. Both sources and sinks support timeouts. New: BufferedSource.rangeEquals() makes it easy to compare a range in a stream to an expected value. This does the right thing: it blocks to load the data required return a definitive result. But it won\u2019t block unnecessarily. New: Timeout.waitUntilNotified() makes it possible to use nice timeout abstractions on Java\u2019s built-in wait/notify primitives. Fix: Don\u2019t return incorrect results when HashingSource does large reads. There was a bug where it wasn\u2019t traversing through the segments of the buffer being hashed. This means that HashingSource was returning incorrect answers for any writes that spanned multiple segment boundaries. Version 1.8.0 \u00b6 2016-05-02 New: BufferedSource.select(Options) API for reading one of a set of expected values. New: Make ByteString.toString() and Buffer.toString() friendlier. These methods return text if the byte string is valid UTF-8. New: APIs to match byte strings: indexOf() , startsWith() , and endsWith() . Version 1.7.0 \u00b6 2016-04-10 New: Change the segment size to 8 KiB. This has been reported to dramatically improve performance in some applications. New: md5() , sha1() , and sha256() methods on Buffer . Also add a sha1() method on ByteString for symmetry. New: HashingSource and HashingSink . These classes are Okio\u2019s equivalent to the JDK\u2019s DigestInputStream and DigestOutputStream . They offer convenient md5() , sha1() , and sha256() factory methods to avoid an impossible NoSuchAlgorithmException . New: ByteString.asByteBuffer() . Fix: Limit snapshot byte strings to requested size. Fix: Change write timeouts to have a maximum write size. Previously large writes could easly suffer timeouts because the entire write was subject to a single timeout. Fix: Recover from EBADF failures, which could be triggered by asynchronously closing a stream on older versions of Android. Fix: Don\u2019t share segments if doing so only saves a small copy. This should improve performance for all applications. Fix: Optimize BufferedSource.indexOfElement() and indexOf(ByteString) . Previously this method had a bug that caused it to be very slow on large buffers. Version 1.6.0 \u00b6 2015-08-25 New: BufferedSource.indexOf(ByteString) searches a source for the next occurrence of a byte string. Fix: Recover from unexpected AssertionError thrown on Android 4.2.2 and earlier when asynchronously closing a socket. Version 1.5.0 \u00b6 2015-06-19 Sockets streams now throw SocketTimeoutException . This builds on new extension point in AsyncTimeout to customize the exception when a timeout occurs. New: ByteString now implements Comparable . The comparison sorts bytes as unsigned: {@code ff} sorts after {@code 00}. Version 1.4.0 \u00b6 2015-05-16 Timeout exception changed. Previously Timeout.throwIfReached() would throw InterruptedIOException on thread interruption, and IOException if the deadline was reached. Now it throws InterruptedIOException in both cases. Fix: throw EOFException when attempting to read digits from an empty source. Previously this would crash with an unchecked exception. New: APIs to read and write UTF-8 code points without allocating strings. New: BufferedSink can now write substrings directly, potentially saving an allocation for some callers. New: ForwardingTimeout class. Version 1.3.0 \u00b6 2015-03-16 New: Read and write signed decimal and unsigned hexadecimal values in BufferedSource and BufferedSink . Unlike the alternatives, these methods don\u2019t do any memory allocations! New: Segment sharing. This improves the runtime of operations like Buffer.clone() and Buffer.copyTo() by sharing underlying segments between buffers. New: Buffer.snapshot() returns an immutable snapshot of a buffer as a ByteString . This builds on segment sharing so that snapshots are shallow, immutable copies. New: ByteString.rangeEquals() . New: ByteString.md5() and ByteString.sha256() . New: ByteString.base64Url() returns URL-safe Base64. The existing decoding method has been extended to support URL-safe Base64 input. New: ByteString.substring() returns a prefix, infix, or suffix. New: Sink now implements java.io.Flushable . Fix: Buffer.write(Source, long) now always writes fully. The previous behavior would return as soon as any data had been written; this was inconsistent with all other write() methods in the API. Fix: don\u2019t leak empty segments in DeflaterSink and InflaterSource. (This was unlikely to cause problems in practice.) Version 1.2.0 \u00b6 2014-12-30 Fix: Okio.buffer() always buffers for better predictability. Fix: Provide context when readUtf8LineStrict() throws. Fix: Buffers do not call through the Source on zero-byte writes. Version 1.1.0 \u00b6 2014-12-11 Do UTF-8 encoding natively for a performance increase, particularly on Android. New APIs: BufferedSink.emit() , BufferedSource.request() and BufferedSink.indexOfElement() . Fixed a performance bug in Buffer.indexOf() Version 1.0.1 \u00b6 2014-08-08 Added read(byte[]) , read(byte[], offset, byteCount) , and void readFully(byte[]) to BufferedSource . Refined declared checked exceptions on Buffer methods. Version 1.0.0 \u00b6 2014-05-23 Bumped release version. No other changes! Version 0.9.0 \u00b6 2014-05-03 Use 0 as a sentinel for no timeout. Make AsyncTimeout public. Remove checked exception from Buffer.readByteArray. Version 0.8.0 \u00b6 2014-04-24 Eagerly verify preconditions on public APIs. Quick return on Buffer instance equivalence. Add delegate types for Sink and Source. Small changes to the way deadlines are managed. Add append variant of Okio.sink for File. Methods to exhaust BufferedSource to byte[] and ByteString. Version 0.7.0 \u00b6 2014-04-18 Don\u2019t use getters in timeout. Use the watchdog to interrupt sockets that have reached deadlines. Add java.io and java.nio file source/sink helpers. Version 0.6.1 \u00b6 2014-04-17 Methods to read a buffered source fully in UTF-8 or supplied charset. API to read a byte[] directly. New methods to move all data from a source to a sink. Fix a bug on input stream exhaustion. Version 0.6.0 \u00b6 2014-04-15 Make ByteString serializable. New API: ByteString.of(byte[] data, int offset, int byteCount) New API: stream-based copy, write, and read helpers. Version 0.5.0 \u00b6 2014-04-08 Initial public release. Imported from OkHttp.","title":"Change Log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#version-270","text":"2020-07-07 New: Pipe.cancel() causes in-progress and future reads and writes on the pipe to immediately fail with an IOException . The streams may still be canceled normally. New: Enlarge Okio\u2019s internal segment pool from a fixed 64 KiB total to 64 KiB per processor. For example, on an Intel i9 8-core/16-thread machine the segment pool now uses up to 1 MiB of memory. New: Migrate from synchronized to lock-free when accessing the segment pool. Combined with the change above we saw throughput increase 3x on a synthetic benchmark designed to create contention.","title":"Version 2.7.0"},{"location":"changelog/#version-260","text":"2020-04-22 New: InflaterSource.readOrInflate() is like InflaterSource.read() , except it will return 0 if consuming deflated bytes from the underlying stream did not produce new inflated bytes.","title":"Version 2.6.0"},{"location":"changelog/#version-250","text":"2020-03-20 New: Upgrade to Kotlin 1.3.70.","title":"Version 2.5.0"},{"location":"changelog/#version-243","text":"2019-12-20 New: Upgrade to Kotlin 1.3.61.","title":"Version 2.4.3"},{"location":"changelog/#version-242","text":"2019-12-11 Fix: Don\u2019t crash when an InputStream source is exhausted exactly at a buffer segment boundary. We had a bug where a sequence of reads could violate a buffer\u2019s invariants, and this could result in a crash when subsequent reads encountered an unexpected empty segment.","title":"Version 2.4.2"},{"location":"changelog/#version-1175","text":"2019-12-11 Fix: Don\u2019t crash when an InputStream source is exhausted exactly at a buffer segment boundary. We had a bug where a sequence of reads could violate a buffer\u2019s invariants, and this could result in a crash when subsequent reads encountered an unexpected empty segment.","title":"Version 1.17.5"},{"location":"changelog/#version-241","text":"2019-10-04 Fix: Don\u2019t cache hash code and UTF-8 string in ByteString on Kotlin/Native which prevented freezing.","title":"Version 2.4.1"},{"location":"changelog/#version-240","text":"2019-08-26 New: Upgrade to Kotlin 1.3.50.","title":"Version 2.4.0"},{"location":"changelog/#version-230","text":"2019-07-29 This release changes our build from Kotlin-JVM to Kotlin-multiplatform (which includes JVM). Both native and JavaScript platforms are unstable preview releases and subject to backwards-incompatible changes in forthcoming releases. To try Okio in a multiplatform project use this Maven coordinate: api ( ' com . squareup . okio : okio - multiplatform : 2.3 . 0 ' ) You\u2019ll also need to enable Gradle metadata in your project\u2019s settings. The artifact name for JVM projects has not changed. New: Upgrade to Kotlin 1.3.40. Fix: Use Gradle api instead of implementation for the kotlin-stdlib dependency. Fix: Don\u2019t block unless strictly necessary in BufferedSource.peek() .","title":"Version 2.3.0"},{"location":"changelog/#version-1174","text":"2019-04-29 Fix: Don\u2019t block unless strictly necessary in BufferedSource.peek() .","title":"Version 1.17.4"},{"location":"changelog/#version-222","text":"2019-01-28 Fix: Make Pipe.fold() close the underlying sink when necessary.","title":"Version 2.2.2"},{"location":"changelog/#version-1173","text":"2019-01-28 Fix: Make Pipe.fold() close the underlying sink when necessary.","title":"Version 1.17.3"},{"location":"changelog/#version-1172","text":"2019-01-17 Fix: Make Pipe.fold() flush the underlying sink.","title":"Version 1.17.2"},{"location":"changelog/#version-221","text":"2019-01-17 Fix: Make Pipe.fold() flush the underlying sink.","title":"Version 2.2.1"},{"location":"changelog/#version-220","text":"2019-01-16 New: Throttler limits sources and sinks to a maximum desired throughput. Multiple sources and sinks can be attached to the same throttler and their combined throughput will not exceed the desired throughput. Multiple throttlers can also be used on the same source or sink and they will all be honored. New: Pipe.fold() replaces the actively-readable Source with a passively-writable Sink . This can be used to forward one sink to a target that is initially undetermined. New: Optimize performance of ByteStrings created with Buffer.snapshot() .","title":"Version 2.2.0"},{"location":"changelog/#version-1171","text":"2019-01-16 Fix: Make the newly-backported Pipe.fold() public.","title":"Version 1.17.1"},{"location":"changelog/#version-1170","text":"2019-01-16 New: Backport Pipe.fold() to Okio 1.x.","title":"Version 1.17.0"},{"location":"changelog/#version-1160","text":"2018-10-08 New: Backport BufferedSource.peek() and BufferedSource.getBuffer() to Okio 1.x. Fix: Enforce timeouts when closing AsyncTimeout sources.","title":"Version 1.16.0"},{"location":"changelog/#version-210","text":"2018-09-22 New: BufferedSource.peek() returns another BufferedSource that reads ahead on the current source. Use this to process the same data multiple times. New: Deprecate BufferedSource.buffer() , replacing it with either BufferedSource.getBuffer() (in Java) or BufferedSource.buffer (in Kotlin). We have done likewise for BufferedSink . When we introduced the new extension method Source.buffer() in Okio 2.0 we inadvertently collided with an existing method. This fixes that. New: Improve performance of Buffer.writeUtf8() . This comes alongside initial implementation of UTF-8 encoding and decoding in JavaScript which uses XOR masks for great performance.","title":"Version 2.1.0"},{"location":"changelog/#version-200","text":"2018-08-27 This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice on upgrading from 1.x to 2.x. We\u2019ve also added APIs to ease migration for Kotlin users. They use Kotlin\u2019s @Deprecated annotation to help you change call sites from the 1.x style to the 2.x style.","title":"Version 2.0.0"},{"location":"changelog/#version-200-rc1","text":"2018-07-26 Okio 2 is a major release that upgrades the library\u2019s implementation language from Java to Kotlin. Okio 2.x is binary-compatible with Okio 1.x and does not change any behavior. Classes and .jar files compiled against 1.x can be used with 2.x without recompiling. Okio 2.x is .java source compatible with Okio 1.x in all but one corner case. In Okio 1.x Buffer would throw an unchecked IllegalStateException when attempting to read more bytes than available. Okio 2.x now throws a checked EOFException in this case. This is now consistent with the behavior of its BufferedSource interface. Java callers that don\u2019t already catch IOException will now need to. Okio 2.x is .kt source-incompatible with Okio 1.x. This release adopts Kotlin idioms where they are available. Java Kotlin Idiom Buffer.getByte() operator fun Buffer.get() operator function Buffer.size() val Buffer.size val ByteString.decodeBase64(String) fun String.decodeBase64() extension function ByteString.decodeHex(String) fun String.decodeHex() extension function ByteString.encodeString(String, Charset) fun String.encode(Charset) extension function ByteString.encodeUtf8(String) fun String.encodeUtf8() extension function ByteString.getByte() operator fun ByteString.get() operator function ByteString.of(ByteBuffer) fun ByteBuffer.toByteString() extension function ByteString.of(byte[], int, int) fun ByteArray.toByteString() extension function ByteString.read(InputStream, int) fun InputStream.readByteString(Int) extension function ByteString.size() val ByteString.size val DeflaterSink(Sink) fun Sink.deflater() extension function ForwardingSink.delegate() val ForwardingSink.delegate val ForwardingSource.delegate() val ForwardingSource.delegate val GzipSink(Sink, Deflater) fun Sink.gzip() extension function GzipSink.deflater() val GzipSink.deflater val GzipSource(Source) fun Source.gzip() extension function HashingSink.hash() val HashingSink.hash val HashingSource.hash() val HashingSource.hash val InflaterSink(Source) fun Source.inflater() extension function Okio.appendingSink(File) fun File.appendingSink() extension function Okio.blackhole() fun blackholeSink() top level function Okio.buffer(Sink) fun Sink.buffer() extension function Okio.buffer(Source) fun Source.buffer() extension function Okio.sink(File) fun File.sink() extension function Okio.sink(OutputStream) fun OutputStream.sink() extension function Okio.sink(Path) fun Path.sink() extension function Okio.sink(Socket) fun Socket.sink() extension function Okio.source(File) fun File.source() extension function Okio.source(InputStream) fun InputStream.source() extension function Okio.source(Path) fun Path.source() extension function Okio.source(Socket) fun Socket.source() extension function Pipe.sink() val Pipe.sink val Pipe.source() val Pipe.source val Utf8.size(String) fun String.utf8Size() extension function Okio 2.x has similar performance to Okio 1.x. We benchmarked both versions to find potential performance regressions. We found one regression and fixed it: we were using == instead of === . Other changes in this release: New: Add a dependency on kotlin-stdlib. Okio\u2019s transitive dependencies grow from none in 1.x to three in 2.x. These are kotlin-stdlib (939 KiB), kotlin-stdlib-common (104 KiB), and JetBrains\u2019 annotations (17 KiB). New: Change Okio to build with Gradle instead of Maven.","title":"Version 2.0.0-RC1"},{"location":"changelog/#version-1150","text":"2018-07-18 New: Trie-based Buffer.select() . This improves performance when selecting among large lists of options. Fix: Retain interrupted state when throwing InterruptedIOException .","title":"Version 1.15.0"},{"location":"changelog/#version-1140","text":"2018-02-11 New: Buffer.UnsafeCursor provides direct access to Okio internals. This API is like Okio\u2019s version of Java reflection: it\u2019s a very powerful API that can be used for great things and dangerous things alike. The documentation is extensive and anyone using it should review it carefully before proceeding! New: Change BufferedSource to implement java.nio.ReadableByteChannel and BufferedSink to implement java.nio.WritableByteChannel . Now it\u2019s a little easier to interop between Okio and NIO. New: Automatic module name of okio for use with the Java Platform Module System. New: Optimize Buffer.getByte() to search backwards when doing so will be more efficient. Fix: Honor the requested byte count in InflaterSource . Previously this class could return more bytes than requested. Fix: Improve a performance bug in AsyncTimeout.sink().write() .","title":"Version 1.14.0"},{"location":"changelog/#version-1130","text":"2017-05-12 Okio now uses @Nullable to annotate all possibly-null values. We\u2019ve added a compile-time dependency on the JSR 305 annotations. This is a provided dependency and does not need to be included in your build configuration, .jar file, or .apk . We use @ParametersAreNonnullByDefault and all parameters and return types are never null unless explicitly annotated @Nullable . Warning: this release is source-incompatible for Kotlin users. Nullability was previously ambiguous and lenient but now the compiler will enforce strict null checks.","title":"Version 1.13.0"},{"location":"changelog/#version-1120","text":"2017-04-11 Fix: Change Pipe\u2019s sink.flush() to not block. Previously closing a pipe\u2019s sink would block until the source had been exhausted. In practice this blocked the caller for no benefit. Fix: Change writeUtf8CodePoint() to emit ? for partial surrogates. The previous behavior was inconsistent: given a malformed string with a partial surrogate, writeUtf8() emitted ? but writeUtf8CodePoint() threw an IllegalArgumentException . Most applications will never encounter partial surrogates, but for those that do this behavior was unexpected. New: Allow length of readUtf8LineStrict() to be limited. New: Utf8.size() method to get the number of bytes required to encode a string as UTF-8. This may be useful for length-prefixed encodings. New: SHA-512 hash and HMAC APIs.","title":"Version 1.12.0"},{"location":"changelog/#version-1110","text":"2016-10-11 Fix: The four-argument overload of Buffer.writeString() had a major bug where it didn\u2019t respect offsets if the specified charset was UTF-8. This was because our short-circuit optimization omitted necessary offset parameters. New: HMAC support in HashingSource , HashingSink , ByteString , and Buffer . This makes it easy to create a keyed-hash message authentication code (HMAC) wherever your data is. Unlike the other hashes, HMAC uses a ByteString secret key for authentication. New: ByteString.of(ByteBuffer) makes it easier to mix NIO with Okio.","title":"Version 1.11.0"},{"location":"changelog/#version-1100","text":"2016-08-28 Fix: Support reading files larger than 2 GiB with GzipSource . Previously attempting to decompress such files would fail due to an overflow when validating the total length. Fix: Exit the watchdog thread after being idle for 60 seconds. This should make it possible for class unloaders to fully unload Okio. New: Okio.blackhole() returns a sink where all bytes written are discarded. This is Okio\u2019s equivalent of /dev/null . New: Encode a string with any charset using ByteString.encodeString() and decode strings in any charset using ByteString.string() . Most applications should prefer ByteString.encodeUtf8() and ByteString.utf8() unless it\u2019s necessary to support a legacy charset. New: GzipSink.deflater() makes it possible to configure the compression level.","title":"Version 1.10.0"},{"location":"changelog/#version-190","text":"2016-07-01 New: Pipe makes it easy to connect a producer thread to a consumer thread. Reads block until data is available to read. Writes block if the pipe\u2019s is full. Both sources and sinks support timeouts. New: BufferedSource.rangeEquals() makes it easy to compare a range in a stream to an expected value. This does the right thing: it blocks to load the data required return a definitive result. But it won\u2019t block unnecessarily. New: Timeout.waitUntilNotified() makes it possible to use nice timeout abstractions on Java\u2019s built-in wait/notify primitives. Fix: Don\u2019t return incorrect results when HashingSource does large reads. There was a bug where it wasn\u2019t traversing through the segments of the buffer being hashed. This means that HashingSource was returning incorrect answers for any writes that spanned multiple segment boundaries.","title":"Version 1.9.0"},{"location":"changelog/#version-180","text":"2016-05-02 New: BufferedSource.select(Options) API for reading one of a set of expected values. New: Make ByteString.toString() and Buffer.toString() friendlier. These methods return text if the byte string is valid UTF-8. New: APIs to match byte strings: indexOf() , startsWith() , and endsWith() .","title":"Version 1.8.0"},{"location":"changelog/#version-170","text":"2016-04-10 New: Change the segment size to 8 KiB. This has been reported to dramatically improve performance in some applications. New: md5() , sha1() , and sha256() methods on Buffer . Also add a sha1() method on ByteString for symmetry. New: HashingSource and HashingSink . These classes are Okio\u2019s equivalent to the JDK\u2019s DigestInputStream and DigestOutputStream . They offer convenient md5() , sha1() , and sha256() factory methods to avoid an impossible NoSuchAlgorithmException . New: ByteString.asByteBuffer() . Fix: Limit snapshot byte strings to requested size. Fix: Change write timeouts to have a maximum write size. Previously large writes could easly suffer timeouts because the entire write was subject to a single timeout. Fix: Recover from EBADF failures, which could be triggered by asynchronously closing a stream on older versions of Android. Fix: Don\u2019t share segments if doing so only saves a small copy. This should improve performance for all applications. Fix: Optimize BufferedSource.indexOfElement() and indexOf(ByteString) . Previously this method had a bug that caused it to be very slow on large buffers.","title":"Version 1.7.0"},{"location":"changelog/#version-160","text":"2015-08-25 New: BufferedSource.indexOf(ByteString) searches a source for the next occurrence of a byte string. Fix: Recover from unexpected AssertionError thrown on Android 4.2.2 and earlier when asynchronously closing a socket.","title":"Version 1.6.0"},{"location":"changelog/#version-150","text":"2015-06-19 Sockets streams now throw SocketTimeoutException . This builds on new extension point in AsyncTimeout to customize the exception when a timeout occurs. New: ByteString now implements Comparable . The comparison sorts bytes as unsigned: {@code ff} sorts after {@code 00}.","title":"Version 1.5.0"},{"location":"changelog/#version-140","text":"2015-05-16 Timeout exception changed. Previously Timeout.throwIfReached() would throw InterruptedIOException on thread interruption, and IOException if the deadline was reached. Now it throws InterruptedIOException in both cases. Fix: throw EOFException when attempting to read digits from an empty source. Previously this would crash with an unchecked exception. New: APIs to read and write UTF-8 code points without allocating strings. New: BufferedSink can now write substrings directly, potentially saving an allocation for some callers. New: ForwardingTimeout class.","title":"Version 1.4.0"},{"location":"changelog/#version-130","text":"2015-03-16 New: Read and write signed decimal and unsigned hexadecimal values in BufferedSource and BufferedSink . Unlike the alternatives, these methods don\u2019t do any memory allocations! New: Segment sharing. This improves the runtime of operations like Buffer.clone() and Buffer.copyTo() by sharing underlying segments between buffers. New: Buffer.snapshot() returns an immutable snapshot of a buffer as a ByteString . This builds on segment sharing so that snapshots are shallow, immutable copies. New: ByteString.rangeEquals() . New: ByteString.md5() and ByteString.sha256() . New: ByteString.base64Url() returns URL-safe Base64. The existing decoding method has been extended to support URL-safe Base64 input. New: ByteString.substring() returns a prefix, infix, or suffix. New: Sink now implements java.io.Flushable . Fix: Buffer.write(Source, long) now always writes fully. The previous behavior would return as soon as any data had been written; this was inconsistent with all other write() methods in the API. Fix: don\u2019t leak empty segments in DeflaterSink and InflaterSource. (This was unlikely to cause problems in practice.)","title":"Version 1.3.0"},{"location":"changelog/#version-120","text":"2014-12-30 Fix: Okio.buffer() always buffers for better predictability. Fix: Provide context when readUtf8LineStrict() throws. Fix: Buffers do not call through the Source on zero-byte writes.","title":"Version 1.2.0"},{"location":"changelog/#version-110","text":"2014-12-11 Do UTF-8 encoding natively for a performance increase, particularly on Android. New APIs: BufferedSink.emit() , BufferedSource.request() and BufferedSink.indexOfElement() . Fixed a performance bug in Buffer.indexOf()","title":"Version 1.1.0"},{"location":"changelog/#version-101","text":"2014-08-08 Added read(byte[]) , read(byte[], offset, byteCount) , and void readFully(byte[]) to BufferedSource . Refined declared checked exceptions on Buffer methods.","title":"Version 1.0.1"},{"location":"changelog/#version-100","text":"2014-05-23 Bumped release version. No other changes!","title":"Version 1.0.0"},{"location":"changelog/#version-090","text":"2014-05-03 Use 0 as a sentinel for no timeout. Make AsyncTimeout public. Remove checked exception from Buffer.readByteArray.","title":"Version 0.9.0"},{"location":"changelog/#version-080","text":"2014-04-24 Eagerly verify preconditions on public APIs. Quick return on Buffer instance equivalence. Add delegate types for Sink and Source. Small changes to the way deadlines are managed. Add append variant of Okio.sink for File. Methods to exhaust BufferedSource to byte[] and ByteString.","title":"Version 0.8.0"},{"location":"changelog/#version-070","text":"2014-04-18 Don\u2019t use getters in timeout. Use the watchdog to interrupt sockets that have reached deadlines. Add java.io and java.nio file source/sink helpers.","title":"Version 0.7.0"},{"location":"changelog/#version-061","text":"2014-04-17 Methods to read a buffered source fully in UTF-8 or supplied charset. API to read a byte[] directly. New methods to move all data from a source to a sink. Fix a bug on input stream exhaustion.","title":"Version 0.6.1"},{"location":"changelog/#version-060","text":"2014-04-15 Make ByteString serializable. New API: ByteString.of(byte[] data, int offset, int byteCount) New API: stream-based copy, write, and read helpers.","title":"Version 0.6.0"},{"location":"changelog/#version-050","text":"2014-04-08 Initial public release. Imported from OkHttp.","title":"Version 0.5.0"},{"location":"code_of_conduct/","text":"Open Source Code of Conduct \u00b6 At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement \u00b6 We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks \u00b6 Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"code_of_conduct/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"code_of_conduct/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"code_of_conduct/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"code_of_conduct/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"code_of_conduct/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"contributing/","text":"Contributing \u00b6 Keeping the project small and stable limits our ability to accept new contributors. We are not seeking new committers at this time, but some small contributions are welcome. If you\u2019ve found a security problem, please follow our bug bounty program. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. Before code can be accepted all contributors must complete our Individual Contributor License Agreement (CLA) . Code Contributions \u00b6 Get working code on a personal branch with tests passing before you submit a PR: ./gradlew clean check Please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Contribute code changes through GitHub by forking the repository and sending a pull request. We squash all pull requests on merge. Committer\u2019s Guides \u00b6 Releasing","title":"Contributing"},{"location":"contributing/#contributing","text":"Keeping the project small and stable limits our ability to accept new contributors. We are not seeking new committers at this time, but some small contributions are welcome. If you\u2019ve found a security problem, please follow our bug bounty program. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. Before code can be accepted all contributors must complete our Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"contributing/#code-contributions","text":"Get working code on a personal branch with tests passing before you submit a PR: ./gradlew clean check Please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Contribute code changes through GitHub by forking the repository and sending a pull request. We squash all pull requests on merge.","title":"Code Contributions"},{"location":"contributing/#committers-guides","text":"Releasing","title":"Committer's Guides"},{"location":"releasing/","text":"Releasing \u00b6 Prerequisite: Sonatype (Maven Central) Account \u00b6 Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for com.squareup projects. Prerequisite: GPG Keys \u00b6 Generate a GPG key (RSA, 4096 bit, 3650 day) expiry, or use an existing one. You should leave the password empty for this key. $ gpg --full-generate-key Upload the GPG keys to public servers: $ gpg --list-keys --keyid-format LONG /Users/johnbarber/.gnupg/pubring.kbx ------------------------------ pub rsa4096/XXXXXXXXXXXXXXXX 2019-07-16 [SC] [expires: 2029-07-13] YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY uid [ultimate] John Barber <jbarber@squareup.com> sub rsa4096/ZZZZZZZZZZZZZZZZ 2019-07-16 [E] [expires: 2029-07-13] $ gpg --send-keys --keyserver keyserver.ubuntu.com XXXXXXXXXXXXXXXX Prerequisite: Gradle Properties \u00b6 Define publishing properties in ~/.gradle/gradle.properties : signing.keyId=1A2345F8 signing.password= signing.secretKeyRingFile=/Users/jbarber/.gnupg/secring.gpg signing.keyId is the GPG key\u2019s ID. Get it with this: $ gpg --list-keys --keyid-format SHORT signing.password is the password for this key. This might be empty! signing.secretKeyRingFile is the absolute path for secring.gpg . You may need to export this file manually with the following command where XXXXXXXX is the keyId above: $ gpg --keyring secring.gpg --export-secret-key XXXXXXXX > ~/.gnupg/secring.gpg Cutting a Release \u00b6 Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Set environment variables with your Sonatype credentials . export SONATYPE_NEXUS_USERNAME=johnbarber export SONATYPE_NEXUS_PASSWORD=`pbpaste` Update, build, and upload: sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"com.squareup.okio:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.okio:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` ./gradlew clean publish Visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Tag the release, prepare for the next one, and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a parent-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push && git push --tags","title":"Releasing"},{"location":"releasing/#releasing","text":"","title":"Releasing"},{"location":"releasing/#prerequisite-sonatype-maven-central-account","text":"Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for com.squareup projects.","title":"Prerequisite: Sonatype (Maven Central) Account"},{"location":"releasing/#prerequisite-gpg-keys","text":"Generate a GPG key (RSA, 4096 bit, 3650 day) expiry, or use an existing one. You should leave the password empty for this key. $ gpg --full-generate-key Upload the GPG keys to public servers: $ gpg --list-keys --keyid-format LONG /Users/johnbarber/.gnupg/pubring.kbx ------------------------------ pub rsa4096/XXXXXXXXXXXXXXXX 2019-07-16 [SC] [expires: 2029-07-13] YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY uid [ultimate] John Barber <jbarber@squareup.com> sub rsa4096/ZZZZZZZZZZZZZZZZ 2019-07-16 [E] [expires: 2029-07-13] $ gpg --send-keys --keyserver keyserver.ubuntu.com XXXXXXXXXXXXXXXX","title":"Prerequisite: GPG Keys"},{"location":"releasing/#prerequisite-gradle-properties","text":"Define publishing properties in ~/.gradle/gradle.properties : signing.keyId=1A2345F8 signing.password= signing.secretKeyRingFile=/Users/jbarber/.gnupg/secring.gpg signing.keyId is the GPG key\u2019s ID. Get it with this: $ gpg --list-keys --keyid-format SHORT signing.password is the password for this key. This might be empty! signing.secretKeyRingFile is the absolute path for secring.gpg . You may need to export this file manually with the following command where XXXXXXXX is the keyId above: $ gpg --keyring secring.gpg --export-secret-key XXXXXXXX > ~/.gnupg/secring.gpg","title":"Prerequisite: Gradle Properties"},{"location":"releasing/#cutting-a-release","text":"Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Set environment variables with your Sonatype credentials . export SONATYPE_NEXUS_USERNAME=johnbarber export SONATYPE_NEXUS_PASSWORD=`pbpaste` Update, build, and upload: sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"com.squareup.okio:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.okio:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` ./gradlew clean publish Visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Tag the release, prepare for the next one, and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a parent-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push && git push --tags","title":"Cutting a Release"},{"location":"security/","text":"Security Policy \u00b6 Supported Versions \u00b6 Version Supported 2.x \u2705 1.x \u2705 Reporting a Vulnerability \u00b6 Square recognizes the important contributions the security research community can make. We therefore encourage reporting security issues with the code contained in this repository. If you believe you have discovered a security vulnerability, please follow the guidelines at https://bugcrowd.com/squareopensource","title":"Security"},{"location":"security/#security-policy","text":"","title":"Security Policy"},{"location":"security/#supported-versions","text":"Version Supported 2.x \u2705 1.x \u2705","title":"Supported Versions"},{"location":"security/#reporting-a-vulnerability","text":"Square recognizes the important contributions the security research community can make. We therefore encourage reporting security issues with the code contained in this repository. If you believe you have discovered a security vulnerability, please follow the guidelines at https://bugcrowd.com/squareopensource","title":"Reporting a Vulnerability"},{"location":"2.x/okio/","text":"okio Packages \u00b6 Name Summary (js, jvm, native) okio Index \u00b6 All Types","title":"Packages - Okio"},{"location":"2.x/okio/#packages","text":"Name Summary (js, jvm, native) okio","title":"Packages"},{"location":"2.x/okio/#index","text":"All Types","title":"Index"},{"location":"2.x/okio/alltypes/","text":"All Types \u00b6 Name Summary (jvm) okio.-DeprecatedOkio \u00b6 |(jvm) okio.-DeprecatedUtf8 \u00b6 |(js, jvm, native) okio.ArrayIndexOutOfBoundsException \u00b6 |(jvm) okio.AsyncTimeout \u00b6 This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. |(js, jvm, native) okio.Buffer \u00b6 A collection of bytes in memory. |(js, jvm, native) okio.BufferedSink \u00b6 A sink that keeps a buffer internally so that callers can do small writes without a performance penalty. |(js, jvm, native) okio.BufferedSource \u00b6 A source that keeps a buffer internally so that callers can do small reads without a performance penalty. It also allows clients to read ahead, buffering as much as necessary before consuming input. |(js, jvm, native) okio.ByteString \u00b6 An immutable sequence of bytes. |(jvm) okio.DeflaterSink \u00b6 A sink that uses DEFLATE to compress data written to another source. |(js, jvm, native) okio.EOFException \u00b6 |(jvm) (extensions in package okio) java.io.File \u00b6 |(jvm) okio.ForwardingSink \u00b6 A Sink which forwards calls to another. Useful for subclassing. |(jvm) okio.ForwardingSource \u00b6 A Source which forwards calls to another. Useful for subclassing. |(jvm) okio.ForwardingTimeout \u00b6 A Timeout which forwards calls to another. Useful for subclassing. |(jvm) okio.GzipSink \u00b6 A sink that uses GZIP to compress written data to another sink. |(jvm) okio.GzipSource \u00b6 A source that uses GZIP to decompress data read from another source. |(jvm) okio.HashingSink \u00b6 A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value. |(jvm) okio.HashingSource \u00b6 A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value. |(jvm) okio.InflaterSource \u00b6 A source that uses DEFLATE to decompress data read from another source. |(jvm) (extensions in package okio) java.io.InputStream \u00b6 |(js, jvm, native) okio.IOException \u00b6 |(js, jvm) okio.Options \u00b6 An indexed set of values that may be read with BufferedSource.select . |(jvm) (extensions in package okio) java.io.OutputStream \u00b6 |(jvm) (extensions in package okio) java.nio.file.Path \u00b6 |(jvm) okio.Pipe \u00b6 A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source. |(js, jvm, native) okio.Sink \u00b6 Receives a stream of bytes. Use this interface to write data wherever it\u2019s needed: to the network, storage, or a buffer in memory. Sinks may be layered to transform received data, such as to compress, encrypt, throttle, or add protocol framing. |(jvm) (extensions in package okio) java.net.Socket \u00b6 |(js, jvm, native) okio.Source \u00b6 Supplies a stream of bytes. Use this interface to read data from wherever it\u2019s located: from the network, storage, or a buffer in memory. Sources may be layered to transform supplied data, such as to decompress, decrypt, or remove protocol framing. |(js, jvm) (extensions in package okio) kotlin.String \u00b6 |(jvm) okio.Throttler \u00b6 Enables limiting of Source and Sink throughput. Attach to this throttler via source and sink and set the desired throughput via bytesPerSecond . Multiple Sources and Sinks can be attached to a single Throttler and they will be throttled as a group, where their combined throughput will not exceed the desired throughput. The same Source or Sink can be attached to multiple Throttlers and its throughput will not exceed the desired throughput of any of the Throttlers. |(js, jvm, native) okio.Timeout \u00b6 A policy on how much time to spend on a task before giving up. When a task times out, it is left in an unspecified state and should be abandoned. For example, if reading from a source times out, that source should be closed and the read should be retried later. If writing to a sink times out, the same rules apply: close the sink and retry later.","title":"All Types - Okio"},{"location":"2.x/okio/alltypes/#all-types","text":"Name Summary (jvm)","title":"All Types"},{"location":"2.x/okio/alltypes/#okio-deprecatedokio","text":"|(jvm)","title":"okio.-DeprecatedOkio"},{"location":"2.x/okio/alltypes/#okio-deprecatedutf8","text":"|(js, jvm, native)","title":"okio.-DeprecatedUtf8"},{"location":"2.x/okio/alltypes/#okioarrayindexoutofboundsexception","text":"|(jvm)","title":"okio.ArrayIndexOutOfBoundsException"},{"location":"2.x/okio/alltypes/#okioasynctimeout","text":"This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. |(js, jvm, native)","title":"okio.AsyncTimeout"},{"location":"2.x/okio/alltypes/#okiobuffer","text":"A collection of bytes in memory. |(js, jvm, native)","title":"okio.Buffer"},{"location":"2.x/okio/alltypes/#okiobufferedsink","text":"A sink that keeps a buffer internally so that callers can do small writes without a performance penalty. |(js, jvm, native)","title":"okio.BufferedSink"},{"location":"2.x/okio/alltypes/#okiobufferedsource","text":"A source that keeps a buffer internally so that callers can do small reads without a performance penalty. It also allows clients to read ahead, buffering as much as necessary before consuming input. |(js, jvm, native)","title":"okio.BufferedSource"},{"location":"2.x/okio/alltypes/#okiobytestring","text":"An immutable sequence of bytes. |(jvm)","title":"okio.ByteString"},{"location":"2.x/okio/alltypes/#okiodeflatersink","text":"A sink that uses DEFLATE to compress data written to another source. |(js, jvm, native)","title":"okio.DeflaterSink"},{"location":"2.x/okio/alltypes/#okioeofexception","text":"|(jvm) (extensions in package okio)","title":"okio.EOFException"},{"location":"2.x/okio/alltypes/#javaiofile","text":"|(jvm)","title":"java.io.File"},{"location":"2.x/okio/alltypes/#okioforwardingsink","text":"A Sink which forwards calls to another. Useful for subclassing. |(jvm)","title":"okio.ForwardingSink"},{"location":"2.x/okio/alltypes/#okioforwardingsource","text":"A Source which forwards calls to another. Useful for subclassing. |(jvm)","title":"okio.ForwardingSource"},{"location":"2.x/okio/alltypes/#okioforwardingtimeout","text":"A Timeout which forwards calls to another. Useful for subclassing. |(jvm)","title":"okio.ForwardingTimeout"},{"location":"2.x/okio/alltypes/#okiogzipsink","text":"A sink that uses GZIP to compress written data to another sink. |(jvm)","title":"okio.GzipSink"},{"location":"2.x/okio/alltypes/#okiogzipsource","text":"A source that uses GZIP to decompress data read from another source. |(jvm)","title":"okio.GzipSource"},{"location":"2.x/okio/alltypes/#okiohashingsink","text":"A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value. |(jvm)","title":"okio.HashingSink"},{"location":"2.x/okio/alltypes/#okiohashingsource","text":"A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value. |(jvm)","title":"okio.HashingSource"},{"location":"2.x/okio/alltypes/#okioinflatersource","text":"A source that uses DEFLATE to decompress data read from another source. |(jvm) (extensions in package okio)","title":"okio.InflaterSource"},{"location":"2.x/okio/alltypes/#javaioinputstream","text":"|(js, jvm, native)","title":"java.io.InputStream"},{"location":"2.x/okio/alltypes/#okioioexception","text":"|(js, jvm)","title":"okio.IOException"},{"location":"2.x/okio/alltypes/#okiooptions","text":"An indexed set of values that may be read with BufferedSource.select . |(jvm) (extensions in package okio)","title":"okio.Options"},{"location":"2.x/okio/alltypes/#javaiooutputstream","text":"|(jvm) (extensions in package okio)","title":"java.io.OutputStream"},{"location":"2.x/okio/alltypes/#javaniofilepath","text":"|(jvm)","title":"java.nio.file.Path"},{"location":"2.x/okio/alltypes/#okiopipe","text":"A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source. |(js, jvm, native)","title":"okio.Pipe"},{"location":"2.x/okio/alltypes/#okiosink","text":"Receives a stream of bytes. Use this interface to write data wherever it\u2019s needed: to the network, storage, or a buffer in memory. Sinks may be layered to transform received data, such as to compress, encrypt, throttle, or add protocol framing. |(jvm) (extensions in package okio)","title":"okio.Sink"},{"location":"2.x/okio/alltypes/#javanetsocket","text":"|(js, jvm, native)","title":"java.net.Socket"},{"location":"2.x/okio/alltypes/#okiosource","text":"Supplies a stream of bytes. Use this interface to read data from wherever it\u2019s located: from the network, storage, or a buffer in memory. Sources may be layered to transform supplied data, such as to decompress, decrypt, or remove protocol framing. |(js, jvm) (extensions in package okio)","title":"okio.Source"},{"location":"2.x/okio/alltypes/#kotlinstring","text":"|(jvm)","title":"kotlin.String"},{"location":"2.x/okio/alltypes/#okiothrottler","text":"Enables limiting of Source and Sink throughput. Attach to this throttler via source and sink and set the desired throughput via bytesPerSecond . Multiple Sources and Sinks can be attached to a single Throttler and they will be throttled as a group, where their combined throughput will not exceed the desired throughput. The same Source or Sink can be attached to multiple Throttlers and its throughput will not exceed the desired throughput of any of the Throttlers. |(js, jvm, native)","title":"okio.Throttler"},{"location":"2.x/okio/alltypes/#okiotimeout","text":"A policy on how much time to spend on a task before giving up. When a task times out, it is left in an unspecified state and should be abandoned. For example, if reading from a source times out, that source should be closed and the read should be retried later. If writing to a sink times out, the same rules apply: close the sink and retry later.","title":"okio.Timeout"},{"location":"2.x/okio/okio/","text":"okio / okio Package okio \u00b6 Types \u00b6 Name Summary (jvm) -DeprecatedOkio object ~~-DeprecatedOkio~~ (jvm) -DeprecatedUtf8 object ~~-DeprecatedUtf8~~ (jvm) AsyncTimeout This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. open class AsyncTimeout : Timeout (js, jvm, native) Buffer A collection of bytes in memory. class Buffer : BufferedSource , BufferedSink (js, jvm, native) BufferedSink A sink that keeps a buffer internally so that callers can do small writes without a performance penalty. interface BufferedSink : Sink (js, jvm, native) BufferedSource A source that keeps a buffer internally so that callers can do small reads without a performance penalty. It also allows clients to read ahead, buffering as much as necessary before consuming input. interface BufferedSource : Source (js, jvm, native) ByteString An immutable sequence of bytes. open class ByteString : Comparable < ByteString > (jvm) DeflaterSink A sink that uses DEFLATE to compress data written to another source. class DeflaterSink : Sink (jvm) ForwardingSink A Sink which forwards calls to another. Useful for subclassing. abstract class ForwardingSink : Sink (jvm) ForwardingSource A Source which forwards calls to another. Useful for subclassing. abstract class ForwardingSource : Source (jvm) ForwardingTimeout A Timeout which forwards calls to another. Useful for subclassing. open class ForwardingTimeout : Timeout (jvm) GzipSink A sink that uses GZIP to compress written data to another sink. class GzipSink : Sink (jvm) GzipSource A source that uses GZIP to decompress data read from another source. class GzipSource : Source (jvm) HashingSink A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value. class HashingSink : ForwardingSink (jvm) HashingSource A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value. class HashingSource : ForwardingSource (jvm) InflaterSource A source that uses DEFLATE to decompress data read from another source. class InflaterSource : Source Options An indexed set of values that may be read with BufferedSource.select .(js) class Options : AbstractList < ByteString >, RandomAccess (jvm) class Options : AbstractList < ByteString >, RandomAccess (jvm) Pipe A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source. class Pipe (js, jvm, native) Sink Receives a stream of bytes. Use this interface to write data wherever it\u2019s needed: to the network, storage, or a buffer in memory. Sinks may be layered to transform received data, such as to compress, encrypt, throttle, or add protocol framing. interface Sink (js, jvm, native) Source Supplies a stream of bytes. Use this interface to read data from wherever it\u2019s located: from the network, storage, or a buffer in memory. Sources may be layered to transform supplied data, such as to decompress, decrypt, or remove protocol framing. interface Source (jvm) Throttler Enables limiting of Source and Sink throughput. Attach to this throttler via source and sink and set the desired throughput via bytesPerSecond . Multiple Sources and Sinks can be attached to a single Throttler and they will be throttled as a group, where their combined throughput will not exceed the desired throughput. The same Source or Sink can be attached to multiple Throttlers and its throughput will not exceed the desired throughput of any of the Throttlers. class Throttler (js, jvm, native) Timeout A policy on how much time to spend on a task before giving up. When a task times out, it is left in an unspecified state and should be abandoned. For example, if reading from a source times out, that source should be closed and the read should be retried later. If writing to a sink times out, the same rules apply: close the sink and retry later. open class Timeout Exceptions \u00b6 Name Summary ArrayIndexOutOfBoundsException (js, jvm) class ArrayIndexOutOfBoundsException : IndexOutOfBoundsException (native) typealias ArrayIndexOutOfBoundsException = <ERROR CLASS> (js, jvm, native) EOFException open class EOFException : IOException IOException (js, jvm) open class IOException : Exception (native) open class IOException : Exception Extensions for External Classes \u00b6 Name Summary (jvm) java.io.File (jvm) java.io.InputStream (jvm) java.io.OutputStream (jvm) java.net.Socket (jvm) java.nio.file.Path (js, jvm) kotlin.String Properties \u00b6 Name Summary (jvm) Okio val Okio: -DeprecatedOkio (jvm) Utf8 val Utf8: -DeprecatedUtf8 Functions \u00b6 Name Summary (js, jvm) blackholeSink Returns a sink that writes nowhere. fun blackholeSink(): Sink (js, jvm) buffer Returns a new source that buffers reads from source . The returned source will perform bulk reads into its in-memory buffer. Use this wherever you read a source to get an ergonomic and efficient access to data. fun Source .buffer(): BufferedSource Returns a new sink that buffers writes to sink . The returned sink will batch writes to sink . Use this wherever you write to a sink to get an ergonomic and efficient access to data. fun Sink .buffer(): BufferedSink (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"2.x API"},{"location":"2.x/okio/okio/#package-okio","text":"","title":"Package okio"},{"location":"2.x/okio/okio/#types","text":"Name Summary (jvm) -DeprecatedOkio object ~~-DeprecatedOkio~~ (jvm) -DeprecatedUtf8 object ~~-DeprecatedUtf8~~ (jvm) AsyncTimeout This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. open class AsyncTimeout : Timeout (js, jvm, native) Buffer A collection of bytes in memory. class Buffer : BufferedSource , BufferedSink (js, jvm, native) BufferedSink A sink that keeps a buffer internally so that callers can do small writes without a performance penalty. interface BufferedSink : Sink (js, jvm, native) BufferedSource A source that keeps a buffer internally so that callers can do small reads without a performance penalty. It also allows clients to read ahead, buffering as much as necessary before consuming input. interface BufferedSource : Source (js, jvm, native) ByteString An immutable sequence of bytes. open class ByteString : Comparable < ByteString > (jvm) DeflaterSink A sink that uses DEFLATE to compress data written to another source. class DeflaterSink : Sink (jvm) ForwardingSink A Sink which forwards calls to another. Useful for subclassing. abstract class ForwardingSink : Sink (jvm) ForwardingSource A Source which forwards calls to another. Useful for subclassing. abstract class ForwardingSource : Source (jvm) ForwardingTimeout A Timeout which forwards calls to another. Useful for subclassing. open class ForwardingTimeout : Timeout (jvm) GzipSink A sink that uses GZIP to compress written data to another sink. class GzipSink : Sink (jvm) GzipSource A source that uses GZIP to decompress data read from another source. class GzipSource : Source (jvm) HashingSink A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value. class HashingSink : ForwardingSink (jvm) HashingSource A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value. class HashingSource : ForwardingSource (jvm) InflaterSource A source that uses DEFLATE to decompress data read from another source. class InflaterSource : Source Options An indexed set of values that may be read with BufferedSource.select .(js) class Options : AbstractList < ByteString >, RandomAccess (jvm) class Options : AbstractList < ByteString >, RandomAccess (jvm) Pipe A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source. class Pipe (js, jvm, native) Sink Receives a stream of bytes. Use this interface to write data wherever it\u2019s needed: to the network, storage, or a buffer in memory. Sinks may be layered to transform received data, such as to compress, encrypt, throttle, or add protocol framing. interface Sink (js, jvm, native) Source Supplies a stream of bytes. Use this interface to read data from wherever it\u2019s located: from the network, storage, or a buffer in memory. Sources may be layered to transform supplied data, such as to decompress, decrypt, or remove protocol framing. interface Source (jvm) Throttler Enables limiting of Source and Sink throughput. Attach to this throttler via source and sink and set the desired throughput via bytesPerSecond . Multiple Sources and Sinks can be attached to a single Throttler and they will be throttled as a group, where their combined throughput will not exceed the desired throughput. The same Source or Sink can be attached to multiple Throttlers and its throughput will not exceed the desired throughput of any of the Throttlers. class Throttler (js, jvm, native) Timeout A policy on how much time to spend on a task before giving up. When a task times out, it is left in an unspecified state and should be abandoned. For example, if reading from a source times out, that source should be closed and the read should be retried later. If writing to a sink times out, the same rules apply: close the sink and retry later. open class Timeout","title":"Types"},{"location":"2.x/okio/okio/#exceptions","text":"Name Summary ArrayIndexOutOfBoundsException (js, jvm) class ArrayIndexOutOfBoundsException : IndexOutOfBoundsException (native) typealias ArrayIndexOutOfBoundsException = <ERROR CLASS> (js, jvm, native) EOFException open class EOFException : IOException IOException (js, jvm) open class IOException : Exception (native) open class IOException : Exception","title":"Exceptions"},{"location":"2.x/okio/okio/#extensions-for-external-classes","text":"Name Summary (jvm) java.io.File (jvm) java.io.InputStream (jvm) java.io.OutputStream (jvm) java.net.Socket (jvm) java.nio.file.Path (js, jvm) kotlin.String","title":"Extensions for External Classes"},{"location":"2.x/okio/okio/#properties","text":"Name Summary (jvm) Okio val Okio: -DeprecatedOkio (jvm) Utf8 val Utf8: -DeprecatedUtf8","title":"Properties"},{"location":"2.x/okio/okio/#functions","text":"Name Summary (js, jvm) blackholeSink Returns a sink that writes nowhere. fun blackholeSink(): Sink (js, jvm) buffer Returns a new source that buffers reads from source . The returned source will perform bulk reads into its in-memory buffer. Use this wherever you read a source to get an ergonomic and efficient access to data. fun Source .buffer(): BufferedSource Returns a new sink that buffers writes to sink . The returned sink will batch writes to sink . Use this wherever you write to a sink to get an ergonomic and efficient access to data. fun Sink .buffer(): BufferedSink (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"Functions"},{"location":"2.x/okio/okio/-okio/","text":"okio / okio / Okio Okio \u00b6 (jvm) val Okio: -DeprecatedOkio","title":"Okio - Okio"},{"location":"2.x/okio/okio/-okio/#okio","text":"(jvm) val Okio: -DeprecatedOkio","title":"Okio"},{"location":"2.x/okio/okio/-utf8/","text":"okio / okio / Utf8 Utf8 \u00b6 (jvm) val Utf8: -DeprecatedUtf8","title":"Utf8 - Okio"},{"location":"2.x/okio/okio/-utf8/#utf8","text":"(jvm) val Utf8: -DeprecatedUtf8","title":"Utf8"},{"location":"2.x/okio/okio/blackhole-sink/","text":"okio / okio / blackholeSink blackholeSink \u00b6 (js, jvm) @JvmName(\"blackhole\") fun blackholeSink(): Sink Returns a sink that writes nowhere.","title":"blackholeSink - Okio"},{"location":"2.x/okio/okio/blackhole-sink/#blackholesink","text":"(js, jvm) @JvmName(\"blackhole\") fun blackholeSink(): Sink Returns a sink that writes nowhere.","title":"blackholeSink"},{"location":"2.x/okio/okio/buffer/","text":"okio / okio / buffer buffer \u00b6 (js, jvm) fun Source .buffer(): BufferedSource Returns a new source that buffers reads from source . The returned source will perform bulk reads into its in-memory buffer. Use this wherever you read a source to get an ergonomic and efficient access to data. (js, jvm) fun Sink .buffer(): BufferedSink Returns a new sink that buffers writes to sink . The returned sink will batch writes to sink . Use this wherever you write to a sink to get an ergonomic and efficient access to data.","title":"buffer - Okio"},{"location":"2.x/okio/okio/buffer/#buffer","text":"(js, jvm) fun Source .buffer(): BufferedSource Returns a new source that buffers reads from source . The returned source will perform bulk reads into its in-memory buffer. Use this wherever you read a source to get an ergonomic and efficient access to data. (js, jvm) fun Sink .buffer(): BufferedSink Returns a new sink that buffers writes to sink . The returned sink will batch writes to sink . Use this wherever you write to a sink to get an ergonomic and efficient access to data.","title":"buffer"},{"location":"2.x/okio/okio/deflate/","text":"okio / okio / deflate deflate \u00b6 (jvm) fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. See Also DeflaterSink","title":"deflate - Okio"},{"location":"2.x/okio/okio/deflate/#deflate","text":"(jvm) fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. See Also DeflaterSink","title":"deflate"},{"location":"2.x/okio/okio/gzip/","text":"okio / okio / gzip gzip \u00b6 (jvm) fun Sink .gzip(): GzipSink Returns a GzipSink that gzip-compresses to this Sink while writing. See Also GzipSource (jvm) fun Source .gzip(): GzipSource Returns a GzipSource that gzip-decompresses this Source while reading. See Also GzipSource","title":"gzip - Okio"},{"location":"2.x/okio/okio/gzip/#gzip","text":"(jvm) fun Sink .gzip(): GzipSink Returns a GzipSink that gzip-compresses to this Sink while writing. See Also GzipSource (jvm) fun Source .gzip(): GzipSource Returns a GzipSource that gzip-decompresses this Source while reading. See Also GzipSource","title":"gzip"},{"location":"2.x/okio/okio/inflate/","text":"okio / okio / inflate inflate \u00b6 (jvm) fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource Returns an InflaterSource that DEFLATE-decompresses this Source while reading. See Also InflaterSource","title":"inflate - Okio"},{"location":"2.x/okio/okio/inflate/#inflate","text":"(jvm) fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource Returns an InflaterSource that DEFLATE-decompresses this Source while reading. See Also InflaterSource","title":"inflate"},{"location":"2.x/okio/okio/--deprecated-okio/","text":"okio / okio / -DeprecatedOkio -DeprecatedOkio \u00b6 (jvm) object ~~-DeprecatedOkio~~ Deprecated: changed in Okio 2.x Functions \u00b6 Name Summary (jvm) appendingSink fun ~~appendingSink~~(file: File ): Sink (jvm) blackhole fun ~~blackhole~~(): Sink (jvm) buffer fun ~~buffer~~(sink: Sink ): BufferedSink fun ~~buffer~~(source: Source ): BufferedSource (jvm) sink fun ~~sink~~(file: File ): Sink fun ~~sink~~(outputStream: OutputStream ): Sink fun ~~sink~~(path: Path, vararg options: OpenOption): Sink fun ~~sink~~(socket: Socket ): Sink (jvm) source fun ~~source~~(file: File ): Source fun ~~source~~(inputStream: InputStream ): Source fun ~~source~~(path: Path, vararg options: OpenOption): Source fun ~~source~~(socket: Socket ): Source","title":"-DeprecatedOkio - Okio"},{"location":"2.x/okio/okio/--deprecated-okio/#-deprecatedokio","text":"(jvm) object ~~-DeprecatedOkio~~ Deprecated: changed in Okio 2.x","title":"-DeprecatedOkio"},{"location":"2.x/okio/okio/--deprecated-okio/#functions","text":"Name Summary (jvm) appendingSink fun ~~appendingSink~~(file: File ): Sink (jvm) blackhole fun ~~blackhole~~(): Sink (jvm) buffer fun ~~buffer~~(sink: Sink ): BufferedSink fun ~~buffer~~(source: Source ): BufferedSource (jvm) sink fun ~~sink~~(file: File ): Sink fun ~~sink~~(outputStream: OutputStream ): Sink fun ~~sink~~(path: Path, vararg options: OpenOption): Sink fun ~~sink~~(socket: Socket ): Sink (jvm) source fun ~~source~~(file: File ): Source fun ~~source~~(inputStream: InputStream ): Source fun ~~source~~(path: Path, vararg options: OpenOption): Source fun ~~source~~(socket: Socket ): Source","title":"Functions"},{"location":"2.x/okio/okio/--deprecated-okio/appending-sink/","text":"okio / okio / -DeprecatedOkio / appendingSink appendingSink \u00b6 (jvm) fun ~~appendingSink~~(file: File ): Sink Deprecated: moved to extension function","title":"appendingSink - Okio"},{"location":"2.x/okio/okio/--deprecated-okio/appending-sink/#appendingsink","text":"(jvm) fun ~~appendingSink~~(file: File ): Sink Deprecated: moved to extension function","title":"appendingSink"},{"location":"2.x/okio/okio/--deprecated-okio/blackhole/","text":"okio / okio / -DeprecatedOkio / blackhole blackhole \u00b6 (jvm) fun ~~blackhole~~(): Sink Deprecated: moved to extension function","title":"blackhole - Okio"},{"location":"2.x/okio/okio/--deprecated-okio/blackhole/#blackhole","text":"(jvm) fun ~~blackhole~~(): Sink Deprecated: moved to extension function","title":"blackhole"},{"location":"2.x/okio/okio/--deprecated-okio/buffer/","text":"okio / okio / -DeprecatedOkio / buffer buffer \u00b6 (jvm) fun ~~buffer~~(sink: Sink ): BufferedSink Deprecated: moved to extension function fun ~~buffer~~(source: Source ): BufferedSource Deprecated: moved to extension function","title":"buffer - Okio"},{"location":"2.x/okio/okio/--deprecated-okio/buffer/#buffer","text":"(jvm) fun ~~buffer~~(sink: Sink ): BufferedSink Deprecated: moved to extension function fun ~~buffer~~(source: Source ): BufferedSource Deprecated: moved to extension function","title":"buffer"},{"location":"2.x/okio/okio/--deprecated-okio/sink/","text":"okio / okio / -DeprecatedOkio / sink sink \u00b6 (jvm) fun ~~sink~~(file: File ): Sink Deprecated: moved to extension function fun ~~sink~~(outputStream: OutputStream ): Sink Deprecated: moved to extension function fun ~~sink~~(path: Path, vararg options: OpenOption): Sink Deprecated: moved to extension function fun ~~sink~~(socket: Socket ): Sink Deprecated: moved to extension function","title":"sink - Okio"},{"location":"2.x/okio/okio/--deprecated-okio/sink/#sink","text":"(jvm) fun ~~sink~~(file: File ): Sink Deprecated: moved to extension function fun ~~sink~~(outputStream: OutputStream ): Sink Deprecated: moved to extension function fun ~~sink~~(path: Path, vararg options: OpenOption): Sink Deprecated: moved to extension function fun ~~sink~~(socket: Socket ): Sink Deprecated: moved to extension function","title":"sink"},{"location":"2.x/okio/okio/--deprecated-okio/source/","text":"okio / okio / -DeprecatedOkio / source source \u00b6 (jvm) fun ~~source~~(file: File ): Source Deprecated: moved to extension function fun ~~source~~(inputStream: InputStream ): Source Deprecated: moved to extension function fun ~~source~~(path: Path, vararg options: OpenOption): Source Deprecated: moved to extension function fun ~~source~~(socket: Socket ): Source Deprecated: moved to extension function","title":"source - Okio"},{"location":"2.x/okio/okio/--deprecated-okio/source/#source","text":"(jvm) fun ~~source~~(file: File ): Source Deprecated: moved to extension function fun ~~source~~(inputStream: InputStream ): Source Deprecated: moved to extension function fun ~~source~~(path: Path, vararg options: OpenOption): Source Deprecated: moved to extension function fun ~~source~~(socket: Socket ): Source Deprecated: moved to extension function","title":"source"},{"location":"2.x/okio/okio/--deprecated-utf8/","text":"okio / okio / -DeprecatedUtf8 -DeprecatedUtf8 \u00b6 (jvm) object ~~-DeprecatedUtf8~~ Deprecated: changed in Okio 2.x Functions \u00b6 Name Summary (jvm) size fun ~~size~~(string: String ): Long fun ~~size~~(string: String , beginIndex: Int , endIndex: Int ): Long","title":"-DeprecatedUtf8 - Okio"},{"location":"2.x/okio/okio/--deprecated-utf8/#-deprecatedutf8","text":"(jvm) object ~~-DeprecatedUtf8~~ Deprecated: changed in Okio 2.x","title":"-DeprecatedUtf8"},{"location":"2.x/okio/okio/--deprecated-utf8/#functions","text":"Name Summary (jvm) size fun ~~size~~(string: String ): Long fun ~~size~~(string: String , beginIndex: Int , endIndex: Int ): Long","title":"Functions"},{"location":"2.x/okio/okio/--deprecated-utf8/size/","text":"okio / okio / -DeprecatedUtf8 / size size \u00b6 (jvm) fun ~~size~~(string: String ): Long Deprecated: moved to extension function fun ~~size~~(string: String , beginIndex: Int , endIndex: Int ): Long Deprecated: moved to extension function","title":"size - Okio"},{"location":"2.x/okio/okio/--deprecated-utf8/size/#size","text":"(jvm) fun ~~size~~(string: String ): Long Deprecated: moved to extension function fun ~~size~~(string: String , beginIndex: Int , endIndex: Int ): Long Deprecated: moved to extension function","title":"size"},{"location":"2.x/okio/okio/-array-index-out-of-bounds-exception/","text":"okio / okio / ArrayIndexOutOfBoundsException ArrayIndexOutOfBoundsException \u00b6 (js, jvm) class ArrayIndexOutOfBoundsException : IndexOutOfBoundsException (native) typealias ArrayIndexOutOfBoundsException = <ERROR CLASS> Constructors \u00b6 Name Summary (js, jvm) <init> <init>(message: String ?)","title":"ArrayIndexOutOfBoundsException - Okio"},{"location":"2.x/okio/okio/-array-index-out-of-bounds-exception/#arrayindexoutofboundsexception","text":"(js, jvm) class ArrayIndexOutOfBoundsException : IndexOutOfBoundsException (native) typealias ArrayIndexOutOfBoundsException = <ERROR CLASS>","title":"ArrayIndexOutOfBoundsException"},{"location":"2.x/okio/okio/-array-index-out-of-bounds-exception/#constructors","text":"Name Summary (js, jvm) <init> <init>(message: String ?)","title":"Constructors"},{"location":"2.x/okio/okio/-array-index-out-of-bounds-exception/-init-/","text":"okio / okio / ArrayIndexOutOfBoundsException / <init> <init> \u00b6 (js, jvm) <init>(message: String ?)","title":" init "},{"location":"2.x/okio/okio/-array-index-out-of-bounds-exception/-init-/#init","text":"(js, jvm) <init>(message: String ?)","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-async-timeout/","text":"okio / okio / AsyncTimeout AsyncTimeout \u00b6 (jvm) open class AsyncTimeout : Timeout This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. Subclasses should override timedOut to take action when a timeout occurs. This method will be invoked by the shared watchdog thread so it should not do any long-running operations. Otherwise we risk starving other timeouts from being triggered. Use sink and source to apply this timeout to a stream. The returned value will apply the timeout to each operation on the wrapped stream. Callers should call enter before doing work that is subject to timeouts, and exit afterwards. The return value of exit indicates whether a timeout was triggered. Note that the call to timedOut is asynchronous, and may be called after exit . Constructors \u00b6 Name Summary (jvm) <init> This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. AsyncTimeout() Functions \u00b6 Name Summary (jvm) enter fun enter(): Unit (jvm) exit Returns true if the timeout occurred. fun exit(): Boolean (jvm) newTimeoutException Returns an IOException to represent a timeout. By default this method returns InterruptedIOException . If cause is non-null it is set as the cause of the returned exception. open fun newTimeoutException(cause: IOException ?): IOException (jvm) sink Returns a new sink that delegates to sink , using this to implement timeouts. This works best if timedOut is overridden to interrupt sink \u2018s current operation. fun sink(sink: Sink ): Sink (jvm) source Returns a new source that delegates to source , using this to implement timeouts. This works best if timedOut is overridden to interrupt source \u2018s current operation. fun source(source: Source ): Source (jvm) timedOut Invoked by the watchdog thread when the time between calls to enter and exit has exceeded the timeout. open fun timedOut(): Unit (jvm) withTimeout Surrounds block with calls to enter and exit , throwing an exception from newTimeoutException if a timeout occurred. fun <T> withTimeout(block: () -> T): T Inherited Functions \u00b6 Name Summary (jvm) clearDeadline Clears the deadline. open fun clearDeadline(): Timeout (jvm) clearTimeout Clears the timeout. Operating system timeouts may still apply. open fun clearTimeout(): Timeout (jvm) deadline Set a deadline of now plus duration time. fun deadline(duration: Long , unit: TimeUnit ): Timeout (jvm) deadlineNanoTime Returns the nano time when the deadline will be reached. open fun deadlineNanoTime(): Long Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. open fun deadlineNanoTime(deadlineNanoTime: Long ): Timeout (jvm) hasDeadline Returns true if a deadline is enabled. open fun hasDeadline(): Boolean (jvm) intersectWith Applies the minimum intersection between this timeout and other , run block , then finally rollback this timeout\u2019s values. fun intersectWith(other: Timeout , block: () -> Unit ): Unit (jvm) throwIfReached Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. open fun throwIfReached(): Unit (jvm) timeout Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail. open fun timeout(timeout: Long , unit: TimeUnit ): Timeout (jvm) timeoutNanos Returns the timeout in nanoseconds, or 0 for no timeout. open fun timeoutNanos(): Long (jvm) waitUntilNotified Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor . fun waitUntilNotified(monitor: Any ): Unit","title":"AsyncTimeout - Okio"},{"location":"2.x/okio/okio/-async-timeout/#asynctimeout","text":"(jvm) open class AsyncTimeout : Timeout This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. Subclasses should override timedOut to take action when a timeout occurs. This method will be invoked by the shared watchdog thread so it should not do any long-running operations. Otherwise we risk starving other timeouts from being triggered. Use sink and source to apply this timeout to a stream. The returned value will apply the timeout to each operation on the wrapped stream. Callers should call enter before doing work that is subject to timeouts, and exit afterwards. The return value of exit indicates whether a timeout was triggered. Note that the call to timedOut is asynchronous, and may be called after exit .","title":"AsyncTimeout"},{"location":"2.x/okio/okio/-async-timeout/#constructors","text":"Name Summary (jvm) <init> This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. AsyncTimeout()","title":"Constructors"},{"location":"2.x/okio/okio/-async-timeout/#functions","text":"Name Summary (jvm) enter fun enter(): Unit (jvm) exit Returns true if the timeout occurred. fun exit(): Boolean (jvm) newTimeoutException Returns an IOException to represent a timeout. By default this method returns InterruptedIOException . If cause is non-null it is set as the cause of the returned exception. open fun newTimeoutException(cause: IOException ?): IOException (jvm) sink Returns a new sink that delegates to sink , using this to implement timeouts. This works best if timedOut is overridden to interrupt sink \u2018s current operation. fun sink(sink: Sink ): Sink (jvm) source Returns a new source that delegates to source , using this to implement timeouts. This works best if timedOut is overridden to interrupt source \u2018s current operation. fun source(source: Source ): Source (jvm) timedOut Invoked by the watchdog thread when the time between calls to enter and exit has exceeded the timeout. open fun timedOut(): Unit (jvm) withTimeout Surrounds block with calls to enter and exit , throwing an exception from newTimeoutException if a timeout occurred. fun <T> withTimeout(block: () -> T): T","title":"Functions"},{"location":"2.x/okio/okio/-async-timeout/#inherited-functions","text":"Name Summary (jvm) clearDeadline Clears the deadline. open fun clearDeadline(): Timeout (jvm) clearTimeout Clears the timeout. Operating system timeouts may still apply. open fun clearTimeout(): Timeout (jvm) deadline Set a deadline of now plus duration time. fun deadline(duration: Long , unit: TimeUnit ): Timeout (jvm) deadlineNanoTime Returns the nano time when the deadline will be reached. open fun deadlineNanoTime(): Long Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. open fun deadlineNanoTime(deadlineNanoTime: Long ): Timeout (jvm) hasDeadline Returns true if a deadline is enabled. open fun hasDeadline(): Boolean (jvm) intersectWith Applies the minimum intersection between this timeout and other , run block , then finally rollback this timeout\u2019s values. fun intersectWith(other: Timeout , block: () -> Unit ): Unit (jvm) throwIfReached Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. open fun throwIfReached(): Unit (jvm) timeout Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail. open fun timeout(timeout: Long , unit: TimeUnit ): Timeout (jvm) timeoutNanos Returns the timeout in nanoseconds, or 0 for no timeout. open fun timeoutNanos(): Long (jvm) waitUntilNotified Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor . fun waitUntilNotified(monitor: Any ): Unit","title":"Inherited Functions"},{"location":"2.x/okio/okio/-async-timeout/-init-/","text":"okio / okio / AsyncTimeout / <init> <init> \u00b6 (jvm) AsyncTimeout() This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. Subclasses should override timedOut to take action when a timeout occurs. This method will be invoked by the shared watchdog thread so it should not do any long-running operations. Otherwise we risk starving other timeouts from being triggered. Use sink and source to apply this timeout to a stream. The returned value will apply the timeout to each operation on the wrapped stream. Callers should call enter before doing work that is subject to timeouts, and exit afterwards. The return value of exit indicates whether a timeout was triggered. Note that the call to timedOut is asynchronous, and may be called after exit .","title":" init "},{"location":"2.x/okio/okio/-async-timeout/-init-/#init","text":"(jvm) AsyncTimeout() This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. Subclasses should override timedOut to take action when a timeout occurs. This method will be invoked by the shared watchdog thread so it should not do any long-running operations. Otherwise we risk starving other timeouts from being triggered. Use sink and source to apply this timeout to a stream. The returned value will apply the timeout to each operation on the wrapped stream. Callers should call enter before doing work that is subject to timeouts, and exit afterwards. The return value of exit indicates whether a timeout was triggered. Note that the call to timedOut is asynchronous, and may be called after exit .","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-async-timeout/enter/","text":"okio / okio / AsyncTimeout / enter enter \u00b6 (jvm) fun enter(): Unit","title":"enter - Okio"},{"location":"2.x/okio/okio/-async-timeout/enter/#enter","text":"(jvm) fun enter(): Unit","title":"enter"},{"location":"2.x/okio/okio/-async-timeout/exit/","text":"okio / okio / AsyncTimeout / exit exit \u00b6 (jvm) fun exit(): Boolean Returns true if the timeout occurred.","title":"exit - Okio"},{"location":"2.x/okio/okio/-async-timeout/exit/#exit","text":"(jvm) fun exit(): Boolean Returns true if the timeout occurred.","title":"exit"},{"location":"2.x/okio/okio/-async-timeout/new-timeout-exception/","text":"okio / okio / AsyncTimeout / newTimeoutException newTimeoutException \u00b6 (jvm) protected open fun newTimeoutException(cause: IOException ?): IOException Returns an IOException to represent a timeout. By default this method returns InterruptedIOException . If cause is non-null it is set as the cause of the returned exception.","title":"newTimeoutException - Okio"},{"location":"2.x/okio/okio/-async-timeout/new-timeout-exception/#newtimeoutexception","text":"(jvm) protected open fun newTimeoutException(cause: IOException ?): IOException Returns an IOException to represent a timeout. By default this method returns InterruptedIOException . If cause is non-null it is set as the cause of the returned exception.","title":"newTimeoutException"},{"location":"2.x/okio/okio/-async-timeout/sink/","text":"okio / okio / AsyncTimeout / sink sink \u00b6 (jvm) fun sink(sink: Sink ): Sink Returns a new sink that delegates to sink , using this to implement timeouts. This works best if timedOut is overridden to interrupt sink \u2018s current operation.","title":"sink - Okio"},{"location":"2.x/okio/okio/-async-timeout/sink/#sink","text":"(jvm) fun sink(sink: Sink ): Sink Returns a new sink that delegates to sink , using this to implement timeouts. This works best if timedOut is overridden to interrupt sink \u2018s current operation.","title":"sink"},{"location":"2.x/okio/okio/-async-timeout/source/","text":"okio / okio / AsyncTimeout / source source \u00b6 (jvm) fun source(source: Source ): Source Returns a new source that delegates to source , using this to implement timeouts. This works best if timedOut is overridden to interrupt source \u2018s current operation.","title":"source - Okio"},{"location":"2.x/okio/okio/-async-timeout/source/#source","text":"(jvm) fun source(source: Source ): Source Returns a new source that delegates to source , using this to implement timeouts. This works best if timedOut is overridden to interrupt source \u2018s current operation.","title":"source"},{"location":"2.x/okio/okio/-async-timeout/timed-out/","text":"okio / okio / AsyncTimeout / timedOut timedOut \u00b6 (jvm) protected open fun timedOut(): Unit Invoked by the watchdog thread when the time between calls to enter and exit has exceeded the timeout.","title":"timedOut - Okio"},{"location":"2.x/okio/okio/-async-timeout/timed-out/#timedout","text":"(jvm) protected open fun timedOut(): Unit Invoked by the watchdog thread when the time between calls to enter and exit has exceeded the timeout.","title":"timedOut"},{"location":"2.x/okio/okio/-async-timeout/with-timeout/","text":"okio / okio / AsyncTimeout / withTimeout withTimeout \u00b6 (jvm) inline fun <T> withTimeout(block: () -> T): T Surrounds block with calls to enter and exit , throwing an exception from newTimeoutException if a timeout occurred.","title":"withTimeout - Okio"},{"location":"2.x/okio/okio/-async-timeout/with-timeout/#withtimeout","text":"(jvm) inline fun <T> withTimeout(block: () -> T): T Surrounds block with calls to enter and exit , throwing an exception from newTimeoutException if a timeout occurred.","title":"withTimeout"},{"location":"2.x/okio/okio/-buffer/","text":"okio / okio / Buffer Buffer \u00b6 (js, jvm, native) class Buffer : BufferedSource , BufferedSink A collection of bytes in memory. Moving data from one buffer to another is fast. Instead of copying bytes from one place in memory to another, this class just changes ownership of the underlying byte arrays. This buffer grows with your data. Just like ArrayList, each buffer starts small. It consumes only the memory it needs to. This buffer pools its byte arrays. When you allocate a byte array in Java, the runtime must zero-fill the requested array before returning it to you. Even if you\u2019re going to write over that space anyway. This class avoids zero-fill and GC churn by pooling byte arrays. Types \u00b6 Name Summary (jvm) UnsafeCursor A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences. class UnsafeCursor : Closeable Constructors \u00b6 Name Summary (js, jvm, native) <init> A collection of bytes in memory. <init>() Properties \u00b6 Name Summary (js, jvm, native) buffer val buffer: Buffer (js, jvm, native) size var size: Long Functions \u00b6 Name Summary (jvm) buffer Returns this source\u2019s internal buffer. fun buffer(): Buffer (js, jvm, native) clear Discards all bytes in this buffer. Calling this method when you\u2019re done with a buffer will return its segments to the pool. fun clear(): Unit (jvm) clone Returns a deep copy of this buffer. fun clone(): Buffer (js, jvm, native) close fun close(): Unit (js, jvm, native) completeSegmentByteCount Returns the number of bytes in segments that are not writable. This is the number of bytes that can be flushed immediately to an underlying sink without harming throughput. fun completeSegmentByteCount(): Long (js, jvm, native) copy Returns a deep copy of this buffer. fun copy(): Buffer copyTo Copy byteCount bytes from this, starting at offset , to out .(jvm) fun copyTo(out: OutputStream , offset: Long = 0L, byteCount: Long = size - offset): Buffer (js, jvm) fun copyTo(out: Buffer , offset: Long = 0L, byteCount: Long ): Buffer (native) fun copyTo(out: Buffer , offset: Long , byteCount: Long ): Buffer Overload of copyTo with byteCount = size - offset, work around for https://youtrack.jetbrains.com/issue/KT-30847(js , jvm) fun copyTo(out: Buffer , offset: Long = 0L): Buffer (native) fun copyTo(out: Buffer , offset: Long ): Buffer (js, jvm, native) emit fun emit(): Buffer (js, jvm, native) emitCompleteSegments fun emitCompleteSegments(): Buffer (js, jvm, native) equals fun equals(other: Any ?): Boolean (js, jvm, native) exhausted fun exhausted(): Boolean (js, jvm, native) flush fun flush(): Unit (js, jvm, native) get Returns the byte at pos . operator fun get(pos: Long ): Byte (jvm) getByte fun ~~getByte~~(index: Long ): Byte (js, jvm, native) hashCode fun hashCode(): Int (jvm) hmacSha1 Returns the 160-bit SHA-1 HMAC of this buffer. fun hmacSha1(key: ByteString ): ByteString (jvm) hmacSha256 Returns the 256-bit SHA-256 HMAC of this buffer. fun hmacSha256(key: ByteString ): ByteString (jvm) hmacSha512 Returns the 512-bit SHA-512 HMAC of this buffer. fun hmacSha512(key: ByteString ): ByteString (js, jvm, native) indexOf fun indexOf(b: Byte ): Long fun indexOf(b: Byte , fromIndex: Long , toIndex: Long ): Long fun indexOf(bytes: ByteString ): Long fun indexOf(bytes: ByteString , fromIndex: Long ): Long Returns the index of b in this at or beyond fromIndex , or -1 if this buffer does not contain b in that range. fun indexOf(b: Byte , fromIndex: Long ): Long (js, jvm, native) indexOfElement fun indexOfElement(targetBytes: ByteString ): Long fun indexOfElement(targetBytes: ByteString , fromIndex: Long ): Long (jvm) inputStream Returns an input stream that reads from this source. fun inputStream(): InputStream (jvm) isOpen fun isOpen(): Boolean (jvm) md5 Returns the 128-bit MD5 hash of this buffer. fun md5(): ByteString (jvm) outputStream Returns an output stream that writes to this sink. fun outputStream(): OutputStream (js, jvm, native) peek fun peek(): BufferedSource (js, jvm, native) rangeEquals fun rangeEquals(offset: Long , bytes: ByteString ): Boolean fun rangeEquals(offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean read (jvm) fun read(sink: ByteBuffer ): Int (js, jvm, native) fun read(sink: ByteArray ): Int (js, jvm, native) fun read(sink: ByteArray , offset: Int , byteCount: Int ): Int (js, jvm, native) fun read(sink: Buffer , byteCount: Long ): Long (js, jvm, native) readAll fun readAll(sink: Sink ): Long (jvm) readAndWriteUnsafe fun readAndWriteUnsafe(unsafeCursor: Buffer.UnsafeCursor = UnsafeCursor()): Buffer.UnsafeCursor (js, jvm, native) readByte fun readByte(): Byte (js, jvm, native) readByteArray fun readByteArray(): ByteArray fun readByteArray(byteCount: Long ): ByteArray (js, jvm, native) readByteString fun readByteString(): ByteString fun readByteString(byteCount: Long ): ByteString (js, jvm, native) readDecimalLong fun readDecimalLong(): Long (jvm) readFrom Read and exhaust bytes from input into this. fun readFrom(input: InputStream ): Buffer Read byteCount bytes from input into this. fun readFrom(input: InputStream , byteCount: Long ): Buffer (js, jvm, native) readFully fun readFully(sink: Buffer , byteCount: Long ): Unit fun readFully(sink: ByteArray ): Unit (js, jvm, native) readHexadecimalUnsignedLong fun readHexadecimalUnsignedLong(): Long (js, jvm, native) readInt fun readInt(): Int (js, jvm, native) readIntLe fun readIntLe(): Int (js, jvm, native) readLong fun readLong(): Long (js, jvm, native) readLongLe fun readLongLe(): Long (js, jvm, native) readShort fun readShort(): Short (js, jvm, native) readShortLe fun readShortLe(): Short (jvm) readString Removes all bytes from this, decodes them as charset , and returns the string. fun readString(charset: Charset ): String Removes byteCount bytes from this, decodes them as charset , and returns the string. fun readString(byteCount: Long , charset: Charset ): String (jvm) readUnsafe fun readUnsafe(unsafeCursor: Buffer.UnsafeCursor = UnsafeCursor()): Buffer.UnsafeCursor (js, jvm, native) readUtf8 fun readUtf8(): String fun readUtf8(byteCount: Long ): String (js, jvm, native) readUtf8CodePoint fun readUtf8CodePoint(): Int (js, jvm, native) readUtf8Line fun readUtf8Line(): String ? (js, jvm, native) readUtf8LineStrict fun readUtf8LineStrict(): String fun readUtf8LineStrict(limit: Long ): String (js, jvm, native) request fun request(byteCount: Long ): Boolean (js, jvm, native) require fun require(byteCount: Long ): Unit select (native) fun select(options: <ERROR CLASS>): Int (js, jvm) fun select(options: Options ): Int (jvm) sha1 Returns the 160-bit SHA-1 hash of this buffer. fun sha1(): ByteString (jvm) sha256 Returns the 256-bit SHA-256 hash of this buffer. fun sha256(): ByteString (jvm) sha512 Returns the 512-bit SHA-512 hash of this buffer. fun sha512(): ByteString (jvm) size fun ~~size~~(): Long (js, jvm, native) skip Discards byteCount bytes from the head of this buffer. fun skip(byteCount: Long ): Unit (js, jvm, native) snapshot Returns an immutable copy of this buffer as a byte string. fun snapshot(): ByteString Returns an immutable copy of the first byteCount bytes of this buffer as a byte string. fun snapshot(byteCount: Int ): ByteString (js, jvm, native) timeout fun timeout(): Timeout toString Returns a human-readable string that describes the contents of this buffer. Typically this is a string like [text=Hello] or [hex=0000ffff] .(js, jvm) fun toString(): String (native) fun toString(): <ERROR CLASS> write (jvm) fun write(source: ByteBuffer ): Int (js, jvm, native) fun write(byteString: ByteString ): Buffer (js, jvm) fun write(byteString: ByteString , offset: Int , byteCount: Int ): Buffer (native) fun write(byteString: ByteString , offset: Int , byteCount: Int ): <ERROR CLASS> (js, jvm, native) fun write(source: ByteArray ): Buffer (js, jvm, native) fun write(source: ByteArray , offset: Int , byteCount: Int ): Buffer (js, jvm, native) fun write(source: Source , byteCount: Long ): Buffer (js, jvm, native) fun write(source: Buffer , byteCount: Long ): Unit (js, jvm, native) writeAll fun writeAll(source: Source ): Long (js, jvm, native) writeByte fun writeByte(b: Int ): Buffer (js, jvm, native) writeDecimalLong fun writeDecimalLong(v: Long ): Buffer (js, jvm, native) writeHexadecimalUnsignedLong fun writeHexadecimalUnsignedLong(v: Long ): Buffer (js, jvm, native) writeInt fun writeInt(i: Int ): Buffer (js, jvm, native) writeIntLe fun writeIntLe(i: Int ): Buffer (js, jvm, native) writeLong fun writeLong(v: Long ): Buffer (js, jvm, native) writeLongLe fun writeLongLe(v: Long ): Buffer (js, jvm, native) writeShort fun writeShort(s: Int ): Buffer (js, jvm, native) writeShortLe fun writeShortLe(s: Int ): Buffer (jvm) writeString fun writeString(string: String , charset: Charset ): Buffer fun writeString(string: String , beginIndex: Int , endIndex: Int , charset: Charset ): Buffer (jvm) writeTo Write byteCount bytes from this to out . fun writeTo(out: OutputStream , byteCount: Long = size): Buffer (js, jvm, native) writeUtf8 fun writeUtf8(string: String ): Buffer fun writeUtf8(string: String , beginIndex: Int , endIndex: Int ): Buffer (js, jvm, native) writeUtf8CodePoint fun writeUtf8CodePoint(codePoint: Int ): Buffer Inherited Functions \u00b6 Name Summary (jvm) buffer Returns this source\u2019s internal buffer. abstract fun ~~buffer~~(): Buffer (jvm) inputStream Returns an input stream that reads from this source. abstract fun inputStream(): InputStream (jvm) outputStream Returns an output stream that writes to this sink. abstract fun outputStream(): OutputStream (jvm) readString Removes all bytes from this, decodes them as charset , and returns the string. abstract fun readString(charset: Charset ): String Removes byteCount bytes from this, decodes them as charset , and returns the string. abstract fun readString(byteCount: Long , charset: Charset ): String (jvm) writeString abstract fun writeString(string: String , charset: Charset ): BufferedSink abstract fun writeString(string: String , beginIndex: Int , endIndex: Int , charset: Charset ): BufferedSink Extension Functions \u00b6 Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"Buffer - Okio"},{"location":"2.x/okio/okio/-buffer/#buffer","text":"(js, jvm, native) class Buffer : BufferedSource , BufferedSink A collection of bytes in memory. Moving data from one buffer to another is fast. Instead of copying bytes from one place in memory to another, this class just changes ownership of the underlying byte arrays. This buffer grows with your data. Just like ArrayList, each buffer starts small. It consumes only the memory it needs to. This buffer pools its byte arrays. When you allocate a byte array in Java, the runtime must zero-fill the requested array before returning it to you. Even if you\u2019re going to write over that space anyway. This class avoids zero-fill and GC churn by pooling byte arrays.","title":"Buffer"},{"location":"2.x/okio/okio/-buffer/#types","text":"Name Summary (jvm) UnsafeCursor A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences. class UnsafeCursor : Closeable","title":"Types"},{"location":"2.x/okio/okio/-buffer/#constructors","text":"Name Summary (js, jvm, native) <init> A collection of bytes in memory. <init>()","title":"Constructors"},{"location":"2.x/okio/okio/-buffer/#properties","text":"Name Summary (js, jvm, native) buffer val buffer: Buffer (js, jvm, native) size var size: Long","title":"Properties"},{"location":"2.x/okio/okio/-buffer/#functions","text":"Name Summary (jvm) buffer Returns this source\u2019s internal buffer. fun buffer(): Buffer (js, jvm, native) clear Discards all bytes in this buffer. Calling this method when you\u2019re done with a buffer will return its segments to the pool. fun clear(): Unit (jvm) clone Returns a deep copy of this buffer. fun clone(): Buffer (js, jvm, native) close fun close(): Unit (js, jvm, native) completeSegmentByteCount Returns the number of bytes in segments that are not writable. This is the number of bytes that can be flushed immediately to an underlying sink without harming throughput. fun completeSegmentByteCount(): Long (js, jvm, native) copy Returns a deep copy of this buffer. fun copy(): Buffer copyTo Copy byteCount bytes from this, starting at offset , to out .(jvm) fun copyTo(out: OutputStream , offset: Long = 0L, byteCount: Long = size - offset): Buffer (js, jvm) fun copyTo(out: Buffer , offset: Long = 0L, byteCount: Long ): Buffer (native) fun copyTo(out: Buffer , offset: Long , byteCount: Long ): Buffer Overload of copyTo with byteCount = size - offset, work around for https://youtrack.jetbrains.com/issue/KT-30847(js , jvm) fun copyTo(out: Buffer , offset: Long = 0L): Buffer (native) fun copyTo(out: Buffer , offset: Long ): Buffer (js, jvm, native) emit fun emit(): Buffer (js, jvm, native) emitCompleteSegments fun emitCompleteSegments(): Buffer (js, jvm, native) equals fun equals(other: Any ?): Boolean (js, jvm, native) exhausted fun exhausted(): Boolean (js, jvm, native) flush fun flush(): Unit (js, jvm, native) get Returns the byte at pos . operator fun get(pos: Long ): Byte (jvm) getByte fun ~~getByte~~(index: Long ): Byte (js, jvm, native) hashCode fun hashCode(): Int (jvm) hmacSha1 Returns the 160-bit SHA-1 HMAC of this buffer. fun hmacSha1(key: ByteString ): ByteString (jvm) hmacSha256 Returns the 256-bit SHA-256 HMAC of this buffer. fun hmacSha256(key: ByteString ): ByteString (jvm) hmacSha512 Returns the 512-bit SHA-512 HMAC of this buffer. fun hmacSha512(key: ByteString ): ByteString (js, jvm, native) indexOf fun indexOf(b: Byte ): Long fun indexOf(b: Byte , fromIndex: Long , toIndex: Long ): Long fun indexOf(bytes: ByteString ): Long fun indexOf(bytes: ByteString , fromIndex: Long ): Long Returns the index of b in this at or beyond fromIndex , or -1 if this buffer does not contain b in that range. fun indexOf(b: Byte , fromIndex: Long ): Long (js, jvm, native) indexOfElement fun indexOfElement(targetBytes: ByteString ): Long fun indexOfElement(targetBytes: ByteString , fromIndex: Long ): Long (jvm) inputStream Returns an input stream that reads from this source. fun inputStream(): InputStream (jvm) isOpen fun isOpen(): Boolean (jvm) md5 Returns the 128-bit MD5 hash of this buffer. fun md5(): ByteString (jvm) outputStream Returns an output stream that writes to this sink. fun outputStream(): OutputStream (js, jvm, native) peek fun peek(): BufferedSource (js, jvm, native) rangeEquals fun rangeEquals(offset: Long , bytes: ByteString ): Boolean fun rangeEquals(offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean read (jvm) fun read(sink: ByteBuffer ): Int (js, jvm, native) fun read(sink: ByteArray ): Int (js, jvm, native) fun read(sink: ByteArray , offset: Int , byteCount: Int ): Int (js, jvm, native) fun read(sink: Buffer , byteCount: Long ): Long (js, jvm, native) readAll fun readAll(sink: Sink ): Long (jvm) readAndWriteUnsafe fun readAndWriteUnsafe(unsafeCursor: Buffer.UnsafeCursor = UnsafeCursor()): Buffer.UnsafeCursor (js, jvm, native) readByte fun readByte(): Byte (js, jvm, native) readByteArray fun readByteArray(): ByteArray fun readByteArray(byteCount: Long ): ByteArray (js, jvm, native) readByteString fun readByteString(): ByteString fun readByteString(byteCount: Long ): ByteString (js, jvm, native) readDecimalLong fun readDecimalLong(): Long (jvm) readFrom Read and exhaust bytes from input into this. fun readFrom(input: InputStream ): Buffer Read byteCount bytes from input into this. fun readFrom(input: InputStream , byteCount: Long ): Buffer (js, jvm, native) readFully fun readFully(sink: Buffer , byteCount: Long ): Unit fun readFully(sink: ByteArray ): Unit (js, jvm, native) readHexadecimalUnsignedLong fun readHexadecimalUnsignedLong(): Long (js, jvm, native) readInt fun readInt(): Int (js, jvm, native) readIntLe fun readIntLe(): Int (js, jvm, native) readLong fun readLong(): Long (js, jvm, native) readLongLe fun readLongLe(): Long (js, jvm, native) readShort fun readShort(): Short (js, jvm, native) readShortLe fun readShortLe(): Short (jvm) readString Removes all bytes from this, decodes them as charset , and returns the string. fun readString(charset: Charset ): String Removes byteCount bytes from this, decodes them as charset , and returns the string. fun readString(byteCount: Long , charset: Charset ): String (jvm) readUnsafe fun readUnsafe(unsafeCursor: Buffer.UnsafeCursor = UnsafeCursor()): Buffer.UnsafeCursor (js, jvm, native) readUtf8 fun readUtf8(): String fun readUtf8(byteCount: Long ): String (js, jvm, native) readUtf8CodePoint fun readUtf8CodePoint(): Int (js, jvm, native) readUtf8Line fun readUtf8Line(): String ? (js, jvm, native) readUtf8LineStrict fun readUtf8LineStrict(): String fun readUtf8LineStrict(limit: Long ): String (js, jvm, native) request fun request(byteCount: Long ): Boolean (js, jvm, native) require fun require(byteCount: Long ): Unit select (native) fun select(options: <ERROR CLASS>): Int (js, jvm) fun select(options: Options ): Int (jvm) sha1 Returns the 160-bit SHA-1 hash of this buffer. fun sha1(): ByteString (jvm) sha256 Returns the 256-bit SHA-256 hash of this buffer. fun sha256(): ByteString (jvm) sha512 Returns the 512-bit SHA-512 hash of this buffer. fun sha512(): ByteString (jvm) size fun ~~size~~(): Long (js, jvm, native) skip Discards byteCount bytes from the head of this buffer. fun skip(byteCount: Long ): Unit (js, jvm, native) snapshot Returns an immutable copy of this buffer as a byte string. fun snapshot(): ByteString Returns an immutable copy of the first byteCount bytes of this buffer as a byte string. fun snapshot(byteCount: Int ): ByteString (js, jvm, native) timeout fun timeout(): Timeout toString Returns a human-readable string that describes the contents of this buffer. Typically this is a string like [text=Hello] or [hex=0000ffff] .(js, jvm) fun toString(): String (native) fun toString(): <ERROR CLASS> write (jvm) fun write(source: ByteBuffer ): Int (js, jvm, native) fun write(byteString: ByteString ): Buffer (js, jvm) fun write(byteString: ByteString , offset: Int , byteCount: Int ): Buffer (native) fun write(byteString: ByteString , offset: Int , byteCount: Int ): <ERROR CLASS> (js, jvm, native) fun write(source: ByteArray ): Buffer (js, jvm, native) fun write(source: ByteArray , offset: Int , byteCount: Int ): Buffer (js, jvm, native) fun write(source: Source , byteCount: Long ): Buffer (js, jvm, native) fun write(source: Buffer , byteCount: Long ): Unit (js, jvm, native) writeAll fun writeAll(source: Source ): Long (js, jvm, native) writeByte fun writeByte(b: Int ): Buffer (js, jvm, native) writeDecimalLong fun writeDecimalLong(v: Long ): Buffer (js, jvm, native) writeHexadecimalUnsignedLong fun writeHexadecimalUnsignedLong(v: Long ): Buffer (js, jvm, native) writeInt fun writeInt(i: Int ): Buffer (js, jvm, native) writeIntLe fun writeIntLe(i: Int ): Buffer (js, jvm, native) writeLong fun writeLong(v: Long ): Buffer (js, jvm, native) writeLongLe fun writeLongLe(v: Long ): Buffer (js, jvm, native) writeShort fun writeShort(s: Int ): Buffer (js, jvm, native) writeShortLe fun writeShortLe(s: Int ): Buffer (jvm) writeString fun writeString(string: String , charset: Charset ): Buffer fun writeString(string: String , beginIndex: Int , endIndex: Int , charset: Charset ): Buffer (jvm) writeTo Write byteCount bytes from this to out . fun writeTo(out: OutputStream , byteCount: Long = size): Buffer (js, jvm, native) writeUtf8 fun writeUtf8(string: String ): Buffer fun writeUtf8(string: String , beginIndex: Int , endIndex: Int ): Buffer (js, jvm, native) writeUtf8CodePoint fun writeUtf8CodePoint(codePoint: Int ): Buffer","title":"Functions"},{"location":"2.x/okio/okio/-buffer/#inherited-functions","text":"Name Summary (jvm) buffer Returns this source\u2019s internal buffer. abstract fun ~~buffer~~(): Buffer (jvm) inputStream Returns an input stream that reads from this source. abstract fun inputStream(): InputStream (jvm) outputStream Returns an output stream that writes to this sink. abstract fun outputStream(): OutputStream (jvm) readString Removes all bytes from this, decodes them as charset , and returns the string. abstract fun readString(charset: Charset ): String Removes byteCount bytes from this, decodes them as charset , and returns the string. abstract fun readString(byteCount: Long , charset: Charset ): String (jvm) writeString abstract fun writeString(string: String , charset: Charset ): BufferedSink abstract fun writeString(string: String , beginIndex: Int , endIndex: Int , charset: Charset ): BufferedSink","title":"Inherited Functions"},{"location":"2.x/okio/okio/-buffer/#extension-functions","text":"Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"Extension Functions"},{"location":"2.x/okio/okio/-buffer/-init-/","text":"okio / okio / Buffer / <init> <init> \u00b6 (js, jvm, native) <init>() A collection of bytes in memory. Moving data from one buffer to another is fast. Instead of copying bytes from one place in memory to another, this class just changes ownership of the underlying byte arrays. This buffer grows with your data. Just like ArrayList, each buffer starts small. It consumes only the memory it needs to. This buffer pools its byte arrays. When you allocate a byte array in Java, the runtime must zero-fill the requested array before returning it to you. Even if you\u2019re going to write over that space anyway. This class avoids zero-fill and GC churn by pooling byte arrays.","title":" init "},{"location":"2.x/okio/okio/-buffer/-init-/#init","text":"(js, jvm, native) <init>() A collection of bytes in memory. Moving data from one buffer to another is fast. Instead of copying bytes from one place in memory to another, this class just changes ownership of the underlying byte arrays. This buffer grows with your data. Just like ArrayList, each buffer starts small. It consumes only the memory it needs to. This buffer pools its byte arrays. When you allocate a byte array in Java, the runtime must zero-fill the requested array before returning it to you. Even if you\u2019re going to write over that space anyway. This class avoids zero-fill and GC churn by pooling byte arrays.","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-buffer/buffer/","text":"okio / okio / Buffer / buffer buffer \u00b6 (js, jvm, native) val buffer: Buffer (jvm) fun buffer(): Buffer Overrides BufferedSource.buffer Overrides BufferedSink.buffer Returns this source\u2019s internal buffer.","title":"buffer - Okio"},{"location":"2.x/okio/okio/-buffer/buffer/#buffer","text":"(js, jvm, native) val buffer: Buffer (jvm) fun buffer(): Buffer Overrides BufferedSource.buffer Overrides BufferedSink.buffer Returns this source\u2019s internal buffer.","title":"buffer"},{"location":"2.x/okio/okio/-buffer/clear/","text":"okio / okio / Buffer / clear clear \u00b6 (js, jvm, native) fun clear(): Unit Discards all bytes in this buffer. Calling this method when you\u2019re done with a buffer will return its segments to the pool.","title":"clear - Okio"},{"location":"2.x/okio/okio/-buffer/clear/#clear","text":"(js, jvm, native) fun clear(): Unit Discards all bytes in this buffer. Calling this method when you\u2019re done with a buffer will return its segments to the pool.","title":"clear"},{"location":"2.x/okio/okio/-buffer/clone/","text":"okio / okio / Buffer / clone clone \u00b6 (jvm) fun clone(): Buffer Returns a deep copy of this buffer.","title":"clone - Okio"},{"location":"2.x/okio/okio/-buffer/clone/#clone","text":"(jvm) fun clone(): Buffer Returns a deep copy of this buffer.","title":"clone"},{"location":"2.x/okio/okio/-buffer/close/","text":"okio / okio / Buffer / close close \u00b6 (js, jvm, native) fun close(): Unit","title":"close - Okio"},{"location":"2.x/okio/okio/-buffer/close/#close","text":"(js, jvm, native) fun close(): Unit","title":"close"},{"location":"2.x/okio/okio/-buffer/complete-segment-byte-count/","text":"okio / okio / Buffer / completeSegmentByteCount completeSegmentByteCount \u00b6 (js, jvm, native) fun completeSegmentByteCount(): Long Returns the number of bytes in segments that are not writable. This is the number of bytes that can be flushed immediately to an underlying sink without harming throughput.","title":"completeSegmentByteCount - Okio"},{"location":"2.x/okio/okio/-buffer/complete-segment-byte-count/#completesegmentbytecount","text":"(js, jvm, native) fun completeSegmentByteCount(): Long Returns the number of bytes in segments that are not writable. This is the number of bytes that can be flushed immediately to an underlying sink without harming throughput.","title":"completeSegmentByteCount"},{"location":"2.x/okio/okio/-buffer/copy-to/","text":"okio / okio / Buffer / copyTo copyTo \u00b6 (js, jvm) fun copyTo(out: Buffer , offset: Long = 0L, byteCount: Long ): Buffer (native) fun copyTo(out: Buffer , offset: Long , byteCount: Long ): Buffer Copy byteCount bytes from this, starting at offset , to out . (js, jvm) fun copyTo(out: Buffer , offset: Long = 0L): Buffer (native) fun copyTo(out: Buffer , offset: Long ): Buffer Overload of copyTo with byteCount = size - offset, work around for https://youtrack.jetbrains.com/issue/KT-30847 (jvm) @JvmOverloads fun copyTo(out: OutputStream , offset: Long = 0L, byteCount: Long = size - offset): Buffer Copy byteCount bytes from this, starting at offset , to out .","title":"copyTo - Okio"},{"location":"2.x/okio/okio/-buffer/copy-to/#copyto","text":"(js, jvm) fun copyTo(out: Buffer , offset: Long = 0L, byteCount: Long ): Buffer (native) fun copyTo(out: Buffer , offset: Long , byteCount: Long ): Buffer Copy byteCount bytes from this, starting at offset , to out . (js, jvm) fun copyTo(out: Buffer , offset: Long = 0L): Buffer (native) fun copyTo(out: Buffer , offset: Long ): Buffer Overload of copyTo with byteCount = size - offset, work around for https://youtrack.jetbrains.com/issue/KT-30847 (jvm) @JvmOverloads fun copyTo(out: OutputStream , offset: Long = 0L, byteCount: Long = size - offset): Buffer Copy byteCount bytes from this, starting at offset , to out .","title":"copyTo"},{"location":"2.x/okio/okio/-buffer/copy/","text":"okio / okio / Buffer / copy copy \u00b6 (js, jvm, native) fun copy(): Buffer Returns a deep copy of this buffer.","title":"copy - Okio"},{"location":"2.x/okio/okio/-buffer/copy/#copy","text":"(js, jvm, native) fun copy(): Buffer Returns a deep copy of this buffer.","title":"copy"},{"location":"2.x/okio/okio/-buffer/emit-complete-segments/","text":"okio / okio / Buffer / emitCompleteSegments emitCompleteSegments \u00b6 (js, jvm, native) fun emitCompleteSegments(): Buffer","title":"emitCompleteSegments - Okio"},{"location":"2.x/okio/okio/-buffer/emit-complete-segments/#emitcompletesegments","text":"(js, jvm, native) fun emitCompleteSegments(): Buffer","title":"emitCompleteSegments"},{"location":"2.x/okio/okio/-buffer/emit/","text":"okio / okio / Buffer / emit emit \u00b6 (js, jvm, native) fun emit(): Buffer","title":"emit - Okio"},{"location":"2.x/okio/okio/-buffer/emit/#emit","text":"(js, jvm, native) fun emit(): Buffer","title":"emit"},{"location":"2.x/okio/okio/-buffer/equals/","text":"okio / okio / Buffer / equals equals \u00b6 (js, jvm, native) fun equals(other: Any ?): Boolean","title":"equals - Okio"},{"location":"2.x/okio/okio/-buffer/equals/#equals","text":"(js, jvm, native) fun equals(other: Any ?): Boolean","title":"equals"},{"location":"2.x/okio/okio/-buffer/exhausted/","text":"okio / okio / Buffer / exhausted exhausted \u00b6 (js, jvm, native) fun exhausted(): Boolean","title":"exhausted - Okio"},{"location":"2.x/okio/okio/-buffer/exhausted/#exhausted","text":"(js, jvm, native) fun exhausted(): Boolean","title":"exhausted"},{"location":"2.x/okio/okio/-buffer/flush/","text":"okio / okio / Buffer / flush flush \u00b6 (js, jvm, native) fun flush(): Unit","title":"flush - Okio"},{"location":"2.x/okio/okio/-buffer/flush/#flush","text":"(js, jvm, native) fun flush(): Unit","title":"flush"},{"location":"2.x/okio/okio/-buffer/get-byte/","text":"okio / okio / Buffer / getByte getByte \u00b6 (jvm) @JvmName(\"-deprecated_getByte\") fun ~~getByte~~(index: Long ): Byte Deprecated: moved to operator function","title":"getByte - Okio"},{"location":"2.x/okio/okio/-buffer/get-byte/#getbyte","text":"(jvm) @JvmName(\"-deprecated_getByte\") fun ~~getByte~~(index: Long ): Byte Deprecated: moved to operator function","title":"getByte"},{"location":"2.x/okio/okio/-buffer/get/","text":"okio / okio / Buffer / get get \u00b6 (js, jvm, native) operator fun get(pos: Long ): Byte Returns the byte at pos .","title":"get - Okio"},{"location":"2.x/okio/okio/-buffer/get/#get","text":"(js, jvm, native) operator fun get(pos: Long ): Byte Returns the byte at pos .","title":"get"},{"location":"2.x/okio/okio/-buffer/hash-code/","text":"okio / okio / Buffer / hashCode hashCode \u00b6 (js, jvm, native) fun hashCode(): Int","title":"hashCode - Okio"},{"location":"2.x/okio/okio/-buffer/hash-code/#hashcode","text":"(js, jvm, native) fun hashCode(): Int","title":"hashCode"},{"location":"2.x/okio/okio/-buffer/hmac-sha1/","text":"okio / okio / Buffer / hmacSha1 hmacSha1 \u00b6 (jvm) fun hmacSha1(key: ByteString ): ByteString Returns the 160-bit SHA-1 HMAC of this buffer.","title":"hmacSha1 - Okio"},{"location":"2.x/okio/okio/-buffer/hmac-sha1/#hmacsha1","text":"(jvm) fun hmacSha1(key: ByteString ): ByteString Returns the 160-bit SHA-1 HMAC of this buffer.","title":"hmacSha1"},{"location":"2.x/okio/okio/-buffer/hmac-sha256/","text":"okio / okio / Buffer / hmacSha256 hmacSha256 \u00b6 (jvm) fun hmacSha256(key: ByteString ): ByteString Returns the 256-bit SHA-256 HMAC of this buffer.","title":"hmacSha256 - Okio"},{"location":"2.x/okio/okio/-buffer/hmac-sha256/#hmacsha256","text":"(jvm) fun hmacSha256(key: ByteString ): ByteString Returns the 256-bit SHA-256 HMAC of this buffer.","title":"hmacSha256"},{"location":"2.x/okio/okio/-buffer/hmac-sha512/","text":"okio / okio / Buffer / hmacSha512 hmacSha512 \u00b6 (jvm) fun hmacSha512(key: ByteString ): ByteString Returns the 512-bit SHA-512 HMAC of this buffer.","title":"hmacSha512 - Okio"},{"location":"2.x/okio/okio/-buffer/hmac-sha512/#hmacsha512","text":"(jvm) fun hmacSha512(key: ByteString ): ByteString Returns the 512-bit SHA-512 HMAC of this buffer.","title":"hmacSha512"},{"location":"2.x/okio/okio/-buffer/index-of-element/","text":"okio / okio / Buffer / indexOfElement indexOfElement \u00b6 (js, jvm, native) fun indexOfElement(targetBytes: ByteString ): Long fun indexOfElement(targetBytes: ByteString , fromIndex: Long ): Long","title":"indexOfElement - Okio"},{"location":"2.x/okio/okio/-buffer/index-of-element/#indexofelement","text":"(js, jvm, native) fun indexOfElement(targetBytes: ByteString ): Long fun indexOfElement(targetBytes: ByteString , fromIndex: Long ): Long","title":"indexOfElement"},{"location":"2.x/okio/okio/-buffer/index-of/","text":"okio / okio / Buffer / indexOf indexOf \u00b6 (js, jvm, native) fun indexOf(b: Byte ): Long fun indexOf(b: Byte , fromIndex: Long , toIndex: Long ): Long fun indexOf(bytes: ByteString ): Long fun indexOf(bytes: ByteString , fromIndex: Long ): Long (js, jvm, native) fun indexOf(b: Byte , fromIndex: Long ): Long Returns the index of b in this at or beyond fromIndex , or -1 if this buffer does not contain b in that range.","title":"indexOf - Okio"},{"location":"2.x/okio/okio/-buffer/index-of/#indexof","text":"(js, jvm, native) fun indexOf(b: Byte ): Long fun indexOf(b: Byte , fromIndex: Long , toIndex: Long ): Long fun indexOf(bytes: ByteString ): Long fun indexOf(bytes: ByteString , fromIndex: Long ): Long (js, jvm, native) fun indexOf(b: Byte , fromIndex: Long ): Long Returns the index of b in this at or beyond fromIndex , or -1 if this buffer does not contain b in that range.","title":"indexOf"},{"location":"2.x/okio/okio/-buffer/input-stream/","text":"okio / okio / Buffer / inputStream inputStream \u00b6 (jvm) fun inputStream(): InputStream Overrides BufferedSource.inputStream Returns an input stream that reads from this source.","title":"inputStream - Okio"},{"location":"2.x/okio/okio/-buffer/input-stream/#inputstream","text":"(jvm) fun inputStream(): InputStream Overrides BufferedSource.inputStream Returns an input stream that reads from this source.","title":"inputStream"},{"location":"2.x/okio/okio/-buffer/is-open/","text":"okio / okio / Buffer / isOpen isOpen \u00b6 (jvm) fun isOpen(): Boolean","title":"isOpen - Okio"},{"location":"2.x/okio/okio/-buffer/is-open/#isopen","text":"(jvm) fun isOpen(): Boolean","title":"isOpen"},{"location":"2.x/okio/okio/-buffer/md5/","text":"okio / okio / Buffer / md5 md5 \u00b6 (jvm) fun md5(): ByteString Returns the 128-bit MD5 hash of this buffer.","title":"md5 - Okio"},{"location":"2.x/okio/okio/-buffer/md5/#md5","text":"(jvm) fun md5(): ByteString Returns the 128-bit MD5 hash of this buffer.","title":"md5"},{"location":"2.x/okio/okio/-buffer/output-stream/","text":"okio / okio / Buffer / outputStream outputStream \u00b6 (jvm) fun outputStream(): OutputStream Overrides BufferedSink.outputStream Returns an output stream that writes to this sink.","title":"outputStream - Okio"},{"location":"2.x/okio/okio/-buffer/output-stream/#outputstream","text":"(jvm) fun outputStream(): OutputStream Overrides BufferedSink.outputStream Returns an output stream that writes to this sink.","title":"outputStream"},{"location":"2.x/okio/okio/-buffer/peek/","text":"okio / okio / Buffer / peek peek \u00b6 (js, jvm, native) fun peek(): BufferedSource","title":"peek - Okio"},{"location":"2.x/okio/okio/-buffer/peek/#peek","text":"(js, jvm, native) fun peek(): BufferedSource","title":"peek"},{"location":"2.x/okio/okio/-buffer/range-equals/","text":"okio / okio / Buffer / rangeEquals rangeEquals \u00b6 (js, jvm, native) fun rangeEquals(offset: Long , bytes: ByteString ): Boolean fun rangeEquals(offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean","title":"rangeEquals - Okio"},{"location":"2.x/okio/okio/-buffer/range-equals/#rangeequals","text":"(js, jvm, native) fun rangeEquals(offset: Long , bytes: ByteString ): Boolean fun rangeEquals(offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean","title":"rangeEquals"},{"location":"2.x/okio/okio/-buffer/read-all/","text":"okio / okio / Buffer / readAll readAll \u00b6 (js, jvm, native) fun readAll(sink: Sink ): Long","title":"readAll - Okio"},{"location":"2.x/okio/okio/-buffer/read-all/#readall","text":"(js, jvm, native) fun readAll(sink: Sink ): Long","title":"readAll"},{"location":"2.x/okio/okio/-buffer/read-and-write-unsafe/","text":"okio / okio / Buffer / readAndWriteUnsafe readAndWriteUnsafe \u00b6 (jvm) @JvmOverloads fun readAndWriteUnsafe(unsafeCursor: Buffer.UnsafeCursor = UnsafeCursor()): Buffer.UnsafeCursor","title":"readAndWriteUnsafe - Okio"},{"location":"2.x/okio/okio/-buffer/read-and-write-unsafe/#readandwriteunsafe","text":"(jvm) @JvmOverloads fun readAndWriteUnsafe(unsafeCursor: Buffer.UnsafeCursor = UnsafeCursor()): Buffer.UnsafeCursor","title":"readAndWriteUnsafe"},{"location":"2.x/okio/okio/-buffer/read-byte-array/","text":"okio / okio / Buffer / readByteArray readByteArray \u00b6 (js, jvm, native) fun readByteArray(): ByteArray fun readByteArray(byteCount: Long ): ByteArray","title":"readByteArray - Okio"},{"location":"2.x/okio/okio/-buffer/read-byte-array/#readbytearray","text":"(js, jvm, native) fun readByteArray(): ByteArray fun readByteArray(byteCount: Long ): ByteArray","title":"readByteArray"},{"location":"2.x/okio/okio/-buffer/read-byte-string/","text":"okio / okio / Buffer / readByteString readByteString \u00b6 (js, jvm, native) fun readByteString(): ByteString fun readByteString(byteCount: Long ): ByteString","title":"readByteString - Okio"},{"location":"2.x/okio/okio/-buffer/read-byte-string/#readbytestring","text":"(js, jvm, native) fun readByteString(): ByteString fun readByteString(byteCount: Long ): ByteString","title":"readByteString"},{"location":"2.x/okio/okio/-buffer/read-byte/","text":"okio / okio / Buffer / readByte readByte \u00b6 (js, jvm, native) fun readByte(): Byte","title":"readByte - Okio"},{"location":"2.x/okio/okio/-buffer/read-byte/#readbyte","text":"(js, jvm, native) fun readByte(): Byte","title":"readByte"},{"location":"2.x/okio/okio/-buffer/read-decimal-long/","text":"okio / okio / Buffer / readDecimalLong readDecimalLong \u00b6 (js, jvm, native) fun readDecimalLong(): Long","title":"readDecimalLong - Okio"},{"location":"2.x/okio/okio/-buffer/read-decimal-long/#readdecimallong","text":"(js, jvm, native) fun readDecimalLong(): Long","title":"readDecimalLong"},{"location":"2.x/okio/okio/-buffer/read-from/","text":"okio / okio / Buffer / readFrom readFrom \u00b6 (jvm) fun readFrom(input: InputStream ): Buffer Read and exhaust bytes from input into this. (jvm) fun readFrom(input: InputStream , byteCount: Long ): Buffer Read byteCount bytes from input into this.","title":"readFrom - Okio"},{"location":"2.x/okio/okio/-buffer/read-from/#readfrom","text":"(jvm) fun readFrom(input: InputStream ): Buffer Read and exhaust bytes from input into this. (jvm) fun readFrom(input: InputStream , byteCount: Long ): Buffer Read byteCount bytes from input into this.","title":"readFrom"},{"location":"2.x/okio/okio/-buffer/read-fully/","text":"okio / okio / Buffer / readFully readFully \u00b6 (js, jvm, native) fun readFully(sink: Buffer , byteCount: Long ): Unit fun readFully(sink: ByteArray ): Unit","title":"readFully - Okio"},{"location":"2.x/okio/okio/-buffer/read-fully/#readfully","text":"(js, jvm, native) fun readFully(sink: Buffer , byteCount: Long ): Unit fun readFully(sink: ByteArray ): Unit","title":"readFully"},{"location":"2.x/okio/okio/-buffer/read-hexadecimal-unsigned-long/","text":"okio / okio / Buffer / readHexadecimalUnsignedLong readHexadecimalUnsignedLong \u00b6 (js, jvm, native) fun readHexadecimalUnsignedLong(): Long","title":"readHexadecimalUnsignedLong - Okio"},{"location":"2.x/okio/okio/-buffer/read-hexadecimal-unsigned-long/#readhexadecimalunsignedlong","text":"(js, jvm, native) fun readHexadecimalUnsignedLong(): Long","title":"readHexadecimalUnsignedLong"},{"location":"2.x/okio/okio/-buffer/read-int-le/","text":"okio / okio / Buffer / readIntLe readIntLe \u00b6 (js, jvm, native) fun readIntLe(): Int","title":"readIntLe - Okio"},{"location":"2.x/okio/okio/-buffer/read-int-le/#readintle","text":"(js, jvm, native) fun readIntLe(): Int","title":"readIntLe"},{"location":"2.x/okio/okio/-buffer/read-int/","text":"okio / okio / Buffer / readInt readInt \u00b6 (js, jvm, native) fun readInt(): Int","title":"readInt - Okio"},{"location":"2.x/okio/okio/-buffer/read-int/#readint","text":"(js, jvm, native) fun readInt(): Int","title":"readInt"},{"location":"2.x/okio/okio/-buffer/read-long-le/","text":"okio / okio / Buffer / readLongLe readLongLe \u00b6 (js, jvm, native) fun readLongLe(): Long","title":"readLongLe - Okio"},{"location":"2.x/okio/okio/-buffer/read-long-le/#readlongle","text":"(js, jvm, native) fun readLongLe(): Long","title":"readLongLe"},{"location":"2.x/okio/okio/-buffer/read-long/","text":"okio / okio / Buffer / readLong readLong \u00b6 (js, jvm, native) fun readLong(): Long","title":"readLong - Okio"},{"location":"2.x/okio/okio/-buffer/read-long/#readlong","text":"(js, jvm, native) fun readLong(): Long","title":"readLong"},{"location":"2.x/okio/okio/-buffer/read-short-le/","text":"okio / okio / Buffer / readShortLe readShortLe \u00b6 (js, jvm, native) fun readShortLe(): Short","title":"readShortLe - Okio"},{"location":"2.x/okio/okio/-buffer/read-short-le/#readshortle","text":"(js, jvm, native) fun readShortLe(): Short","title":"readShortLe"},{"location":"2.x/okio/okio/-buffer/read-short/","text":"okio / okio / Buffer / readShort readShort \u00b6 (js, jvm, native) fun readShort(): Short","title":"readShort - Okio"},{"location":"2.x/okio/okio/-buffer/read-short/#readshort","text":"(js, jvm, native) fun readShort(): Short","title":"readShort"},{"location":"2.x/okio/okio/-buffer/read-string/","text":"okio / okio / Buffer / readString readString \u00b6 (jvm) fun readString(charset: Charset ): String Overrides BufferedSource.readString Removes all bytes from this, decodes them as charset , and returns the string. (jvm) fun readString(byteCount: Long , charset: Charset ): String Overrides BufferedSource.readString Removes byteCount bytes from this, decodes them as charset , and returns the string.","title":"readString - Okio"},{"location":"2.x/okio/okio/-buffer/read-string/#readstring","text":"(jvm) fun readString(charset: Charset ): String Overrides BufferedSource.readString Removes all bytes from this, decodes them as charset , and returns the string. (jvm) fun readString(byteCount: Long , charset: Charset ): String Overrides BufferedSource.readString Removes byteCount bytes from this, decodes them as charset , and returns the string.","title":"readString"},{"location":"2.x/okio/okio/-buffer/read-unsafe/","text":"okio / okio / Buffer / readUnsafe readUnsafe \u00b6 (jvm) @JvmOverloads fun readUnsafe(unsafeCursor: Buffer.UnsafeCursor = UnsafeCursor()): Buffer.UnsafeCursor","title":"readUnsafe - Okio"},{"location":"2.x/okio/okio/-buffer/read-unsafe/#readunsafe","text":"(jvm) @JvmOverloads fun readUnsafe(unsafeCursor: Buffer.UnsafeCursor = UnsafeCursor()): Buffer.UnsafeCursor","title":"readUnsafe"},{"location":"2.x/okio/okio/-buffer/read-utf8-code-point/","text":"okio / okio / Buffer / readUtf8CodePoint readUtf8CodePoint \u00b6 (js, jvm, native) fun readUtf8CodePoint(): Int","title":"readUtf8CodePoint - Okio"},{"location":"2.x/okio/okio/-buffer/read-utf8-code-point/#readutf8codepoint","text":"(js, jvm, native) fun readUtf8CodePoint(): Int","title":"readUtf8CodePoint"},{"location":"2.x/okio/okio/-buffer/read-utf8-line-strict/","text":"okio / okio / Buffer / readUtf8LineStrict readUtf8LineStrict \u00b6 (js, jvm, native) fun readUtf8LineStrict(): String fun readUtf8LineStrict(limit: Long ): String","title":"readUtf8LineStrict - Okio"},{"location":"2.x/okio/okio/-buffer/read-utf8-line-strict/#readutf8linestrict","text":"(js, jvm, native) fun readUtf8LineStrict(): String fun readUtf8LineStrict(limit: Long ): String","title":"readUtf8LineStrict"},{"location":"2.x/okio/okio/-buffer/read-utf8-line/","text":"okio / okio / Buffer / readUtf8Line readUtf8Line \u00b6 (js, jvm, native) fun readUtf8Line(): String ?","title":"readUtf8Line - Okio"},{"location":"2.x/okio/okio/-buffer/read-utf8-line/#readutf8line","text":"(js, jvm, native) fun readUtf8Line(): String ?","title":"readUtf8Line"},{"location":"2.x/okio/okio/-buffer/read-utf8/","text":"okio / okio / Buffer / readUtf8 readUtf8 \u00b6 (js, jvm, native) fun readUtf8(): String fun readUtf8(byteCount: Long ): String","title":"readUtf8 - Okio"},{"location":"2.x/okio/okio/-buffer/read-utf8/#readutf8","text":"(js, jvm, native) fun readUtf8(): String fun readUtf8(byteCount: Long ): String","title":"readUtf8"},{"location":"2.x/okio/okio/-buffer/read/","text":"okio / okio / Buffer / read read \u00b6 (js, jvm, native) fun read(sink: ByteArray ): Int fun read(sink: ByteArray , offset: Int , byteCount: Int ): Int fun read(sink: Buffer , byteCount: Long ): Long (jvm) fun read(sink: ByteBuffer ): Int","title":"read - Okio"},{"location":"2.x/okio/okio/-buffer/read/#read","text":"(js, jvm, native) fun read(sink: ByteArray ): Int fun read(sink: ByteArray , offset: Int , byteCount: Int ): Int fun read(sink: Buffer , byteCount: Long ): Long (jvm) fun read(sink: ByteBuffer ): Int","title":"read"},{"location":"2.x/okio/okio/-buffer/request/","text":"okio / okio / Buffer / request request \u00b6 (js, jvm, native) fun request(byteCount: Long ): Boolean","title":"request - Okio"},{"location":"2.x/okio/okio/-buffer/request/#request","text":"(js, jvm, native) fun request(byteCount: Long ): Boolean","title":"request"},{"location":"2.x/okio/okio/-buffer/require/","text":"okio / okio / Buffer / require require \u00b6 (js, jvm, native) fun require(byteCount: Long ): Unit","title":"require - Okio"},{"location":"2.x/okio/okio/-buffer/require/#require","text":"(js, jvm, native) fun require(byteCount: Long ): Unit","title":"require"},{"location":"2.x/okio/okio/-buffer/select/","text":"okio / okio / Buffer / select select \u00b6 (js, jvm) fun select(options: Options ): Int (native) fun select(options: <ERROR CLASS>): Int Overrides BufferedSource.select","title":"select - Okio"},{"location":"2.x/okio/okio/-buffer/select/#select","text":"(js, jvm) fun select(options: Options ): Int (native) fun select(options: <ERROR CLASS>): Int Overrides BufferedSource.select","title":"select"},{"location":"2.x/okio/okio/-buffer/sha1/","text":"okio / okio / Buffer / sha1 sha1 \u00b6 (jvm) fun sha1(): ByteString Returns the 160-bit SHA-1 hash of this buffer.","title":"sha1 - Okio"},{"location":"2.x/okio/okio/-buffer/sha1/#sha1","text":"(jvm) fun sha1(): ByteString Returns the 160-bit SHA-1 hash of this buffer.","title":"sha1"},{"location":"2.x/okio/okio/-buffer/sha256/","text":"okio / okio / Buffer / sha256 sha256 \u00b6 (jvm) fun sha256(): ByteString Returns the 256-bit SHA-256 hash of this buffer.","title":"sha256 - Okio"},{"location":"2.x/okio/okio/-buffer/sha256/#sha256","text":"(jvm) fun sha256(): ByteString Returns the 256-bit SHA-256 hash of this buffer.","title":"sha256"},{"location":"2.x/okio/okio/-buffer/sha512/","text":"okio / okio / Buffer / sha512 sha512 \u00b6 (jvm) fun sha512(): ByteString Returns the 512-bit SHA-512 hash of this buffer.","title":"sha512 - Okio"},{"location":"2.x/okio/okio/-buffer/sha512/#sha512","text":"(jvm) fun sha512(): ByteString Returns the 512-bit SHA-512 hash of this buffer.","title":"sha512"},{"location":"2.x/okio/okio/-buffer/size/","text":"okio / okio / Buffer / size size \u00b6 (js, jvm, native) var size: Long (jvm) @JvmName(\"-deprecated_size\") fun ~~size~~(): Long Deprecated: moved to val","title":"size - Okio"},{"location":"2.x/okio/okio/-buffer/size/#size","text":"(js, jvm, native) var size: Long (jvm) @JvmName(\"-deprecated_size\") fun ~~size~~(): Long Deprecated: moved to val","title":"size"},{"location":"2.x/okio/okio/-buffer/skip/","text":"okio / okio / Buffer / skip skip \u00b6 (js, jvm, native) fun skip(byteCount: Long ): Unit Discards byteCount bytes from the head of this buffer.","title":"skip - Okio"},{"location":"2.x/okio/okio/-buffer/skip/#skip","text":"(js, jvm, native) fun skip(byteCount: Long ): Unit Discards byteCount bytes from the head of this buffer.","title":"skip"},{"location":"2.x/okio/okio/-buffer/snapshot/","text":"okio / okio / Buffer / snapshot snapshot \u00b6 (js, jvm, native) fun snapshot(): ByteString Returns an immutable copy of this buffer as a byte string. (js, jvm, native) fun snapshot(byteCount: Int ): ByteString Returns an immutable copy of the first byteCount bytes of this buffer as a byte string.","title":"snapshot - Okio"},{"location":"2.x/okio/okio/-buffer/snapshot/#snapshot","text":"(js, jvm, native) fun snapshot(): ByteString Returns an immutable copy of this buffer as a byte string. (js, jvm, native) fun snapshot(byteCount: Int ): ByteString Returns an immutable copy of the first byteCount bytes of this buffer as a byte string.","title":"snapshot"},{"location":"2.x/okio/okio/-buffer/timeout/","text":"okio / okio / Buffer / timeout timeout \u00b6 (js, jvm, native) fun timeout(): Timeout","title":"timeout - Okio"},{"location":"2.x/okio/okio/-buffer/timeout/#timeout","text":"(js, jvm, native) fun timeout(): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-buffer/to-string/","text":"okio / okio / Buffer / toString toString \u00b6 (js, jvm) fun toString(): String (native) fun toString(): <ERROR CLASS> Returns a human-readable string that describes the contents of this buffer. Typically this is a string like [text=Hello] or [hex=0000ffff] .","title":"toString - Okio"},{"location":"2.x/okio/okio/-buffer/to-string/#tostring","text":"(js, jvm) fun toString(): String (native) fun toString(): <ERROR CLASS> Returns a human-readable string that describes the contents of this buffer. Typically this is a string like [text=Hello] or [hex=0000ffff] .","title":"toString"},{"location":"2.x/okio/okio/-buffer/write-all/","text":"okio / okio / Buffer / writeAll writeAll \u00b6 (js, jvm, native) fun writeAll(source: Source ): Long","title":"writeAll - Okio"},{"location":"2.x/okio/okio/-buffer/write-all/#writeall","text":"(js, jvm, native) fun writeAll(source: Source ): Long","title":"writeAll"},{"location":"2.x/okio/okio/-buffer/write-byte/","text":"okio / okio / Buffer / writeByte writeByte \u00b6 (js, jvm, native) fun writeByte(b: Int ): Buffer","title":"writeByte - Okio"},{"location":"2.x/okio/okio/-buffer/write-byte/#writebyte","text":"(js, jvm, native) fun writeByte(b: Int ): Buffer","title":"writeByte"},{"location":"2.x/okio/okio/-buffer/write-decimal-long/","text":"okio / okio / Buffer / writeDecimalLong writeDecimalLong \u00b6 (js, jvm, native) fun writeDecimalLong(v: Long ): Buffer","title":"writeDecimalLong - Okio"},{"location":"2.x/okio/okio/-buffer/write-decimal-long/#writedecimallong","text":"(js, jvm, native) fun writeDecimalLong(v: Long ): Buffer","title":"writeDecimalLong"},{"location":"2.x/okio/okio/-buffer/write-hexadecimal-unsigned-long/","text":"okio / okio / Buffer / writeHexadecimalUnsignedLong writeHexadecimalUnsignedLong \u00b6 (js, jvm, native) fun writeHexadecimalUnsignedLong(v: Long ): Buffer","title":"writeHexadecimalUnsignedLong - Okio"},{"location":"2.x/okio/okio/-buffer/write-hexadecimal-unsigned-long/#writehexadecimalunsignedlong","text":"(js, jvm, native) fun writeHexadecimalUnsignedLong(v: Long ): Buffer","title":"writeHexadecimalUnsignedLong"},{"location":"2.x/okio/okio/-buffer/write-int-le/","text":"okio / okio / Buffer / writeIntLe writeIntLe \u00b6 (js, jvm, native) fun writeIntLe(i: Int ): Buffer","title":"writeIntLe - Okio"},{"location":"2.x/okio/okio/-buffer/write-int-le/#writeintle","text":"(js, jvm, native) fun writeIntLe(i: Int ): Buffer","title":"writeIntLe"},{"location":"2.x/okio/okio/-buffer/write-int/","text":"okio / okio / Buffer / writeInt writeInt \u00b6 (js, jvm, native) fun writeInt(i: Int ): Buffer","title":"writeInt - Okio"},{"location":"2.x/okio/okio/-buffer/write-int/#writeint","text":"(js, jvm, native) fun writeInt(i: Int ): Buffer","title":"writeInt"},{"location":"2.x/okio/okio/-buffer/write-long-le/","text":"okio / okio / Buffer / writeLongLe writeLongLe \u00b6 (js, jvm, native) fun writeLongLe(v: Long ): Buffer","title":"writeLongLe - Okio"},{"location":"2.x/okio/okio/-buffer/write-long-le/#writelongle","text":"(js, jvm, native) fun writeLongLe(v: Long ): Buffer","title":"writeLongLe"},{"location":"2.x/okio/okio/-buffer/write-long/","text":"okio / okio / Buffer / writeLong writeLong \u00b6 (js, jvm, native) fun writeLong(v: Long ): Buffer","title":"writeLong - Okio"},{"location":"2.x/okio/okio/-buffer/write-long/#writelong","text":"(js, jvm, native) fun writeLong(v: Long ): Buffer","title":"writeLong"},{"location":"2.x/okio/okio/-buffer/write-short-le/","text":"okio / okio / Buffer / writeShortLe writeShortLe \u00b6 (js, jvm, native) fun writeShortLe(s: Int ): Buffer","title":"writeShortLe - Okio"},{"location":"2.x/okio/okio/-buffer/write-short-le/#writeshortle","text":"(js, jvm, native) fun writeShortLe(s: Int ): Buffer","title":"writeShortLe"},{"location":"2.x/okio/okio/-buffer/write-short/","text":"okio / okio / Buffer / writeShort writeShort \u00b6 (js, jvm, native) fun writeShort(s: Int ): Buffer","title":"writeShort - Okio"},{"location":"2.x/okio/okio/-buffer/write-short/#writeshort","text":"(js, jvm, native) fun writeShort(s: Int ): Buffer","title":"writeShort"},{"location":"2.x/okio/okio/-buffer/write-string/","text":"okio / okio / Buffer / writeString writeString \u00b6 (jvm) fun writeString(string: String , charset: Charset ): Buffer Overrides BufferedSink.writeString fun writeString(string: String , beginIndex: Int , endIndex: Int , charset: Charset ): Buffer Overrides BufferedSink.writeString","title":"writeString - Okio"},{"location":"2.x/okio/okio/-buffer/write-string/#writestring","text":"(jvm) fun writeString(string: String , charset: Charset ): Buffer Overrides BufferedSink.writeString fun writeString(string: String , beginIndex: Int , endIndex: Int , charset: Charset ): Buffer Overrides BufferedSink.writeString","title":"writeString"},{"location":"2.x/okio/okio/-buffer/write-to/","text":"okio / okio / Buffer / writeTo writeTo \u00b6 (jvm) @JvmOverloads fun writeTo(out: OutputStream , byteCount: Long = size): Buffer Write byteCount bytes from this to out .","title":"writeTo - Okio"},{"location":"2.x/okio/okio/-buffer/write-to/#writeto","text":"(jvm) @JvmOverloads fun writeTo(out: OutputStream , byteCount: Long = size): Buffer Write byteCount bytes from this to out .","title":"writeTo"},{"location":"2.x/okio/okio/-buffer/write-utf8-code-point/","text":"okio / okio / Buffer / writeUtf8CodePoint writeUtf8CodePoint \u00b6 (js, jvm, native) fun writeUtf8CodePoint(codePoint: Int ): Buffer","title":"writeUtf8CodePoint - Okio"},{"location":"2.x/okio/okio/-buffer/write-utf8-code-point/#writeutf8codepoint","text":"(js, jvm, native) fun writeUtf8CodePoint(codePoint: Int ): Buffer","title":"writeUtf8CodePoint"},{"location":"2.x/okio/okio/-buffer/write-utf8/","text":"okio / okio / Buffer / writeUtf8 writeUtf8 \u00b6 (js, jvm, native) fun writeUtf8(string: String ): Buffer fun writeUtf8(string: String , beginIndex: Int , endIndex: Int ): Buffer","title":"writeUtf8 - Okio"},{"location":"2.x/okio/okio/-buffer/write-utf8/#writeutf8","text":"(js, jvm, native) fun writeUtf8(string: String ): Buffer fun writeUtf8(string: String , beginIndex: Int , endIndex: Int ): Buffer","title":"writeUtf8"},{"location":"2.x/okio/okio/-buffer/write/","text":"okio / okio / Buffer / write write \u00b6 (js, jvm, native) fun write(byteString: ByteString ): Buffer (js, jvm) fun write(byteString: ByteString , offset: Int , byteCount: Int ): Buffer (native) fun write(byteString: ByteString , offset: Int , byteCount: Int ): <ERROR CLASS> (js, jvm, native) fun write(source: ByteArray ): Buffer (js, jvm, native) fun write(source: ByteArray , offset: Int , byteCount: Int ): Buffer (js, jvm, native) fun write(source: Source , byteCount: Long ): Buffer (js, jvm, native) fun write(source: Buffer , byteCount: Long ): Unit (jvm) fun write(source: ByteBuffer ): Int","title":"write - Okio"},{"location":"2.x/okio/okio/-buffer/write/#write","text":"(js, jvm, native) fun write(byteString: ByteString ): Buffer (js, jvm) fun write(byteString: ByteString , offset: Int , byteCount: Int ): Buffer (native) fun write(byteString: ByteString , offset: Int , byteCount: Int ): <ERROR CLASS> (js, jvm, native) fun write(source: ByteArray ): Buffer (js, jvm, native) fun write(source: ByteArray , offset: Int , byteCount: Int ): Buffer (js, jvm, native) fun write(source: Source , byteCount: Long ): Buffer (js, jvm, native) fun write(source: Buffer , byteCount: Long ): Unit (jvm) fun write(source: ByteBuffer ): Int","title":"write"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/","text":"okio / okio / Buffer / UnsafeCursor UnsafeCursor \u00b6 (jvm) class UnsafeCursor : Closeable A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences. Buffer Internals Most code should use Buffer as a black box: a class that holds 0 or more bytes of data with efficient APIs to append data to the end and to consume data from the front. Usually this is also the most efficient way to use buffers because it allows Okio to employ several optimizations, including: Fast Allocation: Buffers use a shared pool of memory that is not zero-filled before use. Fast Resize: A buffer\u2019s capacity can change without copying its contents. Fast Move: Memory ownership can be reassigned from one buffer to another. Fast Copy: Multiple buffers can share the same underlying memory. Fast Encoding and Decoding: Common operations like UTF-8 encoding and decimal decoding do not require intermediate objects to be allocated. These optimizations all leverage the way Okio stores data internally. Okio Buffers are implemented using a doubly-linked list of segments. Each segment is a contiguous range within a 8 KiB ByteArray . Each segment has two indexes, start , the offset of the first byte of the array containing application data, and end , the offset of the first byte beyond start whose data is undefined. New buffers are empty and have no segments: val buffer = Buffer() We append 7 bytes of data to the end of our empty buffer. Internally, the buffer allocates a segment and writes its new data there. The lone segment has an 8 KiB byte array but only 7 bytes of data: buffer.writeUtf8(\"sealion\") // [ 's', 'e', 'a', 'l', 'i', 'o', 'n', '?', '?', '?', ...] // ^ ^ // start = 0 end = 7 When we read 4 bytes of data from the buffer, it finds its first segment and returns that data to us. As bytes are read the data is consumed. The segment tracks this by adjusting its internal indices. buffer.readUtf8(4) // \"seal\" // [ 's', 'e', 'a', 'l', 'i', 'o', 'n', '?', '?', '?', ...] // ^ ^ // start = 4 end = 7 As we write data into a buffer we fill up its internal segments. When a write doesn\u2019t fit into a buffer\u2019s last segment, additional segments are allocated and appended to the linked list of segments. Each segment has its own start and end indexes tracking where the user\u2019s data begins and ends. val xoxo = new Buffer() xoxo.writeUtf8(\"xo\".repeat(5_000)) // [ 'x', 'o', 'x', 'o', 'x', 'o', 'x', 'o', ..., 'x', 'o', 'x', 'o'] // ^ ^ // start = 0 end = 8192 // // [ 'x', 'o', 'x', 'o', ..., 'x', 'o', 'x', 'o', '?', '?', '?', ...] // ^ ^ // start = 0 end = 1808 The start index is always inclusive and the end index is always exclusive . The data preceding the start index is undefined, and the data at and following the end index is undefined. After the last byte of a segment has been read, that segment may be returned to an internal segment pool. In addition to reducing the need to do garbage collection, segment pooling also saves the JVM from needing to zero-fill byte arrays. Okio doesn\u2019t need to zero-fill its arrays because it always writes memory before it reads it. But if you look at a segment in a debugger you may see its effects. In this example, one of the \u201cxoxo\u201d segments above is reused in an unrelated buffer: val abc = new Buffer() abc.writeUtf8(\"abc\") // [ 'a', 'b', 'c', 'o', 'x', 'o', 'x', 'o', ...] // ^ ^ // start = 0 end = 3 There is an optimization in Buffer.clone() and other methods that allows two segments to share the same underlying byte array. Clones can\u2019t write to the shared byte array; instead they allocate a new (private) segment early. val nana = new Buffer() nana.writeUtf8(\"na\".repeat(2_500)) nana.readUtf8(2) // \"na\" // [ 'n', 'a', 'n', 'a', ..., 'n', 'a', 'n', 'a', '?', '?', '?', ...] // ^ ^ // start = 2 end = 5000 nana2 = nana.clone() nana2.writeUtf8(\"batman\") // [ 'n', 'a', 'n', 'a', ..., 'n', 'a', 'n', 'a', '?', '?', '?', ...] // ^ ^ // start = 2 end = 5000 // // [ 'b', 'a', 't', 'm', 'a', 'n', '?', '?', '?', ...] // ^ ^ // start = 0 end = 6 Segments are not shared when the shared region is small (ie. less than 1 KiB). This is intended to prevent fragmentation in sharing-heavy use cases. Unsafe Cursor API This class exposes privileged access to the internal byte arrays of a buffer. A cursor either references the data of a single segment, it is before the first segment ( offset == -1 ), or it is after the last segment ( offset == buffer.size ). Call UnsafeCursor.seek to move the cursor to the segment that contains a specified offset. After seeking, UnsafeCursor.data references the segment\u2019s internal byte array, UnsafeCursor.start is the segment\u2019s start and UnsafeCursor.end is its end. Call UnsafeCursor.next to advance the cursor to the next segment. This returns -1 if there are no further segments in the buffer. Use Buffer.readUnsafe to create a cursor to read buffer data and Buffer.readAndWriteUnsafe to create a cursor to read and write buffer data. In either case, always call UnsafeCursor.close when done with a cursor. This is convenient with Kotlin\u2019s use extension function. In this example we read all of the bytes in a buffer into a byte array: val bufferBytes = ByteArray(buffer.size.toInt()) buffer.readUnsafe().use { cursor -> while (cursor.next() != -1) { System.arraycopy(cursor.data, cursor.start, bufferBytes, cursor.offset.toInt(), cursor.end - cursor.start); } } Change the capacity of a buffer with resizeBuffer . This is only permitted for read+write cursors. The buffer\u2019s size always changes from the end: shrinking it removes bytes from the end; growing it adds capacity to the end. Warnings Most application developers should avoid this API. Those that must use this API should respect these warnings. Don\u2019t mutate a cursor. This class has public, non-final fields because that is convenient for low-level I/O frameworks. Never assign values to these fields; instead use the cursor API to adjust these. Never mutate data unless you have read+write access. You are on the honor system to never write the buffer in read-only mode. Read-only mode may be more efficient than read+write mode because it does not need to make private copies of shared segments. Only access data in [start..end) . Other data in the byte array is undefined! It may contain private or sensitive data from other parts of your process. Always fill the new capacity when you grow a buffer. New capacity is not zero-filled and may contain data from other parts of your process. Avoid leaking this information by always writing something to the newly-allocated capacity. Do not assume that new capacity will be filled with 0 ; it will not be. Do not access a buffer while is being accessed by a cursor. Even simple read-only operations like Buffer.clone are unsafe because they mark segments as shared. Do not hard-code the segment size in your application. It is possible that segment sizes will change with advances in hardware. Future versions of Okio may even have heterogeneous segment sizes. These warnings are intended to help you to use this API safely. It\u2019s here for developers that need absolutely the most throughput. Since that\u2019s you, here\u2019s one final performance tip. You can reuse instances of this class if you like. Use the overloads of Buffer.readUnsafe and Buffer.readAndWriteUnsafe that take a cursor and close it after use. Constructors \u00b6 Name Summary (jvm) <init> A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences. UnsafeCursor() Properties \u00b6 Name Summary (jvm) buffer var buffer: Buffer ? (jvm) data var data: ByteArray ? (jvm) end var end: Int (jvm) offset var offset: Long (jvm) readWrite var readWrite: Boolean (jvm) start var start: Int Functions \u00b6 Name Summary (jvm) close fun close(): Unit (jvm) expandBuffer Grow the buffer by adding a contiguous range of capacity in a single segment. This adds at least minByteCount bytes but may add up to a full segment of additional capacity. fun expandBuffer(minByteCount: Int ): Long (jvm) next Seeks to the next range of bytes, advancing the offset by end - start . Returns the size of the readable range (at least 1), or -1 if we have reached the end of the buffer and there are no more bytes to read. fun next(): Int (jvm) resizeBuffer Change the size of the buffer so that it equals newSize by either adding new capacity at the end or truncating the buffer at the end. Newly added capacity may span multiple segments. fun resizeBuffer(newSize: Long ): Long (jvm) seek Reposition the cursor so that the data at offset is readable at data[start] . Returns the number of bytes readable in data (at least 1), or -1 if there are no data to read. fun seek(offset: Long ): Int","title":"UnsafeCursor - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/#unsafecursor","text":"(jvm) class UnsafeCursor : Closeable A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences. Buffer Internals Most code should use Buffer as a black box: a class that holds 0 or more bytes of data with efficient APIs to append data to the end and to consume data from the front. Usually this is also the most efficient way to use buffers because it allows Okio to employ several optimizations, including: Fast Allocation: Buffers use a shared pool of memory that is not zero-filled before use. Fast Resize: A buffer\u2019s capacity can change without copying its contents. Fast Move: Memory ownership can be reassigned from one buffer to another. Fast Copy: Multiple buffers can share the same underlying memory. Fast Encoding and Decoding: Common operations like UTF-8 encoding and decimal decoding do not require intermediate objects to be allocated. These optimizations all leverage the way Okio stores data internally. Okio Buffers are implemented using a doubly-linked list of segments. Each segment is a contiguous range within a 8 KiB ByteArray . Each segment has two indexes, start , the offset of the first byte of the array containing application data, and end , the offset of the first byte beyond start whose data is undefined. New buffers are empty and have no segments: val buffer = Buffer() We append 7 bytes of data to the end of our empty buffer. Internally, the buffer allocates a segment and writes its new data there. The lone segment has an 8 KiB byte array but only 7 bytes of data: buffer.writeUtf8(\"sealion\") // [ 's', 'e', 'a', 'l', 'i', 'o', 'n', '?', '?', '?', ...] // ^ ^ // start = 0 end = 7 When we read 4 bytes of data from the buffer, it finds its first segment and returns that data to us. As bytes are read the data is consumed. The segment tracks this by adjusting its internal indices. buffer.readUtf8(4) // \"seal\" // [ 's', 'e', 'a', 'l', 'i', 'o', 'n', '?', '?', '?', ...] // ^ ^ // start = 4 end = 7 As we write data into a buffer we fill up its internal segments. When a write doesn\u2019t fit into a buffer\u2019s last segment, additional segments are allocated and appended to the linked list of segments. Each segment has its own start and end indexes tracking where the user\u2019s data begins and ends. val xoxo = new Buffer() xoxo.writeUtf8(\"xo\".repeat(5_000)) // [ 'x', 'o', 'x', 'o', 'x', 'o', 'x', 'o', ..., 'x', 'o', 'x', 'o'] // ^ ^ // start = 0 end = 8192 // // [ 'x', 'o', 'x', 'o', ..., 'x', 'o', 'x', 'o', '?', '?', '?', ...] // ^ ^ // start = 0 end = 1808 The start index is always inclusive and the end index is always exclusive . The data preceding the start index is undefined, and the data at and following the end index is undefined. After the last byte of a segment has been read, that segment may be returned to an internal segment pool. In addition to reducing the need to do garbage collection, segment pooling also saves the JVM from needing to zero-fill byte arrays. Okio doesn\u2019t need to zero-fill its arrays because it always writes memory before it reads it. But if you look at a segment in a debugger you may see its effects. In this example, one of the \u201cxoxo\u201d segments above is reused in an unrelated buffer: val abc = new Buffer() abc.writeUtf8(\"abc\") // [ 'a', 'b', 'c', 'o', 'x', 'o', 'x', 'o', ...] // ^ ^ // start = 0 end = 3 There is an optimization in Buffer.clone() and other methods that allows two segments to share the same underlying byte array. Clones can\u2019t write to the shared byte array; instead they allocate a new (private) segment early. val nana = new Buffer() nana.writeUtf8(\"na\".repeat(2_500)) nana.readUtf8(2) // \"na\" // [ 'n', 'a', 'n', 'a', ..., 'n', 'a', 'n', 'a', '?', '?', '?', ...] // ^ ^ // start = 2 end = 5000 nana2 = nana.clone() nana2.writeUtf8(\"batman\") // [ 'n', 'a', 'n', 'a', ..., 'n', 'a', 'n', 'a', '?', '?', '?', ...] // ^ ^ // start = 2 end = 5000 // // [ 'b', 'a', 't', 'm', 'a', 'n', '?', '?', '?', ...] // ^ ^ // start = 0 end = 6 Segments are not shared when the shared region is small (ie. less than 1 KiB). This is intended to prevent fragmentation in sharing-heavy use cases. Unsafe Cursor API This class exposes privileged access to the internal byte arrays of a buffer. A cursor either references the data of a single segment, it is before the first segment ( offset == -1 ), or it is after the last segment ( offset == buffer.size ). Call UnsafeCursor.seek to move the cursor to the segment that contains a specified offset. After seeking, UnsafeCursor.data references the segment\u2019s internal byte array, UnsafeCursor.start is the segment\u2019s start and UnsafeCursor.end is its end. Call UnsafeCursor.next to advance the cursor to the next segment. This returns -1 if there are no further segments in the buffer. Use Buffer.readUnsafe to create a cursor to read buffer data and Buffer.readAndWriteUnsafe to create a cursor to read and write buffer data. In either case, always call UnsafeCursor.close when done with a cursor. This is convenient with Kotlin\u2019s use extension function. In this example we read all of the bytes in a buffer into a byte array: val bufferBytes = ByteArray(buffer.size.toInt()) buffer.readUnsafe().use { cursor -> while (cursor.next() != -1) { System.arraycopy(cursor.data, cursor.start, bufferBytes, cursor.offset.toInt(), cursor.end - cursor.start); } } Change the capacity of a buffer with resizeBuffer . This is only permitted for read+write cursors. The buffer\u2019s size always changes from the end: shrinking it removes bytes from the end; growing it adds capacity to the end. Warnings Most application developers should avoid this API. Those that must use this API should respect these warnings. Don\u2019t mutate a cursor. This class has public, non-final fields because that is convenient for low-level I/O frameworks. Never assign values to these fields; instead use the cursor API to adjust these. Never mutate data unless you have read+write access. You are on the honor system to never write the buffer in read-only mode. Read-only mode may be more efficient than read+write mode because it does not need to make private copies of shared segments. Only access data in [start..end) . Other data in the byte array is undefined! It may contain private or sensitive data from other parts of your process. Always fill the new capacity when you grow a buffer. New capacity is not zero-filled and may contain data from other parts of your process. Avoid leaking this information by always writing something to the newly-allocated capacity. Do not assume that new capacity will be filled with 0 ; it will not be. Do not access a buffer while is being accessed by a cursor. Even simple read-only operations like Buffer.clone are unsafe because they mark segments as shared. Do not hard-code the segment size in your application. It is possible that segment sizes will change with advances in hardware. Future versions of Okio may even have heterogeneous segment sizes. These warnings are intended to help you to use this API safely. It\u2019s here for developers that need absolutely the most throughput. Since that\u2019s you, here\u2019s one final performance tip. You can reuse instances of this class if you like. Use the overloads of Buffer.readUnsafe and Buffer.readAndWriteUnsafe that take a cursor and close it after use.","title":"UnsafeCursor"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/#constructors","text":"Name Summary (jvm) <init> A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences. UnsafeCursor()","title":"Constructors"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/#properties","text":"Name Summary (jvm) buffer var buffer: Buffer ? (jvm) data var data: ByteArray ? (jvm) end var end: Int (jvm) offset var offset: Long (jvm) readWrite var readWrite: Boolean (jvm) start var start: Int","title":"Properties"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/#functions","text":"Name Summary (jvm) close fun close(): Unit (jvm) expandBuffer Grow the buffer by adding a contiguous range of capacity in a single segment. This adds at least minByteCount bytes but may add up to a full segment of additional capacity. fun expandBuffer(minByteCount: Int ): Long (jvm) next Seeks to the next range of bytes, advancing the offset by end - start . Returns the size of the readable range (at least 1), or -1 if we have reached the end of the buffer and there are no more bytes to read. fun next(): Int (jvm) resizeBuffer Change the size of the buffer so that it equals newSize by either adding new capacity at the end or truncating the buffer at the end. Newly added capacity may span multiple segments. fun resizeBuffer(newSize: Long ): Long (jvm) seek Reposition the cursor so that the data at offset is readable at data[start] . Returns the number of bytes readable in data (at least 1), or -1 if there are no data to read. fun seek(offset: Long ): Int","title":"Functions"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/-init-/","text":"okio / okio / Buffer / UnsafeCursor / <init> <init> \u00b6 (jvm) UnsafeCursor() A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences. Buffer Internals Most code should use Buffer as a black box: a class that holds 0 or more bytes of data with efficient APIs to append data to the end and to consume data from the front. Usually this is also the most efficient way to use buffers because it allows Okio to employ several optimizations, including: Fast Allocation: Buffers use a shared pool of memory that is not zero-filled before use. Fast Resize: A buffer\u2019s capacity can change without copying its contents. Fast Move: Memory ownership can be reassigned from one buffer to another. Fast Copy: Multiple buffers can share the same underlying memory. Fast Encoding and Decoding: Common operations like UTF-8 encoding and decimal decoding do not require intermediate objects to be allocated. These optimizations all leverage the way Okio stores data internally. Okio Buffers are implemented using a doubly-linked list of segments. Each segment is a contiguous range within a 8 KiB ByteArray . Each segment has two indexes, start , the offset of the first byte of the array containing application data, and end , the offset of the first byte beyond start whose data is undefined. New buffers are empty and have no segments: val buffer = Buffer() We append 7 bytes of data to the end of our empty buffer. Internally, the buffer allocates a segment and writes its new data there. The lone segment has an 8 KiB byte array but only 7 bytes of data: buffer.writeUtf8(\"sealion\") // [ 's', 'e', 'a', 'l', 'i', 'o', 'n', '?', '?', '?', ...] // ^ ^ // start = 0 end = 7 When we read 4 bytes of data from the buffer, it finds its first segment and returns that data to us. As bytes are read the data is consumed. The segment tracks this by adjusting its internal indices. buffer.readUtf8(4) // \"seal\" // [ 's', 'e', 'a', 'l', 'i', 'o', 'n', '?', '?', '?', ...] // ^ ^ // start = 4 end = 7 As we write data into a buffer we fill up its internal segments. When a write doesn\u2019t fit into a buffer\u2019s last segment, additional segments are allocated and appended to the linked list of segments. Each segment has its own start and end indexes tracking where the user\u2019s data begins and ends. val xoxo = new Buffer() xoxo.writeUtf8(\"xo\".repeat(5_000)) // [ 'x', 'o', 'x', 'o', 'x', 'o', 'x', 'o', ..., 'x', 'o', 'x', 'o'] // ^ ^ // start = 0 end = 8192 // // [ 'x', 'o', 'x', 'o', ..., 'x', 'o', 'x', 'o', '?', '?', '?', ...] // ^ ^ // start = 0 end = 1808 The start index is always inclusive and the end index is always exclusive . The data preceding the start index is undefined, and the data at and following the end index is undefined. After the last byte of a segment has been read, that segment may be returned to an internal segment pool. In addition to reducing the need to do garbage collection, segment pooling also saves the JVM from needing to zero-fill byte arrays. Okio doesn\u2019t need to zero-fill its arrays because it always writes memory before it reads it. But if you look at a segment in a debugger you may see its effects. In this example, one of the \u201cxoxo\u201d segments above is reused in an unrelated buffer: val abc = new Buffer() abc.writeUtf8(\"abc\") // [ 'a', 'b', 'c', 'o', 'x', 'o', 'x', 'o', ...] // ^ ^ // start = 0 end = 3 There is an optimization in Buffer.clone() and other methods that allows two segments to share the same underlying byte array. Clones can\u2019t write to the shared byte array; instead they allocate a new (private) segment early. val nana = new Buffer() nana.writeUtf8(\"na\".repeat(2_500)) nana.readUtf8(2) // \"na\" // [ 'n', 'a', 'n', 'a', ..., 'n', 'a', 'n', 'a', '?', '?', '?', ...] // ^ ^ // start = 2 end = 5000 nana2 = nana.clone() nana2.writeUtf8(\"batman\") // [ 'n', 'a', 'n', 'a', ..., 'n', 'a', 'n', 'a', '?', '?', '?', ...] // ^ ^ // start = 2 end = 5000 // // [ 'b', 'a', 't', 'm', 'a', 'n', '?', '?', '?', ...] // ^ ^ // start = 0 end = 6 Segments are not shared when the shared region is small (ie. less than 1 KiB). This is intended to prevent fragmentation in sharing-heavy use cases. Unsafe Cursor API This class exposes privileged access to the internal byte arrays of a buffer. A cursor either references the data of a single segment, it is before the first segment ( offset == -1 ), or it is after the last segment ( offset == buffer.size ). Call UnsafeCursor.seek to move the cursor to the segment that contains a specified offset. After seeking, UnsafeCursor.data references the segment\u2019s internal byte array, UnsafeCursor.start is the segment\u2019s start and UnsafeCursor.end is its end. Call UnsafeCursor.next to advance the cursor to the next segment. This returns -1 if there are no further segments in the buffer. Use Buffer.readUnsafe to create a cursor to read buffer data and Buffer.readAndWriteUnsafe to create a cursor to read and write buffer data. In either case, always call UnsafeCursor.close when done with a cursor. This is convenient with Kotlin\u2019s use extension function. In this example we read all of the bytes in a buffer into a byte array: val bufferBytes = ByteArray(buffer.size.toInt()) buffer.readUnsafe().use { cursor -> while (cursor.next() != -1) { System.arraycopy(cursor.data, cursor.start, bufferBytes, cursor.offset.toInt(), cursor.end - cursor.start); } } Change the capacity of a buffer with resizeBuffer . This is only permitted for read+write cursors. The buffer\u2019s size always changes from the end: shrinking it removes bytes from the end; growing it adds capacity to the end. Warnings Most application developers should avoid this API. Those that must use this API should respect these warnings. Don\u2019t mutate a cursor. This class has public, non-final fields because that is convenient for low-level I/O frameworks. Never assign values to these fields; instead use the cursor API to adjust these. Never mutate data unless you have read+write access. You are on the honor system to never write the buffer in read-only mode. Read-only mode may be more efficient than read+write mode because it does not need to make private copies of shared segments. Only access data in [start..end) . Other data in the byte array is undefined! It may contain private or sensitive data from other parts of your process. Always fill the new capacity when you grow a buffer. New capacity is not zero-filled and may contain data from other parts of your process. Avoid leaking this information by always writing something to the newly-allocated capacity. Do not assume that new capacity will be filled with 0 ; it will not be. Do not access a buffer while is being accessed by a cursor. Even simple read-only operations like Buffer.clone are unsafe because they mark segments as shared. Do not hard-code the segment size in your application. It is possible that segment sizes will change with advances in hardware. Future versions of Okio may even have heterogeneous segment sizes. These warnings are intended to help you to use this API safely. It\u2019s here for developers that need absolutely the most throughput. Since that\u2019s you, here\u2019s one final performance tip. You can reuse instances of this class if you like. Use the overloads of Buffer.readUnsafe and Buffer.readAndWriteUnsafe that take a cursor and close it after use.","title":" init "},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/-init-/#init","text":"(jvm) UnsafeCursor() A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences. Buffer Internals Most code should use Buffer as a black box: a class that holds 0 or more bytes of data with efficient APIs to append data to the end and to consume data from the front. Usually this is also the most efficient way to use buffers because it allows Okio to employ several optimizations, including: Fast Allocation: Buffers use a shared pool of memory that is not zero-filled before use. Fast Resize: A buffer\u2019s capacity can change without copying its contents. Fast Move: Memory ownership can be reassigned from one buffer to another. Fast Copy: Multiple buffers can share the same underlying memory. Fast Encoding and Decoding: Common operations like UTF-8 encoding and decimal decoding do not require intermediate objects to be allocated. These optimizations all leverage the way Okio stores data internally. Okio Buffers are implemented using a doubly-linked list of segments. Each segment is a contiguous range within a 8 KiB ByteArray . Each segment has two indexes, start , the offset of the first byte of the array containing application data, and end , the offset of the first byte beyond start whose data is undefined. New buffers are empty and have no segments: val buffer = Buffer() We append 7 bytes of data to the end of our empty buffer. Internally, the buffer allocates a segment and writes its new data there. The lone segment has an 8 KiB byte array but only 7 bytes of data: buffer.writeUtf8(\"sealion\") // [ 's', 'e', 'a', 'l', 'i', 'o', 'n', '?', '?', '?', ...] // ^ ^ // start = 0 end = 7 When we read 4 bytes of data from the buffer, it finds its first segment and returns that data to us. As bytes are read the data is consumed. The segment tracks this by adjusting its internal indices. buffer.readUtf8(4) // \"seal\" // [ 's', 'e', 'a', 'l', 'i', 'o', 'n', '?', '?', '?', ...] // ^ ^ // start = 4 end = 7 As we write data into a buffer we fill up its internal segments. When a write doesn\u2019t fit into a buffer\u2019s last segment, additional segments are allocated and appended to the linked list of segments. Each segment has its own start and end indexes tracking where the user\u2019s data begins and ends. val xoxo = new Buffer() xoxo.writeUtf8(\"xo\".repeat(5_000)) // [ 'x', 'o', 'x', 'o', 'x', 'o', 'x', 'o', ..., 'x', 'o', 'x', 'o'] // ^ ^ // start = 0 end = 8192 // // [ 'x', 'o', 'x', 'o', ..., 'x', 'o', 'x', 'o', '?', '?', '?', ...] // ^ ^ // start = 0 end = 1808 The start index is always inclusive and the end index is always exclusive . The data preceding the start index is undefined, and the data at and following the end index is undefined. After the last byte of a segment has been read, that segment may be returned to an internal segment pool. In addition to reducing the need to do garbage collection, segment pooling also saves the JVM from needing to zero-fill byte arrays. Okio doesn\u2019t need to zero-fill its arrays because it always writes memory before it reads it. But if you look at a segment in a debugger you may see its effects. In this example, one of the \u201cxoxo\u201d segments above is reused in an unrelated buffer: val abc = new Buffer() abc.writeUtf8(\"abc\") // [ 'a', 'b', 'c', 'o', 'x', 'o', 'x', 'o', ...] // ^ ^ // start = 0 end = 3 There is an optimization in Buffer.clone() and other methods that allows two segments to share the same underlying byte array. Clones can\u2019t write to the shared byte array; instead they allocate a new (private) segment early. val nana = new Buffer() nana.writeUtf8(\"na\".repeat(2_500)) nana.readUtf8(2) // \"na\" // [ 'n', 'a', 'n', 'a', ..., 'n', 'a', 'n', 'a', '?', '?', '?', ...] // ^ ^ // start = 2 end = 5000 nana2 = nana.clone() nana2.writeUtf8(\"batman\") // [ 'n', 'a', 'n', 'a', ..., 'n', 'a', 'n', 'a', '?', '?', '?', ...] // ^ ^ // start = 2 end = 5000 // // [ 'b', 'a', 't', 'm', 'a', 'n', '?', '?', '?', ...] // ^ ^ // start = 0 end = 6 Segments are not shared when the shared region is small (ie. less than 1 KiB). This is intended to prevent fragmentation in sharing-heavy use cases. Unsafe Cursor API This class exposes privileged access to the internal byte arrays of a buffer. A cursor either references the data of a single segment, it is before the first segment ( offset == -1 ), or it is after the last segment ( offset == buffer.size ). Call UnsafeCursor.seek to move the cursor to the segment that contains a specified offset. After seeking, UnsafeCursor.data references the segment\u2019s internal byte array, UnsafeCursor.start is the segment\u2019s start and UnsafeCursor.end is its end. Call UnsafeCursor.next to advance the cursor to the next segment. This returns -1 if there are no further segments in the buffer. Use Buffer.readUnsafe to create a cursor to read buffer data and Buffer.readAndWriteUnsafe to create a cursor to read and write buffer data. In either case, always call UnsafeCursor.close when done with a cursor. This is convenient with Kotlin\u2019s use extension function. In this example we read all of the bytes in a buffer into a byte array: val bufferBytes = ByteArray(buffer.size.toInt()) buffer.readUnsafe().use { cursor -> while (cursor.next() != -1) { System.arraycopy(cursor.data, cursor.start, bufferBytes, cursor.offset.toInt(), cursor.end - cursor.start); } } Change the capacity of a buffer with resizeBuffer . This is only permitted for read+write cursors. The buffer\u2019s size always changes from the end: shrinking it removes bytes from the end; growing it adds capacity to the end. Warnings Most application developers should avoid this API. Those that must use this API should respect these warnings. Don\u2019t mutate a cursor. This class has public, non-final fields because that is convenient for low-level I/O frameworks. Never assign values to these fields; instead use the cursor API to adjust these. Never mutate data unless you have read+write access. You are on the honor system to never write the buffer in read-only mode. Read-only mode may be more efficient than read+write mode because it does not need to make private copies of shared segments. Only access data in [start..end) . Other data in the byte array is undefined! It may contain private or sensitive data from other parts of your process. Always fill the new capacity when you grow a buffer. New capacity is not zero-filled and may contain data from other parts of your process. Avoid leaking this information by always writing something to the newly-allocated capacity. Do not assume that new capacity will be filled with 0 ; it will not be. Do not access a buffer while is being accessed by a cursor. Even simple read-only operations like Buffer.clone are unsafe because they mark segments as shared. Do not hard-code the segment size in your application. It is possible that segment sizes will change with advances in hardware. Future versions of Okio may even have heterogeneous segment sizes. These warnings are intended to help you to use this API safely. It\u2019s here for developers that need absolutely the most throughput. Since that\u2019s you, here\u2019s one final performance tip. You can reuse instances of this class if you like. Use the overloads of Buffer.readUnsafe and Buffer.readAndWriteUnsafe that take a cursor and close it after use.","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/buffer/","text":"okio / okio / Buffer / UnsafeCursor / buffer buffer \u00b6 (jvm) var buffer: Buffer ?","title":"buffer - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/buffer/#buffer","text":"(jvm) var buffer: Buffer ?","title":"buffer"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/close/","text":"okio / okio / Buffer / UnsafeCursor / close close \u00b6 (jvm) fun close(): Unit","title":"close - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/close/#close","text":"(jvm) fun close(): Unit","title":"close"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/data/","text":"okio / okio / Buffer / UnsafeCursor / data data \u00b6 (jvm) var data: ByteArray ?","title":"data - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/data/#data","text":"(jvm) var data: ByteArray ?","title":"data"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/end/","text":"okio / okio / Buffer / UnsafeCursor / end end \u00b6 (jvm) var end: Int","title":"end - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/end/#end","text":"(jvm) var end: Int","title":"end"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/expand-buffer/","text":"okio / okio / Buffer / UnsafeCursor / expandBuffer expandBuffer \u00b6 (jvm) fun expandBuffer(minByteCount: Int ): Long Grow the buffer by adding a contiguous range of capacity in a single segment. This adds at least minByteCount bytes but may add up to a full segment of additional capacity. As a side-effect this cursor will seek . It will move offset to the first byte of newly-added capacity. This is the size of the buffer prior to the expandBuffer() call. If minByteCount bytes are available in the buffer\u2019s current tail segment that will be used; otherwise another segment will be allocated and appended. In either case this returns the number of bytes of capacity added to this buffer. Warning: it is the caller\u2019s responsibility to either write new data to every byte of the newly-allocated capacity, or to shrink the buffer to the data written. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process. Parameters \u00b6 minByteCount - the size of the contiguous capacity. Must be positive and not greater than the capacity size of a single segment (8 KiB). Return the number of bytes expanded by. Not less than minByteCount .","title":"expandBuffer - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/expand-buffer/#expandbuffer","text":"(jvm) fun expandBuffer(minByteCount: Int ): Long Grow the buffer by adding a contiguous range of capacity in a single segment. This adds at least minByteCount bytes but may add up to a full segment of additional capacity. As a side-effect this cursor will seek . It will move offset to the first byte of newly-added capacity. This is the size of the buffer prior to the expandBuffer() call. If minByteCount bytes are available in the buffer\u2019s current tail segment that will be used; otherwise another segment will be allocated and appended. In either case this returns the number of bytes of capacity added to this buffer. Warning: it is the caller\u2019s responsibility to either write new data to every byte of the newly-allocated capacity, or to shrink the buffer to the data written. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process.","title":"expandBuffer"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/expand-buffer/#parameters","text":"minByteCount - the size of the contiguous capacity. Must be positive and not greater than the capacity size of a single segment (8 KiB). Return the number of bytes expanded by. Not less than minByteCount .","title":"Parameters"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/next/","text":"okio / okio / Buffer / UnsafeCursor / next next \u00b6 (jvm) fun next(): Int Seeks to the next range of bytes, advancing the offset by end - start . Returns the size of the readable range (at least 1), or -1 if we have reached the end of the buffer and there are no more bytes to read.","title":"next - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/next/#next","text":"(jvm) fun next(): Int Seeks to the next range of bytes, advancing the offset by end - start . Returns the size of the readable range (at least 1), or -1 if we have reached the end of the buffer and there are no more bytes to read.","title":"next"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/offset/","text":"okio / okio / Buffer / UnsafeCursor / offset offset \u00b6 (jvm) var offset: Long","title":"offset - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/offset/#offset","text":"(jvm) var offset: Long","title":"offset"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/read-write/","text":"okio / okio / Buffer / UnsafeCursor / readWrite readWrite \u00b6 (jvm) var readWrite: Boolean","title":"readWrite - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/read-write/#readwrite","text":"(jvm) var readWrite: Boolean","title":"readWrite"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/resize-buffer/","text":"okio / okio / Buffer / UnsafeCursor / resizeBuffer resizeBuffer \u00b6 (jvm) fun resizeBuffer(newSize: Long ): Long Change the size of the buffer so that it equals newSize by either adding new capacity at the end or truncating the buffer at the end. Newly added capacity may span multiple segments. As a side-effect this cursor will seek . If the buffer is being enlarged it will move UnsafeCursor.offset to the first byte of newly-added capacity. This is the size of the buffer prior to the resizeBuffer() call. If the buffer is being shrunk it will move UnsafeCursor.offset to the end of the buffer. Warning: it is the caller\u2019s responsibility to write new data to every byte of the newly-allocated capacity. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process. Return the previous size of the buffer.","title":"resizeBuffer - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/resize-buffer/#resizebuffer","text":"(jvm) fun resizeBuffer(newSize: Long ): Long Change the size of the buffer so that it equals newSize by either adding new capacity at the end or truncating the buffer at the end. Newly added capacity may span multiple segments. As a side-effect this cursor will seek . If the buffer is being enlarged it will move UnsafeCursor.offset to the first byte of newly-added capacity. This is the size of the buffer prior to the resizeBuffer() call. If the buffer is being shrunk it will move UnsafeCursor.offset to the end of the buffer. Warning: it is the caller\u2019s responsibility to write new data to every byte of the newly-allocated capacity. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process. Return the previous size of the buffer.","title":"resizeBuffer"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/seek/","text":"okio / okio / Buffer / UnsafeCursor / seek seek \u00b6 (jvm) fun seek(offset: Long ): Int Reposition the cursor so that the data at offset is readable at data[start] . Returns the number of bytes readable in data (at least 1), or -1 if there are no data to read.","title":"seek - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/seek/#seek","text":"(jvm) fun seek(offset: Long ): Int Reposition the cursor so that the data at offset is readable at data[start] . Returns the number of bytes readable in data (at least 1), or -1 if there are no data to read.","title":"seek"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/start/","text":"okio / okio / Buffer / UnsafeCursor / start start \u00b6 (jvm) var start: Int","title":"start - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/start/#start","text":"(jvm) var start: Int","title":"start"},{"location":"2.x/okio/okio/-buffered-sink/","text":"okio / okio / BufferedSink BufferedSink \u00b6 (js, jvm, native) interface BufferedSink : Sink A sink that keeps a buffer internally so that callers can do small writes without a performance penalty. Properties \u00b6 Name Summary (js, jvm, native) buffer This sink\u2019s internal buffer. abstract val buffer: Buffer Functions \u00b6 Name Summary (jvm) buffer Returns this sink\u2019s internal buffer. abstract fun ~~buffer~~(): Buffer (js, jvm, native) emit Writes all buffered data to the underlying sink, if one exists. Like flush , but weaker. Call this before this buffered sink goes out of scope so that its data can reach its destination. abstract fun emit(): BufferedSink (js, jvm, native) emitCompleteSegments Writes complete segments to the underlying sink, if one exists. Like flush , but weaker. Use this to limit the memory held in the buffer to a single segment. Typically application code will not need to call this: it is only necessary when application code writes directly to this sink\u2019s buffer . abstract fun emitCompleteSegments(): BufferedSink (js, jvm) flush Writes all buffered data to the underlying sink, if one exists. Then that sink is recursively flushed which pushes data as far as possible towards its ultimate destination. Typically that destination is a network socket or file. abstract fun flush(): Unit (jvm) outputStream Returns an output stream that writes to this sink. abstract fun outputStream(): OutputStream (js, jvm, native) write abstract fun write(byteString: ByteString ): BufferedSink abstract fun write(byteString: ByteString , offset: Int , byteCount: Int ): BufferedSink Like OutputStream.write , this writes a complete byte array to this sink. abstract fun write(source: ByteArray ): BufferedSink Like OutputStream.write , this writes byteCount bytes of source , starting at offset . abstract fun write(source: ByteArray , offset: Int , byteCount: Int ): BufferedSink Removes byteCount bytes from source and appends them to this sink. abstract fun write(source: Source , byteCount: Long ): BufferedSink (js, jvm, native) writeAll Removes all bytes from source and appends them to this sink. Returns the number of bytes read which will be 0 if source is exhausted. abstract fun writeAll(source: Source ): Long (js, jvm, native) writeByte Writes a byte to this sink. abstract fun writeByte(b: Int ): BufferedSink (js, jvm, native) writeDecimalLong Writes a long to this sink in signed decimal form (i.e., as a string in base 10). abstract fun writeDecimalLong(v: Long ): BufferedSink (js, jvm, native) writeHexadecimalUnsignedLong Writes a long to this sink in hexadecimal form (i.e., as a string in base 16). abstract fun writeHexadecimalUnsignedLong(v: Long ): BufferedSink (js, jvm, native) writeInt Writes a big-endian int to this sink using four bytes. abstract fun writeInt(i: Int ): BufferedSink (js, jvm, native) writeIntLe Writes a little-endian int to this sink using four bytes. abstract fun writeIntLe(i: Int ): BufferedSink (js, jvm, native) writeLong Writes a big-endian long to this sink using eight bytes. abstract fun writeLong(v: Long ): BufferedSink (js, jvm, native) writeLongLe Writes a little-endian long to this sink using eight bytes. abstract fun writeLongLe(v: Long ): BufferedSink (js, jvm, native) writeShort Writes a big-endian short to this sink using two bytes. abstract fun writeShort(s: Int ): BufferedSink (js, jvm, native) writeShortLe Writes a little-endian short to this sink using two bytes. abstract fun writeShortLe(s: Int ): BufferedSink (jvm) writeString abstract fun writeString(string: String , charset: Charset ): BufferedSink abstract fun writeString(string: String , beginIndex: Int , endIndex: Int , charset: Charset ): BufferedSink (js, jvm, native) writeUtf8 Encodes string in UTF-8 and writes it to this sink. abstract fun writeUtf8(string: String ): BufferedSink Encodes the characters at beginIndex up to endIndex from string in UTF-8 and writes it to this sink. abstract fun writeUtf8(string: String , beginIndex: Int , endIndex: Int ): BufferedSink (js, jvm, native) writeUtf8CodePoint Encodes codePoint in UTF-8 and writes it to this sink. abstract fun writeUtf8CodePoint(codePoint: Int ): BufferedSink Extension Functions \u00b6 Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink Inheritors \u00b6 Name Summary (js, jvm, native) Buffer A collection of bytes in memory. class Buffer : BufferedSource , BufferedSink","title":"BufferedSink - Okio"},{"location":"2.x/okio/okio/-buffered-sink/#bufferedsink","text":"(js, jvm, native) interface BufferedSink : Sink A sink that keeps a buffer internally so that callers can do small writes without a performance penalty.","title":"BufferedSink"},{"location":"2.x/okio/okio/-buffered-sink/#properties","text":"Name Summary (js, jvm, native) buffer This sink\u2019s internal buffer. abstract val buffer: Buffer","title":"Properties"},{"location":"2.x/okio/okio/-buffered-sink/#functions","text":"Name Summary (jvm) buffer Returns this sink\u2019s internal buffer. abstract fun ~~buffer~~(): Buffer (js, jvm, native) emit Writes all buffered data to the underlying sink, if one exists. Like flush , but weaker. Call this before this buffered sink goes out of scope so that its data can reach its destination. abstract fun emit(): BufferedSink (js, jvm, native) emitCompleteSegments Writes complete segments to the underlying sink, if one exists. Like flush , but weaker. Use this to limit the memory held in the buffer to a single segment. Typically application code will not need to call this: it is only necessary when application code writes directly to this sink\u2019s buffer . abstract fun emitCompleteSegments(): BufferedSink (js, jvm) flush Writes all buffered data to the underlying sink, if one exists. Then that sink is recursively flushed which pushes data as far as possible towards its ultimate destination. Typically that destination is a network socket or file. abstract fun flush(): Unit (jvm) outputStream Returns an output stream that writes to this sink. abstract fun outputStream(): OutputStream (js, jvm, native) write abstract fun write(byteString: ByteString ): BufferedSink abstract fun write(byteString: ByteString , offset: Int , byteCount: Int ): BufferedSink Like OutputStream.write , this writes a complete byte array to this sink. abstract fun write(source: ByteArray ): BufferedSink Like OutputStream.write , this writes byteCount bytes of source , starting at offset . abstract fun write(source: ByteArray , offset: Int , byteCount: Int ): BufferedSink Removes byteCount bytes from source and appends them to this sink. abstract fun write(source: Source , byteCount: Long ): BufferedSink (js, jvm, native) writeAll Removes all bytes from source and appends them to this sink. Returns the number of bytes read which will be 0 if source is exhausted. abstract fun writeAll(source: Source ): Long (js, jvm, native) writeByte Writes a byte to this sink. abstract fun writeByte(b: Int ): BufferedSink (js, jvm, native) writeDecimalLong Writes a long to this sink in signed decimal form (i.e., as a string in base 10). abstract fun writeDecimalLong(v: Long ): BufferedSink (js, jvm, native) writeHexadecimalUnsignedLong Writes a long to this sink in hexadecimal form (i.e., as a string in base 16). abstract fun writeHexadecimalUnsignedLong(v: Long ): BufferedSink (js, jvm, native) writeInt Writes a big-endian int to this sink using four bytes. abstract fun writeInt(i: Int ): BufferedSink (js, jvm, native) writeIntLe Writes a little-endian int to this sink using four bytes. abstract fun writeIntLe(i: Int ): BufferedSink (js, jvm, native) writeLong Writes a big-endian long to this sink using eight bytes. abstract fun writeLong(v: Long ): BufferedSink (js, jvm, native) writeLongLe Writes a little-endian long to this sink using eight bytes. abstract fun writeLongLe(v: Long ): BufferedSink (js, jvm, native) writeShort Writes a big-endian short to this sink using two bytes. abstract fun writeShort(s: Int ): BufferedSink (js, jvm, native) writeShortLe Writes a little-endian short to this sink using two bytes. abstract fun writeShortLe(s: Int ): BufferedSink (jvm) writeString abstract fun writeString(string: String , charset: Charset ): BufferedSink abstract fun writeString(string: String , beginIndex: Int , endIndex: Int , charset: Charset ): BufferedSink (js, jvm, native) writeUtf8 Encodes string in UTF-8 and writes it to this sink. abstract fun writeUtf8(string: String ): BufferedSink Encodes the characters at beginIndex up to endIndex from string in UTF-8 and writes it to this sink. abstract fun writeUtf8(string: String , beginIndex: Int , endIndex: Int ): BufferedSink (js, jvm, native) writeUtf8CodePoint Encodes codePoint in UTF-8 and writes it to this sink. abstract fun writeUtf8CodePoint(codePoint: Int ): BufferedSink","title":"Functions"},{"location":"2.x/okio/okio/-buffered-sink/#extension-functions","text":"Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink","title":"Extension Functions"},{"location":"2.x/okio/okio/-buffered-sink/#inheritors","text":"Name Summary (js, jvm, native) Buffer A collection of bytes in memory. class Buffer : BufferedSource , BufferedSink","title":"Inheritors"},{"location":"2.x/okio/okio/-buffered-sink/buffer/","text":"okio / okio / BufferedSink / buffer buffer \u00b6 (js, jvm, native) abstract val buffer: Buffer This sink\u2019s internal buffer. (jvm) abstract fun ~~buffer~~(): Buffer Deprecated: moved to val: use getBuffer() instead Returns this sink\u2019s internal buffer.","title":"buffer - Okio"},{"location":"2.x/okio/okio/-buffered-sink/buffer/#buffer","text":"(js, jvm, native) abstract val buffer: Buffer This sink\u2019s internal buffer. (jvm) abstract fun ~~buffer~~(): Buffer Deprecated: moved to val: use getBuffer() instead Returns this sink\u2019s internal buffer.","title":"buffer"},{"location":"2.x/okio/okio/-buffered-sink/emit-complete-segments/","text":"okio / okio / BufferedSink / emitCompleteSegments emitCompleteSegments \u00b6 (js, jvm, native) abstract fun emitCompleteSegments(): BufferedSink Writes complete segments to the underlying sink, if one exists. Like flush , but weaker. Use this to limit the memory held in the buffer to a single segment. Typically application code will not need to call this: it is only necessary when application code writes directly to this sink\u2019s buffer . BufferedSink b0 = new Buffer(); BufferedSink b1 = Okio.buffer(b0); BufferedSink b2 = Okio.buffer(b1); b2.buffer().write(new byte[20_000]); assertEquals(20_000, b2.buffer().size()); assertEquals( 0, b1.buffer().size()); assertEquals( 0, b0.buffer().size()); b2.emitCompleteSegments(); assertEquals( 3_616, b2.buffer().size()); assertEquals( 0, b1.buffer().size()); assertEquals(16_384, b0.buffer().size()); // This example assumes 8192 byte segments.","title":"emitCompleteSegments - Okio"},{"location":"2.x/okio/okio/-buffered-sink/emit-complete-segments/#emitcompletesegments","text":"(js, jvm, native) abstract fun emitCompleteSegments(): BufferedSink Writes complete segments to the underlying sink, if one exists. Like flush , but weaker. Use this to limit the memory held in the buffer to a single segment. Typically application code will not need to call this: it is only necessary when application code writes directly to this sink\u2019s buffer . BufferedSink b0 = new Buffer(); BufferedSink b1 = Okio.buffer(b0); BufferedSink b2 = Okio.buffer(b1); b2.buffer().write(new byte[20_000]); assertEquals(20_000, b2.buffer().size()); assertEquals( 0, b1.buffer().size()); assertEquals( 0, b0.buffer().size()); b2.emitCompleteSegments(); assertEquals( 3_616, b2.buffer().size()); assertEquals( 0, b1.buffer().size()); assertEquals(16_384, b0.buffer().size()); // This example assumes 8192 byte segments.","title":"emitCompleteSegments"},{"location":"2.x/okio/okio/-buffered-sink/emit/","text":"okio / okio / BufferedSink / emit emit \u00b6 (js, jvm, native) abstract fun emit(): BufferedSink Writes all buffered data to the underlying sink, if one exists. Like flush , but weaker. Call this before this buffered sink goes out of scope so that its data can reach its destination. BufferedSink b0 = new Buffer(); BufferedSink b1 = Okio.buffer(b0); BufferedSink b2 = Okio.buffer(b1); b2.writeUtf8(\"hello\"); assertEquals(5, b2.buffer().size()); assertEquals(0, b1.buffer().size()); assertEquals(0, b0.buffer().size()); b2.emit(); assertEquals(0, b2.buffer().size()); assertEquals(5, b1.buffer().size()); assertEquals(0, b0.buffer().size()); b1.emit(); assertEquals(0, b2.buffer().size()); assertEquals(0, b1.buffer().size()); assertEquals(5, b0.buffer().size());","title":"emit - Okio"},{"location":"2.x/okio/okio/-buffered-sink/emit/#emit","text":"(js, jvm, native) abstract fun emit(): BufferedSink Writes all buffered data to the underlying sink, if one exists. Like flush , but weaker. Call this before this buffered sink goes out of scope so that its data can reach its destination. BufferedSink b0 = new Buffer(); BufferedSink b1 = Okio.buffer(b0); BufferedSink b2 = Okio.buffer(b1); b2.writeUtf8(\"hello\"); assertEquals(5, b2.buffer().size()); assertEquals(0, b1.buffer().size()); assertEquals(0, b0.buffer().size()); b2.emit(); assertEquals(0, b2.buffer().size()); assertEquals(5, b1.buffer().size()); assertEquals(0, b0.buffer().size()); b1.emit(); assertEquals(0, b2.buffer().size()); assertEquals(0, b1.buffer().size()); assertEquals(5, b0.buffer().size());","title":"emit"},{"location":"2.x/okio/okio/-buffered-sink/flush/","text":"okio / okio / BufferedSink / flush flush \u00b6 (js, jvm) abstract fun flush(): Unit Writes all buffered data to the underlying sink, if one exists. Then that sink is recursively flushed which pushes data as far as possible towards its ultimate destination. Typically that destination is a network socket or file. BufferedSink b0 = new Buffer(); BufferedSink b1 = Okio.buffer(b0); BufferedSink b2 = Okio.buffer(b1); b2.writeUtf8(\"hello\"); assertEquals(5, b2.buffer().size()); assertEquals(0, b1.buffer().size()); assertEquals(0, b0.buffer().size()); b2.flush(); assertEquals(0, b2.buffer().size()); assertEquals(0, b1.buffer().size()); assertEquals(5, b0.buffer().size());","title":"flush - Okio"},{"location":"2.x/okio/okio/-buffered-sink/flush/#flush","text":"(js, jvm) abstract fun flush(): Unit Writes all buffered data to the underlying sink, if one exists. Then that sink is recursively flushed which pushes data as far as possible towards its ultimate destination. Typically that destination is a network socket or file. BufferedSink b0 = new Buffer(); BufferedSink b1 = Okio.buffer(b0); BufferedSink b2 = Okio.buffer(b1); b2.writeUtf8(\"hello\"); assertEquals(5, b2.buffer().size()); assertEquals(0, b1.buffer().size()); assertEquals(0, b0.buffer().size()); b2.flush(); assertEquals(0, b2.buffer().size()); assertEquals(0, b1.buffer().size()); assertEquals(5, b0.buffer().size());","title":"flush"},{"location":"2.x/okio/okio/-buffered-sink/output-stream/","text":"okio / okio / BufferedSink / outputStream outputStream \u00b6 (jvm) abstract fun outputStream(): OutputStream Returns an output stream that writes to this sink.","title":"outputStream - Okio"},{"location":"2.x/okio/okio/-buffered-sink/output-stream/#outputstream","text":"(jvm) abstract fun outputStream(): OutputStream Returns an output stream that writes to this sink.","title":"outputStream"},{"location":"2.x/okio/okio/-buffered-sink/write-all/","text":"okio / okio / BufferedSink / writeAll writeAll \u00b6 (js, jvm, native) abstract fun writeAll(source: Source ): Long Removes all bytes from source and appends them to this sink. Returns the number of bytes read which will be 0 if source is exhausted.","title":"writeAll - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-all/#writeall","text":"(js, jvm, native) abstract fun writeAll(source: Source ): Long Removes all bytes from source and appends them to this sink. Returns the number of bytes read which will be 0 if source is exhausted.","title":"writeAll"},{"location":"2.x/okio/okio/-buffered-sink/write-byte/","text":"okio / okio / BufferedSink / writeByte writeByte \u00b6 (js, jvm, native) abstract fun writeByte(b: Int ): BufferedSink Writes a byte to this sink.","title":"writeByte - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-byte/#writebyte","text":"(js, jvm, native) abstract fun writeByte(b: Int ): BufferedSink Writes a byte to this sink.","title":"writeByte"},{"location":"2.x/okio/okio/-buffered-sink/write-decimal-long/","text":"okio / okio / BufferedSink / writeDecimalLong writeDecimalLong \u00b6 (js, jvm, native) abstract fun writeDecimalLong(v: Long ): BufferedSink Writes a long to this sink in signed decimal form (i.e., as a string in base 10). Buffer buffer = new Buffer(); buffer.writeDecimalLong(8675309L); buffer.writeByte(' '); buffer.writeDecimalLong(-123L); buffer.writeByte(' '); buffer.writeDecimalLong(1L); assertEquals(\"8675309 -123 1\", buffer.readUtf8());","title":"writeDecimalLong - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-decimal-long/#writedecimallong","text":"(js, jvm, native) abstract fun writeDecimalLong(v: Long ): BufferedSink Writes a long to this sink in signed decimal form (i.e., as a string in base 10). Buffer buffer = new Buffer(); buffer.writeDecimalLong(8675309L); buffer.writeByte(' '); buffer.writeDecimalLong(-123L); buffer.writeByte(' '); buffer.writeDecimalLong(1L); assertEquals(\"8675309 -123 1\", buffer.readUtf8());","title":"writeDecimalLong"},{"location":"2.x/okio/okio/-buffered-sink/write-hexadecimal-unsigned-long/","text":"okio / okio / BufferedSink / writeHexadecimalUnsignedLong writeHexadecimalUnsignedLong \u00b6 (js, jvm, native) abstract fun writeHexadecimalUnsignedLong(v: Long ): BufferedSink Writes a long to this sink in hexadecimal form (i.e., as a string in base 16). Buffer buffer = new Buffer(); buffer.writeHexadecimalUnsignedLong(65535L); buffer.writeByte(' '); buffer.writeHexadecimalUnsignedLong(0xcafebabeL); buffer.writeByte(' '); buffer.writeHexadecimalUnsignedLong(0x10L); assertEquals(\"ffff cafebabe 10\", buffer.readUtf8());","title":"writeHexadecimalUnsignedLong - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-hexadecimal-unsigned-long/#writehexadecimalunsignedlong","text":"(js, jvm, native) abstract fun writeHexadecimalUnsignedLong(v: Long ): BufferedSink Writes a long to this sink in hexadecimal form (i.e., as a string in base 16). Buffer buffer = new Buffer(); buffer.writeHexadecimalUnsignedLong(65535L); buffer.writeByte(' '); buffer.writeHexadecimalUnsignedLong(0xcafebabeL); buffer.writeByte(' '); buffer.writeHexadecimalUnsignedLong(0x10L); assertEquals(\"ffff cafebabe 10\", buffer.readUtf8());","title":"writeHexadecimalUnsignedLong"},{"location":"2.x/okio/okio/-buffered-sink/write-int-le/","text":"okio / okio / BufferedSink / writeIntLe writeIntLe \u00b6 (js, jvm, native) abstract fun writeIntLe(i: Int ): BufferedSink Writes a little-endian int to this sink using four bytes. Buffer buffer = new Buffer(); buffer.writeIntLe(2147483647); buffer.writeIntLe(15); assertEquals(8, buffer.size()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeIntLe - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-int-le/#writeintle","text":"(js, jvm, native) abstract fun writeIntLe(i: Int ): BufferedSink Writes a little-endian int to this sink using four bytes. Buffer buffer = new Buffer(); buffer.writeIntLe(2147483647); buffer.writeIntLe(15); assertEquals(8, buffer.size()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeIntLe"},{"location":"2.x/okio/okio/-buffered-sink/write-int/","text":"okio / okio / BufferedSink / writeInt writeInt \u00b6 (js, jvm, native) abstract fun writeInt(i: Int ): BufferedSink Writes a big-endian int to this sink using four bytes. Buffer buffer = new Buffer(); buffer.writeInt(2147483647); buffer.writeInt(15); assertEquals(8, buffer.size()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeInt - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-int/#writeint","text":"(js, jvm, native) abstract fun writeInt(i: Int ): BufferedSink Writes a big-endian int to this sink using four bytes. Buffer buffer = new Buffer(); buffer.writeInt(2147483647); buffer.writeInt(15); assertEquals(8, buffer.size()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeInt"},{"location":"2.x/okio/okio/-buffered-sink/write-long-le/","text":"okio / okio / BufferedSink / writeLongLe writeLongLe \u00b6 (js, jvm, native) abstract fun writeLongLe(v: Long ): BufferedSink Writes a little-endian long to this sink using eight bytes. Buffer buffer = new Buffer(); buffer.writeLongLe(9223372036854775807L); buffer.writeLongLe(15); assertEquals(16, buffer.size()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeLongLe - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-long-le/#writelongle","text":"(js, jvm, native) abstract fun writeLongLe(v: Long ): BufferedSink Writes a little-endian long to this sink using eight bytes. Buffer buffer = new Buffer(); buffer.writeLongLe(9223372036854775807L); buffer.writeLongLe(15); assertEquals(16, buffer.size()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeLongLe"},{"location":"2.x/okio/okio/-buffered-sink/write-long/","text":"okio / okio / BufferedSink / writeLong writeLong \u00b6 (js, jvm, native) abstract fun writeLong(v: Long ): BufferedSink Writes a big-endian long to this sink using eight bytes. Buffer buffer = new Buffer(); buffer.writeLong(9223372036854775807L); buffer.writeLong(15); assertEquals(16, buffer.size()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeLong - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-long/#writelong","text":"(js, jvm, native) abstract fun writeLong(v: Long ): BufferedSink Writes a big-endian long to this sink using eight bytes. Buffer buffer = new Buffer(); buffer.writeLong(9223372036854775807L); buffer.writeLong(15); assertEquals(16, buffer.size()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeLong"},{"location":"2.x/okio/okio/-buffered-sink/write-short-le/","text":"okio / okio / BufferedSink / writeShortLe writeShortLe \u00b6 (js, jvm, native) abstract fun writeShortLe(s: Int ): BufferedSink Writes a little-endian short to this sink using two bytes. Buffer buffer = new Buffer(); buffer.writeShortLe(32767); buffer.writeShortLe(15); assertEquals(4, buffer.size()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeShortLe - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-short-le/#writeshortle","text":"(js, jvm, native) abstract fun writeShortLe(s: Int ): BufferedSink Writes a little-endian short to this sink using two bytes. Buffer buffer = new Buffer(); buffer.writeShortLe(32767); buffer.writeShortLe(15); assertEquals(4, buffer.size()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeShortLe"},{"location":"2.x/okio/okio/-buffered-sink/write-short/","text":"okio / okio / BufferedSink / writeShort writeShort \u00b6 (js, jvm, native) abstract fun writeShort(s: Int ): BufferedSink Writes a big-endian short to this sink using two bytes. Buffer buffer = new Buffer(); buffer.writeShort(32767); buffer.writeShort(15); assertEquals(4, buffer.size()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeShort - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-short/#writeshort","text":"(js, jvm, native) abstract fun writeShort(s: Int ): BufferedSink Writes a big-endian short to this sink using two bytes. Buffer buffer = new Buffer(); buffer.writeShort(32767); buffer.writeShort(15); assertEquals(4, buffer.size()); assertEquals((byte) 0x7f, buffer.readByte()); assertEquals((byte) 0xff, buffer.readByte()); assertEquals((byte) 0x00, buffer.readByte()); assertEquals((byte) 0x0f, buffer.readByte()); assertEquals(0, buffer.size());","title":"writeShort"},{"location":"2.x/okio/okio/-buffered-sink/write-string/","text":"okio / okio / BufferedSink / writeString writeString \u00b6 (jvm) abstract fun writeString(string: String , charset: Charset ): BufferedSink abstract fun writeString(string: String , beginIndex: Int , endIndex: Int , charset: Charset ): BufferedSink","title":"writeString - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-string/#writestring","text":"(jvm) abstract fun writeString(string: String , charset: Charset ): BufferedSink abstract fun writeString(string: String , beginIndex: Int , endIndex: Int , charset: Charset ): BufferedSink","title":"writeString"},{"location":"2.x/okio/okio/-buffered-sink/write-utf8-code-point/","text":"okio / okio / BufferedSink / writeUtf8CodePoint writeUtf8CodePoint \u00b6 (js, jvm, native) abstract fun writeUtf8CodePoint(codePoint: Int ): BufferedSink Encodes codePoint in UTF-8 and writes it to this sink.","title":"writeUtf8CodePoint - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-utf8-code-point/#writeutf8codepoint","text":"(js, jvm, native) abstract fun writeUtf8CodePoint(codePoint: Int ): BufferedSink Encodes codePoint in UTF-8 and writes it to this sink.","title":"writeUtf8CodePoint"},{"location":"2.x/okio/okio/-buffered-sink/write-utf8/","text":"okio / okio / BufferedSink / writeUtf8 writeUtf8 \u00b6 (js, jvm, native) abstract fun writeUtf8(string: String ): BufferedSink Encodes string in UTF-8 and writes it to this sink. Buffer buffer = new Buffer(); buffer.writeUtf8(\"Uh uh uh!\"); buffer.writeByte(' '); buffer.writeUtf8(\"You didn't say the magic word!\"); assertEquals(\"Uh uh uh! You didn't say the magic word!\", buffer.readUtf8()); (js, jvm, native) abstract fun writeUtf8(string: String , beginIndex: Int , endIndex: Int ): BufferedSink Encodes the characters at beginIndex up to endIndex from string in UTF-8 and writes it to this sink. Buffer buffer = new Buffer(); buffer.writeUtf8(\"I'm a hacker!\\n\", 6, 12); buffer.writeByte(' '); buffer.writeUtf8(\"That's what I said: you're a nerd.\\n\", 29, 33); buffer.writeByte(' '); buffer.writeUtf8(\"I prefer to be called a hacker!\\n\", 24, 31); assertEquals(\"hacker nerd hacker!\", buffer.readUtf8());","title":"writeUtf8 - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-utf8/#writeutf8","text":"(js, jvm, native) abstract fun writeUtf8(string: String ): BufferedSink Encodes string in UTF-8 and writes it to this sink. Buffer buffer = new Buffer(); buffer.writeUtf8(\"Uh uh uh!\"); buffer.writeByte(' '); buffer.writeUtf8(\"You didn't say the magic word!\"); assertEquals(\"Uh uh uh! You didn't say the magic word!\", buffer.readUtf8()); (js, jvm, native) abstract fun writeUtf8(string: String , beginIndex: Int , endIndex: Int ): BufferedSink Encodes the characters at beginIndex up to endIndex from string in UTF-8 and writes it to this sink. Buffer buffer = new Buffer(); buffer.writeUtf8(\"I'm a hacker!\\n\", 6, 12); buffer.writeByte(' '); buffer.writeUtf8(\"That's what I said: you're a nerd.\\n\", 29, 33); buffer.writeByte(' '); buffer.writeUtf8(\"I prefer to be called a hacker!\\n\", 24, 31); assertEquals(\"hacker nerd hacker!\", buffer.readUtf8());","title":"writeUtf8"},{"location":"2.x/okio/okio/-buffered-sink/write/","text":"okio / okio / BufferedSink / write write \u00b6 (js, jvm, native) abstract fun write(byteString: ByteString ): BufferedSink abstract fun write(byteString: ByteString , offset: Int , byteCount: Int ): BufferedSink (js, jvm, native) abstract fun write(source: ByteArray ): BufferedSink Like OutputStream.write , this writes a complete byte array to this sink. (js, jvm, native) abstract fun write(source: ByteArray , offset: Int , byteCount: Int ): BufferedSink Like OutputStream.write , this writes byteCount bytes of source , starting at offset . (js, jvm, native) abstract fun write(source: Source , byteCount: Long ): BufferedSink Removes byteCount bytes from source and appends them to this sink.","title":"write - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write/#write","text":"(js, jvm, native) abstract fun write(byteString: ByteString ): BufferedSink abstract fun write(byteString: ByteString , offset: Int , byteCount: Int ): BufferedSink (js, jvm, native) abstract fun write(source: ByteArray ): BufferedSink Like OutputStream.write , this writes a complete byte array to this sink. (js, jvm, native) abstract fun write(source: ByteArray , offset: Int , byteCount: Int ): BufferedSink Like OutputStream.write , this writes byteCount bytes of source , starting at offset . (js, jvm, native) abstract fun write(source: Source , byteCount: Long ): BufferedSink Removes byteCount bytes from source and appends them to this sink.","title":"write"},{"location":"2.x/okio/okio/-buffered-source/","text":"okio / okio / BufferedSource BufferedSource \u00b6 (js, jvm, native) interface BufferedSource : Source A source that keeps a buffer internally so that callers can do small reads without a performance penalty. It also allows clients to read ahead, buffering as much as necessary before consuming input. Properties \u00b6 Name Summary (js, jvm, native) buffer This source\u2019s internal buffer. abstract val buffer: Buffer Functions \u00b6 Name Summary (jvm) buffer Returns this source\u2019s internal buffer. abstract fun ~~buffer~~(): Buffer (js, jvm, native) exhausted Returns true if there are no more bytes in this source. This will block until there are bytes to read or the source is definitely exhausted. abstract fun exhausted(): Boolean (js, jvm, native) indexOf Equivalent to indexOf(b, 0) . abstract fun indexOf(b: Byte ): Long Returns the index of the first b in the buffer at or after fromIndex . This expands the buffer as necessary until b is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested byte is found. abstract fun indexOf(b: Byte , fromIndex: Long ): Long Returns the index of b if it is found in the range of fromIndex inclusive to toIndex exclusive. If b isn\u2019t found, or if fromIndex == toIndex , then -1 is returned. abstract fun indexOf(b: Byte , fromIndex: Long , toIndex: Long ): Long Equivalent to indexOf(bytes, 0) . abstract fun indexOf(bytes: ByteString ): Long Returns the index of the first match for bytes in the buffer at or after fromIndex . This expands the buffer as necessary until bytes is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested bytes are found. abstract fun indexOf(bytes: ByteString , fromIndex: Long ): Long (js, jvm, native) indexOfElement Equivalent to indexOfElement(targetBytes, 0) . abstract fun indexOfElement(targetBytes: ByteString ): Long Returns the first index in this buffer that is at or after fromIndex and that contains any of the bytes in targetBytes . This expands the buffer as necessary until a target byte is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested byte is found. abstract fun indexOfElement(targetBytes: ByteString , fromIndex: Long ): Long (jvm) inputStream Returns an input stream that reads from this source. abstract fun inputStream(): InputStream (js, jvm, native) peek Returns a new BufferedSource that can read data from this BufferedSource without consuming it. The returned source becomes invalid once this source is next read or closed. abstract fun peek(): BufferedSource (js, jvm, native) rangeEquals Returns true if the bytes at offset in this source equal bytes . This expands the buffer as necessary until a byte does not match, all bytes are matched, or if the stream is exhausted before enough bytes could determine a match. abstract fun rangeEquals(offset: Long , bytes: ByteString ): Boolean Returns true if byteCount bytes at offset in this source equal bytes at bytesOffset . This expands the buffer as necessary until a byte does not match, all bytes are matched, or if the stream is exhausted before enough bytes could determine a match. abstract fun rangeEquals(offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean (js, jvm, native) read Removes up to sink.length bytes from this and copies them into sink . Returns the number of bytes read, or -1 if this source is exhausted. abstract fun read(sink: ByteArray ): Int Removes up to byteCount bytes from this and copies them into sink at offset . Returns the number of bytes read, or -1 if this source is exhausted. abstract fun read(sink: ByteArray , offset: Int , byteCount: Int ): Int (js, jvm, native) readAll Removes all bytes from this and appends them to sink . Returns the total number of bytes written to sink which will be 0 if this is exhausted. abstract fun readAll(sink: Sink ): Long (js, jvm, native) readByte Removes a byte from this source and returns it. abstract fun readByte(): Byte (js, jvm, native) readByteArray Removes all bytes from this and returns them as a byte array. abstract fun readByteArray(): ByteArray Removes byteCount bytes from this and returns them as a byte array. abstract fun readByteArray(byteCount: Long ): ByteArray (js, jvm, native) readByteString Removes all bytes from this and returns them as a byte string. abstract fun readByteString(): ByteString Removes byteCount bytes from this and returns them as a byte string. abstract fun readByteString(byteCount: Long ): ByteString (js, jvm, native) readDecimalLong Reads a long from this source in signed decimal form (i.e., as a string in base 10 with optional leading \u2018-\u2018). This will iterate until a non-digit character is found. abstract fun readDecimalLong(): Long (js, jvm, native) readFully Removes exactly sink.length bytes from this and copies them into sink . Throws an java.io.EOFException if the requested number of bytes cannot be read. abstract fun readFully(sink: ByteArray ): Unit Removes exactly byteCount bytes from this and appends them to sink . Throws an java.io.EOFException if the requested number of bytes cannot be read. abstract fun readFully(sink: Buffer , byteCount: Long ): Unit (js, jvm, native) readHexadecimalUnsignedLong Reads a long form this source in hexadecimal form (i.e., as a string in base 16). This will iterate until a non-hexadecimal character is found. abstract fun readHexadecimalUnsignedLong(): Long (js, jvm, native) readInt Removes four bytes from this source and returns a big-endian int. abstract fun readInt(): Int (js, jvm, native) readIntLe Removes four bytes from this source and returns a little-endian int. abstract fun readIntLe(): Int (js, jvm, native) readLong Removes eight bytes from this source and returns a big-endian long. abstract fun readLong(): Long (js, jvm, native) readLongLe Removes eight bytes from this source and returns a little-endian long. abstract fun readLongLe(): Long (js, jvm, native) readShort Removes two bytes from this source and returns a big-endian short. abstract fun readShort(): Short (js, jvm, native) readShortLe Removes two bytes from this source and returns a little-endian short. abstract fun readShortLe(): Short (jvm) readString Removes all bytes from this, decodes them as charset , and returns the string. abstract fun readString(charset: Charset ): String Removes byteCount bytes from this, decodes them as charset , and returns the string. abstract fun readString(byteCount: Long , charset: Charset ): String (js, jvm, native) readUtf8 Removes all bytes from this, decodes them as UTF-8, and returns the string. Returns the empty string if this source is empty. abstract fun readUtf8(): String Removes byteCount bytes from this, decodes them as UTF-8, and returns the string. abstract fun readUtf8(byteCount: Long ): String (js, jvm, native) readUtf8CodePoint Removes and returns a single UTF-8 code point, reading between 1 and 4 bytes as necessary. abstract fun readUtf8CodePoint(): Int (js, jvm, native) readUtf8Line Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. abstract fun readUtf8Line(): String ? (js, jvm, native) readUtf8LineStrict Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. abstract fun readUtf8LineStrict(): String Like readUtf8LineStrict , except this allows the caller to specify the longest allowed match. Use this to protect against streams that may not include \"\\n\" or \"\\r\\n\" . abstract fun readUtf8LineStrict(limit: Long ): String (js, jvm, native) request Returns true when the buffer contains at least byteCount bytes, expanding it as necessary. Returns false if the source is exhausted before the requested bytes can be read. abstract fun request(byteCount: Long ): Boolean (js, jvm, native) require Returns when the buffer contains at least byteCount bytes. Throws an java.io.EOFException if the source is exhausted before the required bytes can be read. abstract fun require(byteCount: Long ): Unit select (native) abstract fun select(options: <ERROR CLASS>): Int (js, jvm) Finds the first string in options that is a prefix of this buffer, consumes it from this buffer, and returns its index. If no byte string in options is a prefix of this buffer this returns -1 and no bytes are consumed. abstract fun select(options: Options ): Int (js, jvm, native) skip Reads and discards byteCount bytes from this source. Throws an java.io.EOFException if the source is exhausted before the requested bytes can be skipped. abstract fun skip(byteCount: Long ): Unit Extension Functions \u00b6 Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource Inheritors \u00b6 Name Summary (js, jvm, native) Buffer A collection of bytes in memory. class Buffer : BufferedSource , BufferedSink","title":"BufferedSource - Okio"},{"location":"2.x/okio/okio/-buffered-source/#bufferedsource","text":"(js, jvm, native) interface BufferedSource : Source A source that keeps a buffer internally so that callers can do small reads without a performance penalty. It also allows clients to read ahead, buffering as much as necessary before consuming input.","title":"BufferedSource"},{"location":"2.x/okio/okio/-buffered-source/#properties","text":"Name Summary (js, jvm, native) buffer This source\u2019s internal buffer. abstract val buffer: Buffer","title":"Properties"},{"location":"2.x/okio/okio/-buffered-source/#functions","text":"Name Summary (jvm) buffer Returns this source\u2019s internal buffer. abstract fun ~~buffer~~(): Buffer (js, jvm, native) exhausted Returns true if there are no more bytes in this source. This will block until there are bytes to read or the source is definitely exhausted. abstract fun exhausted(): Boolean (js, jvm, native) indexOf Equivalent to indexOf(b, 0) . abstract fun indexOf(b: Byte ): Long Returns the index of the first b in the buffer at or after fromIndex . This expands the buffer as necessary until b is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested byte is found. abstract fun indexOf(b: Byte , fromIndex: Long ): Long Returns the index of b if it is found in the range of fromIndex inclusive to toIndex exclusive. If b isn\u2019t found, or if fromIndex == toIndex , then -1 is returned. abstract fun indexOf(b: Byte , fromIndex: Long , toIndex: Long ): Long Equivalent to indexOf(bytes, 0) . abstract fun indexOf(bytes: ByteString ): Long Returns the index of the first match for bytes in the buffer at or after fromIndex . This expands the buffer as necessary until bytes is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested bytes are found. abstract fun indexOf(bytes: ByteString , fromIndex: Long ): Long (js, jvm, native) indexOfElement Equivalent to indexOfElement(targetBytes, 0) . abstract fun indexOfElement(targetBytes: ByteString ): Long Returns the first index in this buffer that is at or after fromIndex and that contains any of the bytes in targetBytes . This expands the buffer as necessary until a target byte is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested byte is found. abstract fun indexOfElement(targetBytes: ByteString , fromIndex: Long ): Long (jvm) inputStream Returns an input stream that reads from this source. abstract fun inputStream(): InputStream (js, jvm, native) peek Returns a new BufferedSource that can read data from this BufferedSource without consuming it. The returned source becomes invalid once this source is next read or closed. abstract fun peek(): BufferedSource (js, jvm, native) rangeEquals Returns true if the bytes at offset in this source equal bytes . This expands the buffer as necessary until a byte does not match, all bytes are matched, or if the stream is exhausted before enough bytes could determine a match. abstract fun rangeEquals(offset: Long , bytes: ByteString ): Boolean Returns true if byteCount bytes at offset in this source equal bytes at bytesOffset . This expands the buffer as necessary until a byte does not match, all bytes are matched, or if the stream is exhausted before enough bytes could determine a match. abstract fun rangeEquals(offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean (js, jvm, native) read Removes up to sink.length bytes from this and copies them into sink . Returns the number of bytes read, or -1 if this source is exhausted. abstract fun read(sink: ByteArray ): Int Removes up to byteCount bytes from this and copies them into sink at offset . Returns the number of bytes read, or -1 if this source is exhausted. abstract fun read(sink: ByteArray , offset: Int , byteCount: Int ): Int (js, jvm, native) readAll Removes all bytes from this and appends them to sink . Returns the total number of bytes written to sink which will be 0 if this is exhausted. abstract fun readAll(sink: Sink ): Long (js, jvm, native) readByte Removes a byte from this source and returns it. abstract fun readByte(): Byte (js, jvm, native) readByteArray Removes all bytes from this and returns them as a byte array. abstract fun readByteArray(): ByteArray Removes byteCount bytes from this and returns them as a byte array. abstract fun readByteArray(byteCount: Long ): ByteArray (js, jvm, native) readByteString Removes all bytes from this and returns them as a byte string. abstract fun readByteString(): ByteString Removes byteCount bytes from this and returns them as a byte string. abstract fun readByteString(byteCount: Long ): ByteString (js, jvm, native) readDecimalLong Reads a long from this source in signed decimal form (i.e., as a string in base 10 with optional leading \u2018-\u2018). This will iterate until a non-digit character is found. abstract fun readDecimalLong(): Long (js, jvm, native) readFully Removes exactly sink.length bytes from this and copies them into sink . Throws an java.io.EOFException if the requested number of bytes cannot be read. abstract fun readFully(sink: ByteArray ): Unit Removes exactly byteCount bytes from this and appends them to sink . Throws an java.io.EOFException if the requested number of bytes cannot be read. abstract fun readFully(sink: Buffer , byteCount: Long ): Unit (js, jvm, native) readHexadecimalUnsignedLong Reads a long form this source in hexadecimal form (i.e., as a string in base 16). This will iterate until a non-hexadecimal character is found. abstract fun readHexadecimalUnsignedLong(): Long (js, jvm, native) readInt Removes four bytes from this source and returns a big-endian int. abstract fun readInt(): Int (js, jvm, native) readIntLe Removes four bytes from this source and returns a little-endian int. abstract fun readIntLe(): Int (js, jvm, native) readLong Removes eight bytes from this source and returns a big-endian long. abstract fun readLong(): Long (js, jvm, native) readLongLe Removes eight bytes from this source and returns a little-endian long. abstract fun readLongLe(): Long (js, jvm, native) readShort Removes two bytes from this source and returns a big-endian short. abstract fun readShort(): Short (js, jvm, native) readShortLe Removes two bytes from this source and returns a little-endian short. abstract fun readShortLe(): Short (jvm) readString Removes all bytes from this, decodes them as charset , and returns the string. abstract fun readString(charset: Charset ): String Removes byteCount bytes from this, decodes them as charset , and returns the string. abstract fun readString(byteCount: Long , charset: Charset ): String (js, jvm, native) readUtf8 Removes all bytes from this, decodes them as UTF-8, and returns the string. Returns the empty string if this source is empty. abstract fun readUtf8(): String Removes byteCount bytes from this, decodes them as UTF-8, and returns the string. abstract fun readUtf8(byteCount: Long ): String (js, jvm, native) readUtf8CodePoint Removes and returns a single UTF-8 code point, reading between 1 and 4 bytes as necessary. abstract fun readUtf8CodePoint(): Int (js, jvm, native) readUtf8Line Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. abstract fun readUtf8Line(): String ? (js, jvm, native) readUtf8LineStrict Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. abstract fun readUtf8LineStrict(): String Like readUtf8LineStrict , except this allows the caller to specify the longest allowed match. Use this to protect against streams that may not include \"\\n\" or \"\\r\\n\" . abstract fun readUtf8LineStrict(limit: Long ): String (js, jvm, native) request Returns true when the buffer contains at least byteCount bytes, expanding it as necessary. Returns false if the source is exhausted before the requested bytes can be read. abstract fun request(byteCount: Long ): Boolean (js, jvm, native) require Returns when the buffer contains at least byteCount bytes. Throws an java.io.EOFException if the source is exhausted before the required bytes can be read. abstract fun require(byteCount: Long ): Unit select (native) abstract fun select(options: <ERROR CLASS>): Int (js, jvm) Finds the first string in options that is a prefix of this buffer, consumes it from this buffer, and returns its index. If no byte string in options is a prefix of this buffer this returns -1 and no bytes are consumed. abstract fun select(options: Options ): Int (js, jvm, native) skip Reads and discards byteCount bytes from this source. Throws an java.io.EOFException if the source is exhausted before the requested bytes can be skipped. abstract fun skip(byteCount: Long ): Unit","title":"Functions"},{"location":"2.x/okio/okio/-buffered-source/#extension-functions","text":"Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"Extension Functions"},{"location":"2.x/okio/okio/-buffered-source/#inheritors","text":"Name Summary (js, jvm, native) Buffer A collection of bytes in memory. class Buffer : BufferedSource , BufferedSink","title":"Inheritors"},{"location":"2.x/okio/okio/-buffered-source/buffer/","text":"okio / okio / BufferedSource / buffer buffer \u00b6 (js, jvm, native) abstract val buffer: Buffer This source\u2019s internal buffer. (jvm) abstract fun ~~buffer~~(): Buffer Deprecated: moved to val: use getBuffer() instead Returns this source\u2019s internal buffer.","title":"buffer - Okio"},{"location":"2.x/okio/okio/-buffered-source/buffer/#buffer","text":"(js, jvm, native) abstract val buffer: Buffer This source\u2019s internal buffer. (jvm) abstract fun ~~buffer~~(): Buffer Deprecated: moved to val: use getBuffer() instead Returns this source\u2019s internal buffer.","title":"buffer"},{"location":"2.x/okio/okio/-buffered-source/exhausted/","text":"okio / okio / BufferedSource / exhausted exhausted \u00b6 (js, jvm, native) abstract fun exhausted(): Boolean Returns true if there are no more bytes in this source. This will block until there are bytes to read or the source is definitely exhausted.","title":"exhausted - Okio"},{"location":"2.x/okio/okio/-buffered-source/exhausted/#exhausted","text":"(js, jvm, native) abstract fun exhausted(): Boolean Returns true if there are no more bytes in this source. This will block until there are bytes to read or the source is definitely exhausted.","title":"exhausted"},{"location":"2.x/okio/okio/-buffered-source/index-of-element/","text":"okio / okio / BufferedSource / indexOfElement indexOfElement \u00b6 (js, jvm, native) abstract fun indexOfElement(targetBytes: ByteString ): Long Equivalent to indexOfElement(targetBytes, 0) . (js, jvm, native) abstract fun indexOfElement(targetBytes: ByteString , fromIndex: Long ): Long Returns the first index in this buffer that is at or after fromIndex and that contains any of the bytes in targetBytes . This expands the buffer as necessary until a target byte is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested byte is found. ByteString ANY_VOWEL = ByteString.encodeUtf8(\"AEOIUaeoiu\"); Buffer buffer = new Buffer(); buffer.writeUtf8(\"Dr. Alan Grant\"); assertEquals(4, buffer.indexOfElement(ANY_VOWEL)); // 'A' in 'Alan'. assertEquals(11, buffer.indexOfElement(ANY_VOWEL, 9)); // 'a' in 'Grant'.","title":"indexOfElement - Okio"},{"location":"2.x/okio/okio/-buffered-source/index-of-element/#indexofelement","text":"(js, jvm, native) abstract fun indexOfElement(targetBytes: ByteString ): Long Equivalent to indexOfElement(targetBytes, 0) . (js, jvm, native) abstract fun indexOfElement(targetBytes: ByteString , fromIndex: Long ): Long Returns the first index in this buffer that is at or after fromIndex and that contains any of the bytes in targetBytes . This expands the buffer as necessary until a target byte is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested byte is found. ByteString ANY_VOWEL = ByteString.encodeUtf8(\"AEOIUaeoiu\"); Buffer buffer = new Buffer(); buffer.writeUtf8(\"Dr. Alan Grant\"); assertEquals(4, buffer.indexOfElement(ANY_VOWEL)); // 'A' in 'Alan'. assertEquals(11, buffer.indexOfElement(ANY_VOWEL, 9)); // 'a' in 'Grant'.","title":"indexOfElement"},{"location":"2.x/okio/okio/-buffered-source/index-of/","text":"okio / okio / BufferedSource / indexOf indexOf \u00b6 (js, jvm, native) abstract fun indexOf(b: Byte ): Long Equivalent to indexOf(b, 0) . (js, jvm, native) abstract fun indexOf(b: Byte , fromIndex: Long ): Long Returns the index of the first b in the buffer at or after fromIndex . This expands the buffer as necessary until b is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested byte is found. Buffer buffer = new Buffer(); buffer.writeUtf8(\"Don't move! He can't see us if we don't move.\"); byte m = 'm'; assertEquals(6, buffer.indexOf(m)); assertEquals(40, buffer.indexOf(m, 12)); (js, jvm, native) abstract fun indexOf(b: Byte , fromIndex: Long , toIndex: Long ): Long Returns the index of b if it is found in the range of fromIndex inclusive to toIndex exclusive. If b isn\u2019t found, or if fromIndex == toIndex , then -1 is returned. The scan terminates at either toIndex or the end of the buffer, whichever comes first. The maximum number of bytes scanned is toIndex-fromIndex . (js, jvm, native) abstract fun indexOf(bytes: ByteString ): Long Equivalent to indexOf(bytes, 0) . (js, jvm, native) abstract fun indexOf(bytes: ByteString , fromIndex: Long ): Long Returns the index of the first match for bytes in the buffer at or after fromIndex . This expands the buffer as necessary until bytes is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested bytes are found. ByteString MOVE = ByteString.encodeUtf8(\"move\"); Buffer buffer = new Buffer(); buffer.writeUtf8(\"Don't move! He can't see us if we don't move.\"); assertEquals(6, buffer.indexOf(MOVE)); assertEquals(40, buffer.indexOf(MOVE, 12));","title":"indexOf - Okio"},{"location":"2.x/okio/okio/-buffered-source/index-of/#indexof","text":"(js, jvm, native) abstract fun indexOf(b: Byte ): Long Equivalent to indexOf(b, 0) . (js, jvm, native) abstract fun indexOf(b: Byte , fromIndex: Long ): Long Returns the index of the first b in the buffer at or after fromIndex . This expands the buffer as necessary until b is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested byte is found. Buffer buffer = new Buffer(); buffer.writeUtf8(\"Don't move! He can't see us if we don't move.\"); byte m = 'm'; assertEquals(6, buffer.indexOf(m)); assertEquals(40, buffer.indexOf(m, 12)); (js, jvm, native) abstract fun indexOf(b: Byte , fromIndex: Long , toIndex: Long ): Long Returns the index of b if it is found in the range of fromIndex inclusive to toIndex exclusive. If b isn\u2019t found, or if fromIndex == toIndex , then -1 is returned. The scan terminates at either toIndex or the end of the buffer, whichever comes first. The maximum number of bytes scanned is toIndex-fromIndex . (js, jvm, native) abstract fun indexOf(bytes: ByteString ): Long Equivalent to indexOf(bytes, 0) . (js, jvm, native) abstract fun indexOf(bytes: ByteString , fromIndex: Long ): Long Returns the index of the first match for bytes in the buffer at or after fromIndex . This expands the buffer as necessary until bytes is found. This reads an unbounded number of bytes into the buffer. Returns -1 if the stream is exhausted before the requested bytes are found. ByteString MOVE = ByteString.encodeUtf8(\"move\"); Buffer buffer = new Buffer(); buffer.writeUtf8(\"Don't move! He can't see us if we don't move.\"); assertEquals(6, buffer.indexOf(MOVE)); assertEquals(40, buffer.indexOf(MOVE, 12));","title":"indexOf"},{"location":"2.x/okio/okio/-buffered-source/input-stream/","text":"okio / okio / BufferedSource / inputStream inputStream \u00b6 (jvm) abstract fun inputStream(): InputStream Returns an input stream that reads from this source.","title":"inputStream - Okio"},{"location":"2.x/okio/okio/-buffered-source/input-stream/#inputstream","text":"(jvm) abstract fun inputStream(): InputStream Returns an input stream that reads from this source.","title":"inputStream"},{"location":"2.x/okio/okio/-buffered-source/peek/","text":"okio / okio / BufferedSource / peek peek \u00b6 (js, jvm, native) abstract fun peek(): BufferedSource Returns a new BufferedSource that can read data from this BufferedSource without consuming it. The returned source becomes invalid once this source is next read or closed. For example, we can use peek() to lookahead and read the same data multiple times. val buffer = Buffer() buffer.writeUtf8(\"abcdefghi\") buffer.readUtf8(3) // returns \"abc\", buffer contains \"defghi\" val peek = buffer.peek() peek.readUtf8(3) // returns \"def\", buffer contains \"defghi\" peek.readUtf8(3) // returns \"ghi\", buffer contains \"defghi\" buffer.readUtf8(3) // returns \"def\", buffer contains \"ghi\"","title":"peek - Okio"},{"location":"2.x/okio/okio/-buffered-source/peek/#peek","text":"(js, jvm, native) abstract fun peek(): BufferedSource Returns a new BufferedSource that can read data from this BufferedSource without consuming it. The returned source becomes invalid once this source is next read or closed. For example, we can use peek() to lookahead and read the same data multiple times. val buffer = Buffer() buffer.writeUtf8(\"abcdefghi\") buffer.readUtf8(3) // returns \"abc\", buffer contains \"defghi\" val peek = buffer.peek() peek.readUtf8(3) // returns \"def\", buffer contains \"defghi\" peek.readUtf8(3) // returns \"ghi\", buffer contains \"defghi\" buffer.readUtf8(3) // returns \"def\", buffer contains \"ghi\"","title":"peek"},{"location":"2.x/okio/okio/-buffered-source/range-equals/","text":"okio / okio / BufferedSource / rangeEquals rangeEquals \u00b6 (js, jvm, native) abstract fun rangeEquals(offset: Long , bytes: ByteString ): Boolean Returns true if the bytes at offset in this source equal bytes . This expands the buffer as necessary until a byte does not match, all bytes are matched, or if the stream is exhausted before enough bytes could determine a match. ByteString simonSays = ByteString.encodeUtf8(\"Simon says:\"); Buffer standOnOneLeg = new Buffer().writeUtf8(\"Simon says: Stand on one leg.\"); assertTrue(standOnOneLeg.rangeEquals(0, simonSays)); Buffer payMeMoney = new Buffer().writeUtf8(\"Pay me $1,000,000.\"); assertFalse(payMeMoney.rangeEquals(0, simonSays)); (js, jvm, native) abstract fun rangeEquals(offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean Returns true if byteCount bytes at offset in this source equal bytes at bytesOffset . This expands the buffer as necessary until a byte does not match, all bytes are matched, or if the stream is exhausted before enough bytes could determine a match.","title":"rangeEquals - Okio"},{"location":"2.x/okio/okio/-buffered-source/range-equals/#rangeequals","text":"(js, jvm, native) abstract fun rangeEquals(offset: Long , bytes: ByteString ): Boolean Returns true if the bytes at offset in this source equal bytes . This expands the buffer as necessary until a byte does not match, all bytes are matched, or if the stream is exhausted before enough bytes could determine a match. ByteString simonSays = ByteString.encodeUtf8(\"Simon says:\"); Buffer standOnOneLeg = new Buffer().writeUtf8(\"Simon says: Stand on one leg.\"); assertTrue(standOnOneLeg.rangeEquals(0, simonSays)); Buffer payMeMoney = new Buffer().writeUtf8(\"Pay me $1,000,000.\"); assertFalse(payMeMoney.rangeEquals(0, simonSays)); (js, jvm, native) abstract fun rangeEquals(offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean Returns true if byteCount bytes at offset in this source equal bytes at bytesOffset . This expands the buffer as necessary until a byte does not match, all bytes are matched, or if the stream is exhausted before enough bytes could determine a match.","title":"rangeEquals"},{"location":"2.x/okio/okio/-buffered-source/read-all/","text":"okio / okio / BufferedSource / readAll readAll \u00b6 (js, jvm, native) abstract fun readAll(sink: Sink ): Long Removes all bytes from this and appends them to sink . Returns the total number of bytes written to sink which will be 0 if this is exhausted.","title":"readAll - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-all/#readall","text":"(js, jvm, native) abstract fun readAll(sink: Sink ): Long Removes all bytes from this and appends them to sink . Returns the total number of bytes written to sink which will be 0 if this is exhausted.","title":"readAll"},{"location":"2.x/okio/okio/-buffered-source/read-byte-array/","text":"okio / okio / BufferedSource / readByteArray readByteArray \u00b6 (js, jvm, native) abstract fun readByteArray(): ByteArray Removes all bytes from this and returns them as a byte array. (js, jvm, native) abstract fun readByteArray(byteCount: Long ): ByteArray Removes byteCount bytes from this and returns them as a byte array.","title":"readByteArray - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-byte-array/#readbytearray","text":"(js, jvm, native) abstract fun readByteArray(): ByteArray Removes all bytes from this and returns them as a byte array. (js, jvm, native) abstract fun readByteArray(byteCount: Long ): ByteArray Removes byteCount bytes from this and returns them as a byte array.","title":"readByteArray"},{"location":"2.x/okio/okio/-buffered-source/read-byte-string/","text":"okio / okio / BufferedSource / readByteString readByteString \u00b6 (js, jvm, native) abstract fun readByteString(): ByteString Removes all bytes from this and returns them as a byte string. (js, jvm, native) abstract fun readByteString(byteCount: Long ): ByteString Removes byteCount bytes from this and returns them as a byte string.","title":"readByteString - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-byte-string/#readbytestring","text":"(js, jvm, native) abstract fun readByteString(): ByteString Removes all bytes from this and returns them as a byte string. (js, jvm, native) abstract fun readByteString(byteCount: Long ): ByteString Removes byteCount bytes from this and returns them as a byte string.","title":"readByteString"},{"location":"2.x/okio/okio/-buffered-source/read-byte/","text":"okio / okio / BufferedSource / readByte readByte \u00b6 (js, jvm, native) abstract fun readByte(): Byte Removes a byte from this source and returns it.","title":"readByte - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-byte/#readbyte","text":"(js, jvm, native) abstract fun readByte(): Byte Removes a byte from this source and returns it.","title":"readByte"},{"location":"2.x/okio/okio/-buffered-source/read-decimal-long/","text":"okio / okio / BufferedSource / readDecimalLong readDecimalLong \u00b6 (js, jvm, native) abstract fun readDecimalLong(): Long Reads a long from this source in signed decimal form (i.e., as a string in base 10 with optional leading \u2018-\u2018). This will iterate until a non-digit character is found. Buffer buffer = new Buffer() .writeUtf8(\"8675309 -123 00001\"); assertEquals(8675309L, buffer.readDecimalLong()); assertEquals(' ', buffer.readByte()); assertEquals(-123L, buffer.readDecimalLong()); assertEquals(' ', buffer.readByte()); assertEquals(1L, buffer.readDecimalLong()); Exceptions \u00b6 NumberFormatException - if the found digits do not fit into a long or a decimal number was not present.","title":"readDecimalLong - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-decimal-long/#readdecimallong","text":"(js, jvm, native) abstract fun readDecimalLong(): Long Reads a long from this source in signed decimal form (i.e., as a string in base 10 with optional leading \u2018-\u2018). This will iterate until a non-digit character is found. Buffer buffer = new Buffer() .writeUtf8(\"8675309 -123 00001\"); assertEquals(8675309L, buffer.readDecimalLong()); assertEquals(' ', buffer.readByte()); assertEquals(-123L, buffer.readDecimalLong()); assertEquals(' ', buffer.readByte()); assertEquals(1L, buffer.readDecimalLong());","title":"readDecimalLong"},{"location":"2.x/okio/okio/-buffered-source/read-decimal-long/#exceptions","text":"NumberFormatException - if the found digits do not fit into a long or a decimal number was not present.","title":"Exceptions"},{"location":"2.x/okio/okio/-buffered-source/read-fully/","text":"okio / okio / BufferedSource / readFully readFully \u00b6 (js, jvm, native) abstract fun readFully(sink: ByteArray ): Unit (js) Removes exactly sink.length bytes from this and copies them into sink . Throws an java.io.EOFException if the requested number of bytes cannot be read. (jvm) Removes exactly sink.length bytes from this and copies them into sink . Throws an java.io.EOFException if the requested number of bytes cannot be read. (js, jvm, native) abstract fun readFully(sink: Buffer , byteCount: Long ): Unit (js) Removes exactly byteCount bytes from this and appends them to sink . Throws an java.io.EOFException if the requested number of bytes cannot be read. (jvm) Removes exactly byteCount bytes from this and appends them to sink . Throws an java.io.EOFException if the requested number of bytes cannot be read.","title":"readFully - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-fully/#readfully","text":"(js, jvm, native) abstract fun readFully(sink: ByteArray ): Unit (js) Removes exactly sink.length bytes from this and copies them into sink . Throws an java.io.EOFException if the requested number of bytes cannot be read. (jvm) Removes exactly sink.length bytes from this and copies them into sink . Throws an java.io.EOFException if the requested number of bytes cannot be read. (js, jvm, native) abstract fun readFully(sink: Buffer , byteCount: Long ): Unit (js) Removes exactly byteCount bytes from this and appends them to sink . Throws an java.io.EOFException if the requested number of bytes cannot be read. (jvm) Removes exactly byteCount bytes from this and appends them to sink . Throws an java.io.EOFException if the requested number of bytes cannot be read.","title":"readFully"},{"location":"2.x/okio/okio/-buffered-source/read-hexadecimal-unsigned-long/","text":"okio / okio / BufferedSource / readHexadecimalUnsignedLong readHexadecimalUnsignedLong \u00b6 (js, jvm, native) abstract fun readHexadecimalUnsignedLong(): Long Reads a long form this source in hexadecimal form (i.e., as a string in base 16). This will iterate until a non-hexadecimal character is found. Buffer buffer = new Buffer() .writeUtf8(\"ffff CAFEBABE 10\"); assertEquals(65535L, buffer.readHexadecimalUnsignedLong()); assertEquals(' ', buffer.readByte()); assertEquals(0xcafebabeL, buffer.readHexadecimalUnsignedLong()); assertEquals(' ', buffer.readByte()); assertEquals(0x10L, buffer.readHexadecimalUnsignedLong()); Exceptions \u00b6 NumberFormatException - if the found hexadecimal does not fit into a long or hexadecimal was not found.","title":"readHexadecimalUnsignedLong - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-hexadecimal-unsigned-long/#readhexadecimalunsignedlong","text":"(js, jvm, native) abstract fun readHexadecimalUnsignedLong(): Long Reads a long form this source in hexadecimal form (i.e., as a string in base 16). This will iterate until a non-hexadecimal character is found. Buffer buffer = new Buffer() .writeUtf8(\"ffff CAFEBABE 10\"); assertEquals(65535L, buffer.readHexadecimalUnsignedLong()); assertEquals(' ', buffer.readByte()); assertEquals(0xcafebabeL, buffer.readHexadecimalUnsignedLong()); assertEquals(' ', buffer.readByte()); assertEquals(0x10L, buffer.readHexadecimalUnsignedLong());","title":"readHexadecimalUnsignedLong"},{"location":"2.x/okio/okio/-buffered-source/read-hexadecimal-unsigned-long/#exceptions","text":"NumberFormatException - if the found hexadecimal does not fit into a long or hexadecimal was not found.","title":"Exceptions"},{"location":"2.x/okio/okio/-buffered-source/read-int-le/","text":"okio / okio / BufferedSource / readIntLe readIntLe \u00b6 (js, jvm, native) abstract fun readIntLe(): Int Removes four bytes from this source and returns a little-endian int. Buffer buffer = new Buffer() .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0x7f) .writeByte(0x0f) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00); assertEquals(8, buffer.size()); assertEquals(2147483647, buffer.readIntLe()); assertEquals(4, buffer.size()); assertEquals(15, buffer.readIntLe()); assertEquals(0, buffer.size());","title":"readIntLe - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-int-le/#readintle","text":"(js, jvm, native) abstract fun readIntLe(): Int Removes four bytes from this source and returns a little-endian int. Buffer buffer = new Buffer() .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0x7f) .writeByte(0x0f) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00); assertEquals(8, buffer.size()); assertEquals(2147483647, buffer.readIntLe()); assertEquals(4, buffer.size()); assertEquals(15, buffer.readIntLe()); assertEquals(0, buffer.size());","title":"readIntLe"},{"location":"2.x/okio/okio/-buffered-source/read-int/","text":"okio / okio / BufferedSource / readInt readInt \u00b6 (js, jvm, native) abstract fun readInt(): Int Removes four bytes from this source and returns a big-endian int. Buffer buffer = new Buffer() .writeByte(0x7f) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x0f); assertEquals(8, buffer.size()); assertEquals(2147483647, buffer.readInt()); assertEquals(4, buffer.size()); assertEquals(15, buffer.readInt()); assertEquals(0, buffer.size());","title":"readInt - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-int/#readint","text":"(js, jvm, native) abstract fun readInt(): Int Removes four bytes from this source and returns a big-endian int. Buffer buffer = new Buffer() .writeByte(0x7f) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x0f); assertEquals(8, buffer.size()); assertEquals(2147483647, buffer.readInt()); assertEquals(4, buffer.size()); assertEquals(15, buffer.readInt()); assertEquals(0, buffer.size());","title":"readInt"},{"location":"2.x/okio/okio/-buffered-source/read-long-le/","text":"okio / okio / BufferedSource / readLongLe readLongLe \u00b6 (js, jvm, native) abstract fun readLongLe(): Long Removes eight bytes from this source and returns a little-endian long. Buffer buffer = new Buffer() .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0x7f) .writeByte(0x0f) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00); assertEquals(16, buffer.size()); assertEquals(9223372036854775807L, buffer.readLongLe()); assertEquals(8, buffer.size()); assertEquals(15, buffer.readLongLe()); assertEquals(0, buffer.size());","title":"readLongLe - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-long-le/#readlongle","text":"(js, jvm, native) abstract fun readLongLe(): Long Removes eight bytes from this source and returns a little-endian long. Buffer buffer = new Buffer() .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0x7f) .writeByte(0x0f) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00); assertEquals(16, buffer.size()); assertEquals(9223372036854775807L, buffer.readLongLe()); assertEquals(8, buffer.size()); assertEquals(15, buffer.readLongLe()); assertEquals(0, buffer.size());","title":"readLongLe"},{"location":"2.x/okio/okio/-buffered-source/read-long/","text":"okio / okio / BufferedSource / readLong readLong \u00b6 (js, jvm, native) abstract fun readLong(): Long Removes eight bytes from this source and returns a big-endian long. Buffer buffer = new Buffer() .writeByte(0x7f) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x0f); assertEquals(16, buffer.size()); assertEquals(9223372036854775807L, buffer.readLong()); assertEquals(8, buffer.size()); assertEquals(15, buffer.readLong()); assertEquals(0, buffer.size());","title":"readLong - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-long/#readlong","text":"(js, jvm, native) abstract fun readLong(): Long Removes eight bytes from this source and returns a big-endian long. Buffer buffer = new Buffer() .writeByte(0x7f) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0xff) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x00) .writeByte(0x0f); assertEquals(16, buffer.size()); assertEquals(9223372036854775807L, buffer.readLong()); assertEquals(8, buffer.size()); assertEquals(15, buffer.readLong()); assertEquals(0, buffer.size());","title":"readLong"},{"location":"2.x/okio/okio/-buffered-source/read-short-le/","text":"okio / okio / BufferedSource / readShortLe readShortLe \u00b6 (js, jvm, native) abstract fun readShortLe(): Short Removes two bytes from this source and returns a little-endian short. Buffer buffer = new Buffer() .writeByte(0xff) .writeByte(0x7f) .writeByte(0x0f) .writeByte(0x00); assertEquals(4, buffer.size()); assertEquals(32767, buffer.readShortLe()); assertEquals(2, buffer.size()); assertEquals(15, buffer.readShortLe()); assertEquals(0, buffer.size());","title":"readShortLe - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-short-le/#readshortle","text":"(js, jvm, native) abstract fun readShortLe(): Short Removes two bytes from this source and returns a little-endian short. Buffer buffer = new Buffer() .writeByte(0xff) .writeByte(0x7f) .writeByte(0x0f) .writeByte(0x00); assertEquals(4, buffer.size()); assertEquals(32767, buffer.readShortLe()); assertEquals(2, buffer.size()); assertEquals(15, buffer.readShortLe()); assertEquals(0, buffer.size());","title":"readShortLe"},{"location":"2.x/okio/okio/-buffered-source/read-short/","text":"okio / okio / BufferedSource / readShort readShort \u00b6 (js, jvm, native) abstract fun readShort(): Short Removes two bytes from this source and returns a big-endian short. Buffer buffer = new Buffer() .writeByte(0x7f) .writeByte(0xff) .writeByte(0x00) .writeByte(0x0f); assertEquals(4, buffer.size()); assertEquals(32767, buffer.readShort()); assertEquals(2, buffer.size()); assertEquals(15, buffer.readShort()); assertEquals(0, buffer.size());","title":"readShort - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-short/#readshort","text":"(js, jvm, native) abstract fun readShort(): Short Removes two bytes from this source and returns a big-endian short. Buffer buffer = new Buffer() .writeByte(0x7f) .writeByte(0xff) .writeByte(0x00) .writeByte(0x0f); assertEquals(4, buffer.size()); assertEquals(32767, buffer.readShort()); assertEquals(2, buffer.size()); assertEquals(15, buffer.readShort()); assertEquals(0, buffer.size());","title":"readShort"},{"location":"2.x/okio/okio/-buffered-source/read-string/","text":"okio / okio / BufferedSource / readString readString \u00b6 (jvm) abstract fun readString(charset: Charset ): String Removes all bytes from this, decodes them as charset , and returns the string. (jvm) abstract fun readString(byteCount: Long , charset: Charset ): String Removes byteCount bytes from this, decodes them as charset , and returns the string.","title":"readString - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-string/#readstring","text":"(jvm) abstract fun readString(charset: Charset ): String Removes all bytes from this, decodes them as charset , and returns the string. (jvm) abstract fun readString(byteCount: Long , charset: Charset ): String Removes byteCount bytes from this, decodes them as charset , and returns the string.","title":"readString"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-code-point/","text":"okio / okio / BufferedSource / readUtf8CodePoint readUtf8CodePoint \u00b6 (js, jvm, native) abstract fun readUtf8CodePoint(): Int (js) Removes and returns a single UTF-8 code point, reading between 1 and 4 bytes as necessary. If this source is exhausted before a complete code point can be read, this throws an java.io.EOFException and consumes no input. If this source doesn\u2019t start with a properly-encoded UTF-8 code point, this method will remove 1 or more non-UTF-8 bytes and return the replacement character ( U+FFFD ). This covers encoding problems (the input is not properly-encoded UTF-8), characters out of range (beyond the 0x10ffff limit of Unicode), code points for UTF-16 surrogates (U+d800..U+dfff) and overlong encodings (such as 0xc080 for the NUL character in modified UTF-8). (jvm) Removes and returns a single UTF-8 code point, reading between 1 and 4 bytes as necessary. If this source is exhausted before a complete code point can be read, this throws an java.io.EOFException and consumes no input. If this source doesn\u2019t start with a properly-encoded UTF-8 code point, this method will remove 1 or more non-UTF-8 bytes and return the replacement character ( U+FFFD ). This covers encoding problems (the input is not properly-encoded UTF-8), characters out of range (beyond the 0x10ffff limit of Unicode), code points for UTF-16 surrogates (U+d800..U+dfff) and overlong encodings (such as 0xc080 for the NUL character in modified UTF-8).","title":"readUtf8CodePoint - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-code-point/#readutf8codepoint","text":"(js, jvm, native) abstract fun readUtf8CodePoint(): Int (js) Removes and returns a single UTF-8 code point, reading between 1 and 4 bytes as necessary. If this source is exhausted before a complete code point can be read, this throws an java.io.EOFException and consumes no input. If this source doesn\u2019t start with a properly-encoded UTF-8 code point, this method will remove 1 or more non-UTF-8 bytes and return the replacement character ( U+FFFD ). This covers encoding problems (the input is not properly-encoded UTF-8), characters out of range (beyond the 0x10ffff limit of Unicode), code points for UTF-16 surrogates (U+d800..U+dfff) and overlong encodings (such as 0xc080 for the NUL character in modified UTF-8). (jvm) Removes and returns a single UTF-8 code point, reading between 1 and 4 bytes as necessary. If this source is exhausted before a complete code point can be read, this throws an java.io.EOFException and consumes no input. If this source doesn\u2019t start with a properly-encoded UTF-8 code point, this method will remove 1 or more non-UTF-8 bytes and return the replacement character ( U+FFFD ). This covers encoding problems (the input is not properly-encoded UTF-8), characters out of range (beyond the 0x10ffff limit of Unicode), code points for UTF-16 surrogates (U+d800..U+dfff) and overlong encodings (such as 0xc080 for the NUL character in modified UTF-8).","title":"readUtf8CodePoint"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-line-strict/","text":"okio / okio / BufferedSource / readUtf8LineStrict readUtf8LineStrict \u00b6 (js, jvm, native) abstract fun readUtf8LineStrict(): String (js) Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. On the end of the stream this method throws. Every call must consume either \u2018\\r\\n\u2019 or \u2018\\n\u2019. If these characters are absent in the stream, an java.io.EOFException is thrown. Use this for machine-generated data where a missing line break implies truncated input. (jvm) Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. On the end of the stream this method throws. Every call must consume either \u2018\\r\\n\u2019 or \u2018\\n\u2019. If these characters are absent in the stream, an java.io.EOFException is thrown. Use this for machine-generated data where a missing line break implies truncated input. (js, jvm, native) abstract fun readUtf8LineStrict(limit: Long ): String Like readUtf8LineStrict , except this allows the caller to specify the longest allowed match. Use this to protect against streams that may not include \"\\n\" or \"\\r\\n\" . The returned string will have at most limit UTF-8 bytes, and the maximum number of bytes scanned is limit + 2 . If limit == 0 this will always throw an EOFException because no bytes will be scanned. This method is safe. No bytes are discarded if the match fails, and the caller is free to try another match: Buffer buffer = new Buffer(); buffer.writeUtf8(\"12345\\r\\n\"); // This will throw! There must be \\r\\n or \\n at the limit or before it. buffer.readUtf8LineStrict(4); // No bytes have been consumed so the caller can retry. assertEquals(\"12345\", buffer.readUtf8LineStrict(5));","title":"readUtf8LineStrict - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-line-strict/#readutf8linestrict","text":"(js, jvm, native) abstract fun readUtf8LineStrict(): String (js) Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. On the end of the stream this method throws. Every call must consume either \u2018\\r\\n\u2019 or \u2018\\n\u2019. If these characters are absent in the stream, an java.io.EOFException is thrown. Use this for machine-generated data where a missing line break implies truncated input. (jvm) Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. On the end of the stream this method throws. Every call must consume either \u2018\\r\\n\u2019 or \u2018\\n\u2019. If these characters are absent in the stream, an java.io.EOFException is thrown. Use this for machine-generated data where a missing line break implies truncated input. (js, jvm, native) abstract fun readUtf8LineStrict(limit: Long ): String Like readUtf8LineStrict , except this allows the caller to specify the longest allowed match. Use this to protect against streams that may not include \"\\n\" or \"\\r\\n\" . The returned string will have at most limit UTF-8 bytes, and the maximum number of bytes scanned is limit + 2 . If limit == 0 this will always throw an EOFException because no bytes will be scanned. This method is safe. No bytes are discarded if the match fails, and the caller is free to try another match: Buffer buffer = new Buffer(); buffer.writeUtf8(\"12345\\r\\n\"); // This will throw! There must be \\r\\n or \\n at the limit or before it. buffer.readUtf8LineStrict(4); // No bytes have been consumed so the caller can retry. assertEquals(\"12345\", buffer.readUtf8LineStrict(5));","title":"readUtf8LineStrict"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-line/","text":"okio / okio / BufferedSource / readUtf8Line readUtf8Line \u00b6 (js, jvm, native) abstract fun readUtf8Line(): String ? (js) Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. Buffer buffer = new Buffer() .writeUtf8(\"I'm a hacker!\\n\") .writeUtf8(\"That's what I said: you're a nerd.\\n\") .writeUtf8(\"I prefer to be called a hacker!\\n\"); assertEquals(81, buffer.size()); assertEquals(\"I'm a hacker!\", buffer.readUtf8Line()); assertEquals(67, buffer.size()); assertEquals(\"That's what I said: you're a nerd.\", buffer.readUtf8Line()); assertEquals(32, buffer.size()); assertEquals(\"I prefer to be called a hacker!\", buffer.readUtf8Line()); assertEquals(0, buffer.size()); assertEquals(null, buffer.readUtf8Line()); assertEquals(0, buffer.size()); On the end of the stream this method returns null, just like java.io.BufferedReader . If the source doesn\u2019t end with a line break then an implicit line break is assumed. Null is returned once the source is exhausted. Use this for human-generated data, where a trailing line break is optional. (jvm) Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. Buffer buffer = new Buffer() .writeUtf8(\"I'm a hacker!\\n\") .writeUtf8(\"That's what I said: you're a nerd.\\n\") .writeUtf8(\"I prefer to be called a hacker!\\n\"); assertEquals(81, buffer.size()); assertEquals(\"I'm a hacker!\", buffer.readUtf8Line()); assertEquals(67, buffer.size()); assertEquals(\"That's what I said: you're a nerd.\", buffer.readUtf8Line()); assertEquals(32, buffer.size()); assertEquals(\"I prefer to be called a hacker!\", buffer.readUtf8Line()); assertEquals(0, buffer.size()); assertEquals(null, buffer.readUtf8Line()); assertEquals(0, buffer.size()); On the end of the stream this method returns null, just like java.io.BufferedReader . If the source doesn\u2019t end with a line break then an implicit line break is assumed. Null is returned once the source is exhausted. Use this for human-generated data, where a trailing line break is optional.","title":"readUtf8Line - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-line/#readutf8line","text":"(js, jvm, native) abstract fun readUtf8Line(): String ? (js) Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. Buffer buffer = new Buffer() .writeUtf8(\"I'm a hacker!\\n\") .writeUtf8(\"That's what I said: you're a nerd.\\n\") .writeUtf8(\"I prefer to be called a hacker!\\n\"); assertEquals(81, buffer.size()); assertEquals(\"I'm a hacker!\", buffer.readUtf8Line()); assertEquals(67, buffer.size()); assertEquals(\"That's what I said: you're a nerd.\", buffer.readUtf8Line()); assertEquals(32, buffer.size()); assertEquals(\"I prefer to be called a hacker!\", buffer.readUtf8Line()); assertEquals(0, buffer.size()); assertEquals(null, buffer.readUtf8Line()); assertEquals(0, buffer.size()); On the end of the stream this method returns null, just like java.io.BufferedReader . If the source doesn\u2019t end with a line break then an implicit line break is assumed. Null is returned once the source is exhausted. Use this for human-generated data, where a trailing line break is optional. (jvm) Removes and returns characters up to but not including the next line break. A line break is either \"\\n\" or \"\\r\\n\" ; these characters are not included in the result. Buffer buffer = new Buffer() .writeUtf8(\"I'm a hacker!\\n\") .writeUtf8(\"That's what I said: you're a nerd.\\n\") .writeUtf8(\"I prefer to be called a hacker!\\n\"); assertEquals(81, buffer.size()); assertEquals(\"I'm a hacker!\", buffer.readUtf8Line()); assertEquals(67, buffer.size()); assertEquals(\"That's what I said: you're a nerd.\", buffer.readUtf8Line()); assertEquals(32, buffer.size()); assertEquals(\"I prefer to be called a hacker!\", buffer.readUtf8Line()); assertEquals(0, buffer.size()); assertEquals(null, buffer.readUtf8Line()); assertEquals(0, buffer.size()); On the end of the stream this method returns null, just like java.io.BufferedReader . If the source doesn\u2019t end with a line break then an implicit line break is assumed. Null is returned once the source is exhausted. Use this for human-generated data, where a trailing line break is optional.","title":"readUtf8Line"},{"location":"2.x/okio/okio/-buffered-source/read-utf8/","text":"okio / okio / BufferedSource / readUtf8 readUtf8 \u00b6 (js, jvm, native) abstract fun readUtf8(): String Removes all bytes from this, decodes them as UTF-8, and returns the string. Returns the empty string if this source is empty. Buffer buffer = new Buffer() .writeUtf8(\"Uh uh uh!\") .writeByte(' ') .writeUtf8(\"You didn't say the magic word!\"); assertEquals(\"Uh uh uh! You didn't say the magic word!\", buffer.readUtf8()); assertEquals(0, buffer.size()); assertEquals(\"\", buffer.readUtf8()); assertEquals(0, buffer.size()); (js, jvm, native) abstract fun readUtf8(byteCount: Long ): String Removes byteCount bytes from this, decodes them as UTF-8, and returns the string. Buffer buffer = new Buffer() .writeUtf8(\"Uh uh uh!\") .writeByte(' ') .writeUtf8(\"You didn't say the magic word!\"); assertEquals(40, buffer.size()); assertEquals(\"Uh uh uh! You \", buffer.readUtf8(14)); assertEquals(26, buffer.size()); assertEquals(\"didn't say the\", buffer.readUtf8(14)); assertEquals(12, buffer.size()); assertEquals(\" magic word!\", buffer.readUtf8(12)); assertEquals(0, buffer.size());","title":"readUtf8 - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-utf8/#readutf8","text":"(js, jvm, native) abstract fun readUtf8(): String Removes all bytes from this, decodes them as UTF-8, and returns the string. Returns the empty string if this source is empty. Buffer buffer = new Buffer() .writeUtf8(\"Uh uh uh!\") .writeByte(' ') .writeUtf8(\"You didn't say the magic word!\"); assertEquals(\"Uh uh uh! You didn't say the magic word!\", buffer.readUtf8()); assertEquals(0, buffer.size()); assertEquals(\"\", buffer.readUtf8()); assertEquals(0, buffer.size()); (js, jvm, native) abstract fun readUtf8(byteCount: Long ): String Removes byteCount bytes from this, decodes them as UTF-8, and returns the string. Buffer buffer = new Buffer() .writeUtf8(\"Uh uh uh!\") .writeByte(' ') .writeUtf8(\"You didn't say the magic word!\"); assertEquals(40, buffer.size()); assertEquals(\"Uh uh uh! You \", buffer.readUtf8(14)); assertEquals(26, buffer.size()); assertEquals(\"didn't say the\", buffer.readUtf8(14)); assertEquals(12, buffer.size()); assertEquals(\" magic word!\", buffer.readUtf8(12)); assertEquals(0, buffer.size());","title":"readUtf8"},{"location":"2.x/okio/okio/-buffered-source/read/","text":"okio / okio / BufferedSource / read read \u00b6 (js, jvm, native) abstract fun read(sink: ByteArray ): Int Removes up to sink.length bytes from this and copies them into sink . Returns the number of bytes read, or -1 if this source is exhausted. (js, jvm, native) abstract fun read(sink: ByteArray , offset: Int , byteCount: Int ): Int Removes up to byteCount bytes from this and copies them into sink at offset . Returns the number of bytes read, or -1 if this source is exhausted.","title":"read - Okio"},{"location":"2.x/okio/okio/-buffered-source/read/#read","text":"(js, jvm, native) abstract fun read(sink: ByteArray ): Int Removes up to sink.length bytes from this and copies them into sink . Returns the number of bytes read, or -1 if this source is exhausted. (js, jvm, native) abstract fun read(sink: ByteArray , offset: Int , byteCount: Int ): Int Removes up to byteCount bytes from this and copies them into sink at offset . Returns the number of bytes read, or -1 if this source is exhausted.","title":"read"},{"location":"2.x/okio/okio/-buffered-source/request/","text":"okio / okio / BufferedSource / request request \u00b6 (js, jvm, native) abstract fun request(byteCount: Long ): Boolean Returns true when the buffer contains at least byteCount bytes, expanding it as necessary. Returns false if the source is exhausted before the requested bytes can be read.","title":"request - Okio"},{"location":"2.x/okio/okio/-buffered-source/request/#request","text":"(js, jvm, native) abstract fun request(byteCount: Long ): Boolean Returns true when the buffer contains at least byteCount bytes, expanding it as necessary. Returns false if the source is exhausted before the requested bytes can be read.","title":"request"},{"location":"2.x/okio/okio/-buffered-source/require/","text":"okio / okio / BufferedSource / require require \u00b6 (js, jvm, native) abstract fun require(byteCount: Long ): Unit (js) Returns when the buffer contains at least byteCount bytes. Throws an java.io.EOFException if the source is exhausted before the required bytes can be read. (jvm) Returns when the buffer contains at least byteCount bytes. Throws an java.io.EOFException if the source is exhausted before the required bytes can be read.","title":"require - Okio"},{"location":"2.x/okio/okio/-buffered-source/require/#require","text":"(js, jvm, native) abstract fun require(byteCount: Long ): Unit (js) Returns when the buffer contains at least byteCount bytes. Throws an java.io.EOFException if the source is exhausted before the required bytes can be read. (jvm) Returns when the buffer contains at least byteCount bytes. Throws an java.io.EOFException if the source is exhausted before the required bytes can be read.","title":"require"},{"location":"2.x/okio/okio/-buffered-source/select/","text":"okio / okio / BufferedSource / select select \u00b6 (js, jvm) abstract fun select(options: Options ): Int Finds the first string in options that is a prefix of this buffer, consumes it from this buffer, and returns its index. If no byte string in options is a prefix of this buffer this returns -1 and no bytes are consumed. This can be used as an alternative to readByteString or even readUtf8 if the set of expected values is known in advance. Options FIELDS = Options.of( ByteString.encodeUtf8(\"depth=\"), ByteString.encodeUtf8(\"height=\"), ByteString.encodeUtf8(\"width=\")); Buffer buffer = new Buffer() .writeUtf8(\"width=640\\n\") .writeUtf8(\"height=480\\n\"); assertEquals(2, buffer.select(FIELDS)); assertEquals(640, buffer.readDecimalLong()); assertEquals('\\n', buffer.readByte()); assertEquals(1, buffer.select(FIELDS)); assertEquals(480, buffer.readDecimalLong()); assertEquals('\\n', buffer.readByte()); (native) abstract fun select(options: <ERROR CLASS>): Int","title":"select - Okio"},{"location":"2.x/okio/okio/-buffered-source/select/#select","text":"(js, jvm) abstract fun select(options: Options ): Int Finds the first string in options that is a prefix of this buffer, consumes it from this buffer, and returns its index. If no byte string in options is a prefix of this buffer this returns -1 and no bytes are consumed. This can be used as an alternative to readByteString or even readUtf8 if the set of expected values is known in advance. Options FIELDS = Options.of( ByteString.encodeUtf8(\"depth=\"), ByteString.encodeUtf8(\"height=\"), ByteString.encodeUtf8(\"width=\")); Buffer buffer = new Buffer() .writeUtf8(\"width=640\\n\") .writeUtf8(\"height=480\\n\"); assertEquals(2, buffer.select(FIELDS)); assertEquals(640, buffer.readDecimalLong()); assertEquals('\\n', buffer.readByte()); assertEquals(1, buffer.select(FIELDS)); assertEquals(480, buffer.readDecimalLong()); assertEquals('\\n', buffer.readByte()); (native) abstract fun select(options: <ERROR CLASS>): Int","title":"select"},{"location":"2.x/okio/okio/-buffered-source/skip/","text":"okio / okio / BufferedSource / skip skip \u00b6 (js, jvm, native) abstract fun skip(byteCount: Long ): Unit (js) Reads and discards byteCount bytes from this source. Throws an java.io.EOFException if the source is exhausted before the requested bytes can be skipped. (jvm) Reads and discards byteCount bytes from this source. Throws an java.io.EOFException if the source is exhausted before the requested bytes can be skipped.","title":"skip - Okio"},{"location":"2.x/okio/okio/-buffered-source/skip/#skip","text":"(js, jvm, native) abstract fun skip(byteCount: Long ): Unit (js) Reads and discards byteCount bytes from this source. Throws an java.io.EOFException if the source is exhausted before the requested bytes can be skipped. (jvm) Reads and discards byteCount bytes from this source. Throws an java.io.EOFException if the source is exhausted before the requested bytes can be skipped.","title":"skip"},{"location":"2.x/okio/okio/-byte-string/","text":"okio / okio / ByteString ByteString \u00b6 (js, jvm, native) open class ByteString : Comparable < ByteString > An immutable sequence of bytes. Byte strings compare lexicographically as a sequence of unsigned bytes. That is, the byte string ff sorts after 00 . This is counter to the sort order of the corresponding bytes, where -1 sorts before 0 . Full disclosure: this class provides untrusted input and output streams with raw access to the underlying byte array. A hostile stream implementation could keep a reference to the mutable byte string, violating the immutable guarantee of this class. For this reason a byte string\u2019s immutability guarantee cannot be relied upon for security in applets and other environments that run both trusted and untrusted code in the same process. Properties \u00b6 Name Summary size Returns the number of bytes in this ByteString.(js, jvm) val size: Int (native) val size: <ERROR CLASS> Functions \u00b6 Name Summary (jvm) asByteBuffer Returns a ByteBuffer view of the bytes in this ByteString . open fun asByteBuffer(): ByteBuffer base64 Returns this byte string encoded as Base64 . In violation of the RFC, the returned string does not wrap lines at 76 columns.(js, jvm) fun base64(): String (native) open fun base64(): String base64Url Returns this byte string encoded as URL-safe Base64 .(js, jvm) fun base64Url(): String (native) open fun base64Url(): String compareTo (js, jvm) open fun compareTo(other: ByteString ): Int (native) open fun compareTo(other: ByteString ): <ERROR CLASS> endsWith (js, jvm) fun endsWith(suffix: ByteString ): Boolean (native) fun endsWith(suffix: ByteString ): <ERROR CLASS> (js, jvm) fun endsWith(suffix: ByteArray ): Boolean (native) fun endsWith(suffix: ByteArray ): <ERROR CLASS> equals (js, jvm) open fun equals(other: Any ?): Boolean (native) open fun equals(other: Any ?): <ERROR CLASS> (js, jvm, native) get Returns the byte at index . operator fun get(index: Int ): Byte (jvm) getByte fun ~~getByte~~(index: Int ): Byte hashCode (js, jvm) open fun hashCode(): Int (native) open fun hashCode(): <ERROR CLASS> hex Returns this byte string encoded in hexadecimal.(js, jvm) fun hex(): String (native) open fun hex(): String (jvm) hmacSha1 Returns the 160-bit SHA-1 HMAC of this byte string. open fun hmacSha1(key: ByteString ): ByteString (jvm) hmacSha256 Returns the 256-bit SHA-256 HMAC of this byte string. open fun hmacSha256(key: ByteString ): ByteString (jvm) hmacSha512 Returns the 512-bit SHA-512 HMAC of this byte string. open fun hmacSha512(key: ByteString ): ByteString indexOf (js, jvm) fun indexOf(other: ByteString , fromIndex: Int = 0): Int (native) fun indexOf(other: ByteString , fromIndex: Int ): <ERROR CLASS> (js, jvm) fun indexOf(other: ByteArray , fromIndex: Int = 0): Int (native) open fun indexOf(other: ByteArray , fromIndex: Int ): <ERROR CLASS> lastIndexOf (js, jvm) fun lastIndexOf(other: ByteString , fromIndex: Int = size): Int (native) fun lastIndexOf(other: ByteString , fromIndex: Int ): <ERROR CLASS> (js, jvm) fun lastIndexOf(other: ByteArray , fromIndex: Int = size): Int (native) open fun lastIndexOf(other: ByteArray , fromIndex: Int ): <ERROR CLASS> (jvm) md5 Returns the 128-bit MD5 hash of this byte string. open fun md5(): ByteString rangeEquals Returns true if the bytes of this in [offset..offset+byteCount) equal the bytes of other in [otherOffset..otherOffset+byteCount) . Returns false if either range is out of bounds.(js, jvm) fun rangeEquals(offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean (native) open fun rangeEquals(offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean (js, jvm) fun rangeEquals(offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean (native) open fun rangeEquals(offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean (jvm) sha1 Returns the 160-bit SHA-1 hash of this byte string. open fun sha1(): ByteString (jvm) sha256 Returns the 256-bit SHA-256 hash of this byte string. open fun sha256(): ByteString (jvm) sha512 Returns the 512-bit SHA-512 hash of this byte string. open fun sha512(): ByteString (jvm) size fun ~~size~~(): Int startsWith (js, jvm) fun startsWith(prefix: ByteString ): Boolean (native) fun startsWith(prefix: ByteString ): <ERROR CLASS> (js, jvm) fun startsWith(prefix: ByteArray ): Boolean (native) fun startsWith(prefix: ByteArray ): <ERROR CLASS> (jvm) string Constructs a new String by decoding the bytes using charset . open fun string(charset: Charset ): String substring Returns a byte string that is a substring of this byte string, beginning at the specified beginIndex and ends at the specified endIndex . Returns this byte string if beginIndex is 0 and endIndex is the length of this byte string.(js, jvm) fun substring(beginIndex: Int = 0, endIndex: Int = size): ByteString (native) open fun substring(beginIndex: Int , endIndex: Int ): ByteString toAsciiLowercase Returns a byte string equal to this byte string, but with the bytes \u2018A\u2019 through \u2018Z\u2019 replaced with the corresponding byte in \u2018a\u2019 through \u2018z\u2019. Returns this byte string if it contains no bytes in \u2018A\u2019 through \u2018Z\u2019.(js, jvm) fun toAsciiLowercase(): ByteString (native) open fun toAsciiLowercase(): ByteString toAsciiUppercase Returns a byte string equal to this byte string, but with the bytes \u2018a\u2019 through \u2018z\u2019 replaced with the corresponding byte in \u2018A\u2019 through \u2018Z\u2019. Returns this byte string if it contains no bytes in \u2018a\u2019 through \u2018z\u2019.(js, jvm) fun toAsciiUppercase(): ByteString (native) open fun toAsciiUppercase(): ByteString toByteArray Returns a byte array containing a copy of the bytes in this ByteString .(js, jvm) fun toByteArray(): ByteArray (native) open fun toByteArray(): <ERROR CLASS> toString Returns a human-readable string that describes the contents of this byte string. Typically this is a string like [text=Hello] or [hex=0000ffff] .(js, jvm) open fun toString(): String (native) open fun toString(): <ERROR CLASS> utf8 Constructs a new String by decoding the bytes as UTF-8 .(js, jvm) fun utf8(): String (native) open fun utf8(): String (jvm) write Writes the contents of this byte string to out . open fun write(out: OutputStream ): Unit Companion Object Properties \u00b6 Name Summary (js, jvm, native) EMPTY A singleton empty ByteString . val EMPTY: ByteString Companion Object Functions \u00b6 Name Summary (js, jvm, native) decodeBase64 Decodes the Base64-encoded bytes and returns their value as a byte string. Returns null if this is not a Base64-encoded sequence of bytes. fun String .decodeBase64(): ByteString ? decodeHex Decodes the hex-encoded bytes and returns their value a byte string.(js, jvm) fun String .decodeHex(): ByteString (native) fun String .decodeHex(): <ERROR CLASS> (jvm) encode Returns a new ByteString containing the charset -encoded bytes of this String . fun String .encode(charset: Charset = Charsets.UTF_8): ByteString (jvm) encodeString fun ~~encodeString~~(string: String , charset: Charset ): ByteString (js, jvm, native) encodeUtf8 Returns a new byte string containing the UTF-8 bytes of this String . fun String .encodeUtf8(): ByteString of (jvm) fun ~~of~~(buffer: ByteBuffer ): ByteString (jvm) fun ~~of~~(array: ByteArray , offset: Int , byteCount: Int ): ByteString Returns a new byte string containing a clone of the bytes of data .(js, jvm) fun of(vararg data: Byte ): ByteString (native) fun of(vararg data: Byte ): <ERROR CLASS> (jvm) read fun ~~read~~(inputstream: InputStream , byteCount: Int ): ByteString (jvm) readByteString Reads count bytes from this InputStream and returns the result. fun InputStream .readByteString(byteCount: Int ): ByteString toByteString Returns a ByteString containing a copy of this ByteBuffer .(jvm) fun ByteBuffer .toByteString(): ByteString Returns a new ByteString containing a copy of byteCount bytes of this ByteArray starting at offset .(js, jvm) fun ByteArray .toByteString(offset: Int = 0, byteCount: Int = size): ByteString (native) fun ByteArray .toByteString(offset: Int , byteCount: Int ): ByteString","title":"ByteString - Okio"},{"location":"2.x/okio/okio/-byte-string/#bytestring","text":"(js, jvm, native) open class ByteString : Comparable < ByteString > An immutable sequence of bytes. Byte strings compare lexicographically as a sequence of unsigned bytes. That is, the byte string ff sorts after 00 . This is counter to the sort order of the corresponding bytes, where -1 sorts before 0 . Full disclosure: this class provides untrusted input and output streams with raw access to the underlying byte array. A hostile stream implementation could keep a reference to the mutable byte string, violating the immutable guarantee of this class. For this reason a byte string\u2019s immutability guarantee cannot be relied upon for security in applets and other environments that run both trusted and untrusted code in the same process.","title":"ByteString"},{"location":"2.x/okio/okio/-byte-string/#properties","text":"Name Summary size Returns the number of bytes in this ByteString.(js, jvm) val size: Int (native) val size: <ERROR CLASS>","title":"Properties"},{"location":"2.x/okio/okio/-byte-string/#functions","text":"Name Summary (jvm) asByteBuffer Returns a ByteBuffer view of the bytes in this ByteString . open fun asByteBuffer(): ByteBuffer base64 Returns this byte string encoded as Base64 . In violation of the RFC, the returned string does not wrap lines at 76 columns.(js, jvm) fun base64(): String (native) open fun base64(): String base64Url Returns this byte string encoded as URL-safe Base64 .(js, jvm) fun base64Url(): String (native) open fun base64Url(): String compareTo (js, jvm) open fun compareTo(other: ByteString ): Int (native) open fun compareTo(other: ByteString ): <ERROR CLASS> endsWith (js, jvm) fun endsWith(suffix: ByteString ): Boolean (native) fun endsWith(suffix: ByteString ): <ERROR CLASS> (js, jvm) fun endsWith(suffix: ByteArray ): Boolean (native) fun endsWith(suffix: ByteArray ): <ERROR CLASS> equals (js, jvm) open fun equals(other: Any ?): Boolean (native) open fun equals(other: Any ?): <ERROR CLASS> (js, jvm, native) get Returns the byte at index . operator fun get(index: Int ): Byte (jvm) getByte fun ~~getByte~~(index: Int ): Byte hashCode (js, jvm) open fun hashCode(): Int (native) open fun hashCode(): <ERROR CLASS> hex Returns this byte string encoded in hexadecimal.(js, jvm) fun hex(): String (native) open fun hex(): String (jvm) hmacSha1 Returns the 160-bit SHA-1 HMAC of this byte string. open fun hmacSha1(key: ByteString ): ByteString (jvm) hmacSha256 Returns the 256-bit SHA-256 HMAC of this byte string. open fun hmacSha256(key: ByteString ): ByteString (jvm) hmacSha512 Returns the 512-bit SHA-512 HMAC of this byte string. open fun hmacSha512(key: ByteString ): ByteString indexOf (js, jvm) fun indexOf(other: ByteString , fromIndex: Int = 0): Int (native) fun indexOf(other: ByteString , fromIndex: Int ): <ERROR CLASS> (js, jvm) fun indexOf(other: ByteArray , fromIndex: Int = 0): Int (native) open fun indexOf(other: ByteArray , fromIndex: Int ): <ERROR CLASS> lastIndexOf (js, jvm) fun lastIndexOf(other: ByteString , fromIndex: Int = size): Int (native) fun lastIndexOf(other: ByteString , fromIndex: Int ): <ERROR CLASS> (js, jvm) fun lastIndexOf(other: ByteArray , fromIndex: Int = size): Int (native) open fun lastIndexOf(other: ByteArray , fromIndex: Int ): <ERROR CLASS> (jvm) md5 Returns the 128-bit MD5 hash of this byte string. open fun md5(): ByteString rangeEquals Returns true if the bytes of this in [offset..offset+byteCount) equal the bytes of other in [otherOffset..otherOffset+byteCount) . Returns false if either range is out of bounds.(js, jvm) fun rangeEquals(offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean (native) open fun rangeEquals(offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean (js, jvm) fun rangeEquals(offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean (native) open fun rangeEquals(offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean (jvm) sha1 Returns the 160-bit SHA-1 hash of this byte string. open fun sha1(): ByteString (jvm) sha256 Returns the 256-bit SHA-256 hash of this byte string. open fun sha256(): ByteString (jvm) sha512 Returns the 512-bit SHA-512 hash of this byte string. open fun sha512(): ByteString (jvm) size fun ~~size~~(): Int startsWith (js, jvm) fun startsWith(prefix: ByteString ): Boolean (native) fun startsWith(prefix: ByteString ): <ERROR CLASS> (js, jvm) fun startsWith(prefix: ByteArray ): Boolean (native) fun startsWith(prefix: ByteArray ): <ERROR CLASS> (jvm) string Constructs a new String by decoding the bytes using charset . open fun string(charset: Charset ): String substring Returns a byte string that is a substring of this byte string, beginning at the specified beginIndex and ends at the specified endIndex . Returns this byte string if beginIndex is 0 and endIndex is the length of this byte string.(js, jvm) fun substring(beginIndex: Int = 0, endIndex: Int = size): ByteString (native) open fun substring(beginIndex: Int , endIndex: Int ): ByteString toAsciiLowercase Returns a byte string equal to this byte string, but with the bytes \u2018A\u2019 through \u2018Z\u2019 replaced with the corresponding byte in \u2018a\u2019 through \u2018z\u2019. Returns this byte string if it contains no bytes in \u2018A\u2019 through \u2018Z\u2019.(js, jvm) fun toAsciiLowercase(): ByteString (native) open fun toAsciiLowercase(): ByteString toAsciiUppercase Returns a byte string equal to this byte string, but with the bytes \u2018a\u2019 through \u2018z\u2019 replaced with the corresponding byte in \u2018A\u2019 through \u2018Z\u2019. Returns this byte string if it contains no bytes in \u2018a\u2019 through \u2018z\u2019.(js, jvm) fun toAsciiUppercase(): ByteString (native) open fun toAsciiUppercase(): ByteString toByteArray Returns a byte array containing a copy of the bytes in this ByteString .(js, jvm) fun toByteArray(): ByteArray (native) open fun toByteArray(): <ERROR CLASS> toString Returns a human-readable string that describes the contents of this byte string. Typically this is a string like [text=Hello] or [hex=0000ffff] .(js, jvm) open fun toString(): String (native) open fun toString(): <ERROR CLASS> utf8 Constructs a new String by decoding the bytes as UTF-8 .(js, jvm) fun utf8(): String (native) open fun utf8(): String (jvm) write Writes the contents of this byte string to out . open fun write(out: OutputStream ): Unit","title":"Functions"},{"location":"2.x/okio/okio/-byte-string/#companion-object-properties","text":"Name Summary (js, jvm, native) EMPTY A singleton empty ByteString . val EMPTY: ByteString","title":"Companion Object Properties"},{"location":"2.x/okio/okio/-byte-string/#companion-object-functions","text":"Name Summary (js, jvm, native) decodeBase64 Decodes the Base64-encoded bytes and returns their value as a byte string. Returns null if this is not a Base64-encoded sequence of bytes. fun String .decodeBase64(): ByteString ? decodeHex Decodes the hex-encoded bytes and returns their value a byte string.(js, jvm) fun String .decodeHex(): ByteString (native) fun String .decodeHex(): <ERROR CLASS> (jvm) encode Returns a new ByteString containing the charset -encoded bytes of this String . fun String .encode(charset: Charset = Charsets.UTF_8): ByteString (jvm) encodeString fun ~~encodeString~~(string: String , charset: Charset ): ByteString (js, jvm, native) encodeUtf8 Returns a new byte string containing the UTF-8 bytes of this String . fun String .encodeUtf8(): ByteString of (jvm) fun ~~of~~(buffer: ByteBuffer ): ByteString (jvm) fun ~~of~~(array: ByteArray , offset: Int , byteCount: Int ): ByteString Returns a new byte string containing a clone of the bytes of data .(js, jvm) fun of(vararg data: Byte ): ByteString (native) fun of(vararg data: Byte ): <ERROR CLASS> (jvm) read fun ~~read~~(inputstream: InputStream , byteCount: Int ): ByteString (jvm) readByteString Reads count bytes from this InputStream and returns the result. fun InputStream .readByteString(byteCount: Int ): ByteString toByteString Returns a ByteString containing a copy of this ByteBuffer .(jvm) fun ByteBuffer .toByteString(): ByteString Returns a new ByteString containing a copy of byteCount bytes of this ByteArray starting at offset .(js, jvm) fun ByteArray .toByteString(offset: Int = 0, byteCount: Int = size): ByteString (native) fun ByteArray .toByteString(offset: Int , byteCount: Int ): ByteString","title":"Companion Object Functions"},{"location":"2.x/okio/okio/-byte-string/-e-m-p-t-y/","text":"okio / okio / ByteString / EMPTY EMPTY \u00b6 (js, jvm, native) val EMPTY: ByteString A singleton empty ByteString .","title":"EMPTY - Okio"},{"location":"2.x/okio/okio/-byte-string/-e-m-p-t-y/#empty","text":"(js, jvm, native) val EMPTY: ByteString A singleton empty ByteString .","title":"EMPTY"},{"location":"2.x/okio/okio/-byte-string/as-byte-buffer/","text":"okio / okio / ByteString / asByteBuffer asByteBuffer \u00b6 (jvm) open fun asByteBuffer(): ByteBuffer Returns a ByteBuffer view of the bytes in this ByteString .","title":"asByteBuffer - Okio"},{"location":"2.x/okio/okio/-byte-string/as-byte-buffer/#asbytebuffer","text":"(jvm) open fun asByteBuffer(): ByteBuffer Returns a ByteBuffer view of the bytes in this ByteString .","title":"asByteBuffer"},{"location":"2.x/okio/okio/-byte-string/base64-url/","text":"okio / okio / ByteString / base64Url base64Url \u00b6 (js, jvm) fun base64Url(): String (native) open fun base64Url(): String Returns this byte string encoded as URL-safe Base64 .","title":"base64Url - Okio"},{"location":"2.x/okio/okio/-byte-string/base64-url/#base64url","text":"(js, jvm) fun base64Url(): String (native) open fun base64Url(): String Returns this byte string encoded as URL-safe Base64 .","title":"base64Url"},{"location":"2.x/okio/okio/-byte-string/base64/","text":"okio / okio / ByteString / base64 base64 \u00b6 (js, jvm) fun base64(): String (native) open fun base64(): String Returns this byte string encoded as Base64 . In violation of the RFC, the returned string does not wrap lines at 76 columns.","title":"base64 - Okio"},{"location":"2.x/okio/okio/-byte-string/base64/#base64","text":"(js, jvm) fun base64(): String (native) open fun base64(): String Returns this byte string encoded as Base64 . In violation of the RFC, the returned string does not wrap lines at 76 columns.","title":"base64"},{"location":"2.x/okio/okio/-byte-string/compare-to/","text":"okio / okio / ByteString / compareTo compareTo \u00b6 (js, jvm) open fun compareTo(other: ByteString ): Int (native) open fun compareTo(other: ByteString ): <ERROR CLASS>","title":"compareTo - Okio"},{"location":"2.x/okio/okio/-byte-string/compare-to/#compareto","text":"(js, jvm) open fun compareTo(other: ByteString ): Int (native) open fun compareTo(other: ByteString ): <ERROR CLASS>","title":"compareTo"},{"location":"2.x/okio/okio/-byte-string/decode-base64/","text":"okio / okio / ByteString / decodeBase64 decodeBase64 \u00b6 (js, jvm) @JvmStatic fun String .decodeBase64(): ByteString ? (native) fun String .decodeBase64(): ByteString ? Decodes the Base64-encoded bytes and returns their value as a byte string. Returns null if this is not a Base64-encoded sequence of bytes.","title":"decodeBase64 - Okio"},{"location":"2.x/okio/okio/-byte-string/decode-base64/#decodebase64","text":"(js, jvm) @JvmStatic fun String .decodeBase64(): ByteString ? (native) fun String .decodeBase64(): ByteString ? Decodes the Base64-encoded bytes and returns their value as a byte string. Returns null if this is not a Base64-encoded sequence of bytes.","title":"decodeBase64"},{"location":"2.x/okio/okio/-byte-string/decode-hex/","text":"okio / okio / ByteString / decodeHex decodeHex \u00b6 (js, jvm) @JvmStatic fun String .decodeHex(): ByteString (native) fun String .decodeHex(): <ERROR CLASS> Decodes the hex-encoded bytes and returns their value a byte string.","title":"decodeHex - Okio"},{"location":"2.x/okio/okio/-byte-string/decode-hex/#decodehex","text":"(js, jvm) @JvmStatic fun String .decodeHex(): ByteString (native) fun String .decodeHex(): <ERROR CLASS> Decodes the hex-encoded bytes and returns their value a byte string.","title":"decodeHex"},{"location":"2.x/okio/okio/-byte-string/encode-string/","text":"okio / okio / ByteString / encodeString encodeString \u00b6 (jvm) @JvmName(\"-deprecated_encodeString\") fun ~~encodeString~~(string: String , charset: Charset ): ByteString Deprecated: moved to extension function","title":"encodeString - Okio"},{"location":"2.x/okio/okio/-byte-string/encode-string/#encodestring","text":"(jvm) @JvmName(\"-deprecated_encodeString\") fun ~~encodeString~~(string: String , charset: Charset ): ByteString Deprecated: moved to extension function","title":"encodeString"},{"location":"2.x/okio/okio/-byte-string/encode-utf8/","text":"okio / okio / ByteString / encodeUtf8 encodeUtf8 \u00b6 (js, jvm) @JvmStatic fun String .encodeUtf8(): ByteString (native) fun String .encodeUtf8(): ByteString Returns a new byte string containing the UTF-8 bytes of this String .","title":"encodeUtf8 - Okio"},{"location":"2.x/okio/okio/-byte-string/encode-utf8/#encodeutf8","text":"(js, jvm) @JvmStatic fun String .encodeUtf8(): ByteString (native) fun String .encodeUtf8(): ByteString Returns a new byte string containing the UTF-8 bytes of this String .","title":"encodeUtf8"},{"location":"2.x/okio/okio/-byte-string/encode/","text":"okio / okio / ByteString / encode encode \u00b6 (jvm) @JvmStatic @JvmName(\"encodeString\") fun String .encode(charset: Charset = Charsets.UTF_8): ByteString Returns a new ByteString containing the charset -encoded bytes of this String .","title":"encode - Okio"},{"location":"2.x/okio/okio/-byte-string/encode/#encode","text":"(jvm) @JvmStatic @JvmName(\"encodeString\") fun String .encode(charset: Charset = Charsets.UTF_8): ByteString Returns a new ByteString containing the charset -encoded bytes of this String .","title":"encode"},{"location":"2.x/okio/okio/-byte-string/ends-with/","text":"okio / okio / ByteString / endsWith endsWith \u00b6 (js, jvm) fun endsWith(suffix: ByteString ): Boolean (native) fun endsWith(suffix: ByteString ): <ERROR CLASS> (js, jvm) fun endsWith(suffix: ByteArray ): Boolean (native) fun endsWith(suffix: ByteArray ): <ERROR CLASS>","title":"endsWith - Okio"},{"location":"2.x/okio/okio/-byte-string/ends-with/#endswith","text":"(js, jvm) fun endsWith(suffix: ByteString ): Boolean (native) fun endsWith(suffix: ByteString ): <ERROR CLASS> (js, jvm) fun endsWith(suffix: ByteArray ): Boolean (native) fun endsWith(suffix: ByteArray ): <ERROR CLASS>","title":"endsWith"},{"location":"2.x/okio/okio/-byte-string/equals/","text":"okio / okio / ByteString / equals equals \u00b6 (js, jvm) open fun equals(other: Any ?): Boolean (native) open fun equals(other: Any ?): <ERROR CLASS>","title":"equals - Okio"},{"location":"2.x/okio/okio/-byte-string/equals/#equals","text":"(js, jvm) open fun equals(other: Any ?): Boolean (native) open fun equals(other: Any ?): <ERROR CLASS>","title":"equals"},{"location":"2.x/okio/okio/-byte-string/get-byte/","text":"okio / okio / ByteString / getByte getByte \u00b6 (jvm) @JvmName(\"-deprecated_getByte\") fun ~~getByte~~(index: Int ): Byte Deprecated: moved to operator function","title":"getByte - Okio"},{"location":"2.x/okio/okio/-byte-string/get-byte/#getbyte","text":"(jvm) @JvmName(\"-deprecated_getByte\") fun ~~getByte~~(index: Int ): Byte Deprecated: moved to operator function","title":"getByte"},{"location":"2.x/okio/okio/-byte-string/get/","text":"okio / okio / ByteString / get get \u00b6 (js, jvm) @JvmName(\"getByte\") operator fun get(index: Int ): Byte (native) operator fun get(index: Int ): Byte Returns the byte at index .","title":"get - Okio"},{"location":"2.x/okio/okio/-byte-string/get/#get","text":"(js, jvm) @JvmName(\"getByte\") operator fun get(index: Int ): Byte (native) operator fun get(index: Int ): Byte Returns the byte at index .","title":"get"},{"location":"2.x/okio/okio/-byte-string/hash-code/","text":"okio / okio / ByteString / hashCode hashCode \u00b6 (js, jvm) open fun hashCode(): Int (native) open fun hashCode(): <ERROR CLASS>","title":"hashCode - Okio"},{"location":"2.x/okio/okio/-byte-string/hash-code/#hashcode","text":"(js, jvm) open fun hashCode(): Int (native) open fun hashCode(): <ERROR CLASS>","title":"hashCode"},{"location":"2.x/okio/okio/-byte-string/hex/","text":"okio / okio / ByteString / hex hex \u00b6 (js, jvm) fun hex(): String (native) open fun hex(): String Returns this byte string encoded in hexadecimal.","title":"hex - Okio"},{"location":"2.x/okio/okio/-byte-string/hex/#hex","text":"(js, jvm) fun hex(): String (native) open fun hex(): String Returns this byte string encoded in hexadecimal.","title":"hex"},{"location":"2.x/okio/okio/-byte-string/hmac-sha1/","text":"okio / okio / ByteString / hmacSha1 hmacSha1 \u00b6 (jvm) open fun hmacSha1(key: ByteString ): ByteString Returns the 160-bit SHA-1 HMAC of this byte string.","title":"hmacSha1 - Okio"},{"location":"2.x/okio/okio/-byte-string/hmac-sha1/#hmacsha1","text":"(jvm) open fun hmacSha1(key: ByteString ): ByteString Returns the 160-bit SHA-1 HMAC of this byte string.","title":"hmacSha1"},{"location":"2.x/okio/okio/-byte-string/hmac-sha256/","text":"okio / okio / ByteString / hmacSha256 hmacSha256 \u00b6 (jvm) open fun hmacSha256(key: ByteString ): ByteString Returns the 256-bit SHA-256 HMAC of this byte string.","title":"hmacSha256 - Okio"},{"location":"2.x/okio/okio/-byte-string/hmac-sha256/#hmacsha256","text":"(jvm) open fun hmacSha256(key: ByteString ): ByteString Returns the 256-bit SHA-256 HMAC of this byte string.","title":"hmacSha256"},{"location":"2.x/okio/okio/-byte-string/hmac-sha512/","text":"okio / okio / ByteString / hmacSha512 hmacSha512 \u00b6 (jvm) open fun hmacSha512(key: ByteString ): ByteString Returns the 512-bit SHA-512 HMAC of this byte string.","title":"hmacSha512 - Okio"},{"location":"2.x/okio/okio/-byte-string/hmac-sha512/#hmacsha512","text":"(jvm) open fun hmacSha512(key: ByteString ): ByteString Returns the 512-bit SHA-512 HMAC of this byte string.","title":"hmacSha512"},{"location":"2.x/okio/okio/-byte-string/index-of/","text":"okio / okio / ByteString / indexOf indexOf \u00b6 (js, jvm) @JvmOverloads fun indexOf(other: ByteString , fromIndex: Int = 0): Int (native) fun indexOf(other: ByteString , fromIndex: Int ): <ERROR CLASS> (js, jvm) @JvmOverloads fun indexOf(other: ByteArray , fromIndex: Int = 0): Int (native) open fun indexOf(other: ByteArray , fromIndex: Int ): <ERROR CLASS>","title":"indexOf - Okio"},{"location":"2.x/okio/okio/-byte-string/index-of/#indexof","text":"(js, jvm) @JvmOverloads fun indexOf(other: ByteString , fromIndex: Int = 0): Int (native) fun indexOf(other: ByteString , fromIndex: Int ): <ERROR CLASS> (js, jvm) @JvmOverloads fun indexOf(other: ByteArray , fromIndex: Int = 0): Int (native) open fun indexOf(other: ByteArray , fromIndex: Int ): <ERROR CLASS>","title":"indexOf"},{"location":"2.x/okio/okio/-byte-string/last-index-of/","text":"okio / okio / ByteString / lastIndexOf lastIndexOf \u00b6 (js, jvm) fun lastIndexOf(other: ByteString , fromIndex: Int = size): Int (native) fun lastIndexOf(other: ByteString , fromIndex: Int ): <ERROR CLASS> (js, jvm) fun lastIndexOf(other: ByteArray , fromIndex: Int = size): Int (native) open fun lastIndexOf(other: ByteArray , fromIndex: Int ): <ERROR CLASS>","title":"lastIndexOf - Okio"},{"location":"2.x/okio/okio/-byte-string/last-index-of/#lastindexof","text":"(js, jvm) fun lastIndexOf(other: ByteString , fromIndex: Int = size): Int (native) fun lastIndexOf(other: ByteString , fromIndex: Int ): <ERROR CLASS> (js, jvm) fun lastIndexOf(other: ByteArray , fromIndex: Int = size): Int (native) open fun lastIndexOf(other: ByteArray , fromIndex: Int ): <ERROR CLASS>","title":"lastIndexOf"},{"location":"2.x/okio/okio/-byte-string/md5/","text":"okio / okio / ByteString / md5 md5 \u00b6 (jvm) open fun md5(): ByteString Returns the 128-bit MD5 hash of this byte string.","title":"md5 - Okio"},{"location":"2.x/okio/okio/-byte-string/md5/#md5","text":"(jvm) open fun md5(): ByteString Returns the 128-bit MD5 hash of this byte string.","title":"md5"},{"location":"2.x/okio/okio/-byte-string/of/","text":"okio / okio / ByteString / of of \u00b6 (js, jvm) @JvmStatic fun of(vararg data: Byte ): ByteString (native) fun of(vararg data: Byte ): <ERROR CLASS> Returns a new byte string containing a clone of the bytes of data . (jvm) @JvmName(\"-deprecated_of\") fun ~~of~~(buffer: ByteBuffer ): ByteString Deprecated: moved to extension function @JvmName(\"-deprecated_of\") fun ~~of~~(array: ByteArray , offset: Int , byteCount: Int ): ByteString Deprecated: moved to extension function","title":"of - Okio"},{"location":"2.x/okio/okio/-byte-string/of/#of","text":"(js, jvm) @JvmStatic fun of(vararg data: Byte ): ByteString (native) fun of(vararg data: Byte ): <ERROR CLASS> Returns a new byte string containing a clone of the bytes of data . (jvm) @JvmName(\"-deprecated_of\") fun ~~of~~(buffer: ByteBuffer ): ByteString Deprecated: moved to extension function @JvmName(\"-deprecated_of\") fun ~~of~~(array: ByteArray , offset: Int , byteCount: Int ): ByteString Deprecated: moved to extension function","title":"of"},{"location":"2.x/okio/okio/-byte-string/range-equals/","text":"okio / okio / ByteString / rangeEquals rangeEquals \u00b6 (js, jvm) fun rangeEquals(offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean (native) open fun rangeEquals(offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean (js, jvm) fun rangeEquals(offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean (native) open fun rangeEquals(offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean Returns true if the bytes of this in [offset..offset+byteCount) equal the bytes of other in [otherOffset..otherOffset+byteCount) . Returns false if either range is out of bounds.","title":"rangeEquals - Okio"},{"location":"2.x/okio/okio/-byte-string/range-equals/#rangeequals","text":"(js, jvm) fun rangeEquals(offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean (native) open fun rangeEquals(offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean (js, jvm) fun rangeEquals(offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean (native) open fun rangeEquals(offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean Returns true if the bytes of this in [offset..offset+byteCount) equal the bytes of other in [otherOffset..otherOffset+byteCount) . Returns false if either range is out of bounds.","title":"rangeEquals"},{"location":"2.x/okio/okio/-byte-string/read-byte-string/","text":"okio / okio / ByteString / readByteString readByteString \u00b6 (jvm) @JvmStatic @JvmName(\"read\") fun InputStream .readByteString(byteCount: Int ): ByteString Reads count bytes from this InputStream and returns the result. Exceptions \u00b6 java.io.EOFException - if in has fewer than count bytes to read.","title":"readByteString - Okio"},{"location":"2.x/okio/okio/-byte-string/read-byte-string/#readbytestring","text":"(jvm) @JvmStatic @JvmName(\"read\") fun InputStream .readByteString(byteCount: Int ): ByteString Reads count bytes from this InputStream and returns the result.","title":"readByteString"},{"location":"2.x/okio/okio/-byte-string/read-byte-string/#exceptions","text":"java.io.EOFException - if in has fewer than count bytes to read.","title":"Exceptions"},{"location":"2.x/okio/okio/-byte-string/read/","text":"okio / okio / ByteString / read read \u00b6 (jvm) @JvmName(\"-deprecated_read\") fun ~~read~~(inputstream: InputStream , byteCount: Int ): ByteString Deprecated: moved to extension function","title":"read - Okio"},{"location":"2.x/okio/okio/-byte-string/read/#read","text":"(jvm) @JvmName(\"-deprecated_read\") fun ~~read~~(inputstream: InputStream , byteCount: Int ): ByteString Deprecated: moved to extension function","title":"read"},{"location":"2.x/okio/okio/-byte-string/sha1/","text":"okio / okio / ByteString / sha1 sha1 \u00b6 (jvm) open fun sha1(): ByteString Returns the 160-bit SHA-1 hash of this byte string.","title":"sha1 - Okio"},{"location":"2.x/okio/okio/-byte-string/sha1/#sha1","text":"(jvm) open fun sha1(): ByteString Returns the 160-bit SHA-1 hash of this byte string.","title":"sha1"},{"location":"2.x/okio/okio/-byte-string/sha256/","text":"okio / okio / ByteString / sha256 sha256 \u00b6 (jvm) open fun sha256(): ByteString Returns the 256-bit SHA-256 hash of this byte string.","title":"sha256 - Okio"},{"location":"2.x/okio/okio/-byte-string/sha256/#sha256","text":"(jvm) open fun sha256(): ByteString Returns the 256-bit SHA-256 hash of this byte string.","title":"sha256"},{"location":"2.x/okio/okio/-byte-string/sha512/","text":"okio / okio / ByteString / sha512 sha512 \u00b6 (jvm) open fun sha512(): ByteString Returns the 512-bit SHA-512 hash of this byte string.","title":"sha512 - Okio"},{"location":"2.x/okio/okio/-byte-string/sha512/#sha512","text":"(jvm) open fun sha512(): ByteString Returns the 512-bit SHA-512 hash of this byte string.","title":"sha512"},{"location":"2.x/okio/okio/-byte-string/size/","text":"okio / okio / ByteString / size size \u00b6 (js, jvm) val size: Int (native) val size: <ERROR CLASS> Returns the number of bytes in this ByteString. (jvm) @JvmName(\"-deprecated_size\") fun ~~size~~(): Int Deprecated: moved to val","title":"size - Okio"},{"location":"2.x/okio/okio/-byte-string/size/#size","text":"(js, jvm) val size: Int (native) val size: <ERROR CLASS> Returns the number of bytes in this ByteString. (jvm) @JvmName(\"-deprecated_size\") fun ~~size~~(): Int Deprecated: moved to val","title":"size"},{"location":"2.x/okio/okio/-byte-string/starts-with/","text":"okio / okio / ByteString / startsWith startsWith \u00b6 (js, jvm) fun startsWith(prefix: ByteString ): Boolean (native) fun startsWith(prefix: ByteString ): <ERROR CLASS> (js, jvm) fun startsWith(prefix: ByteArray ): Boolean (native) fun startsWith(prefix: ByteArray ): <ERROR CLASS>","title":"startsWith - Okio"},{"location":"2.x/okio/okio/-byte-string/starts-with/#startswith","text":"(js, jvm) fun startsWith(prefix: ByteString ): Boolean (native) fun startsWith(prefix: ByteString ): <ERROR CLASS> (js, jvm) fun startsWith(prefix: ByteArray ): Boolean (native) fun startsWith(prefix: ByteArray ): <ERROR CLASS>","title":"startsWith"},{"location":"2.x/okio/okio/-byte-string/string/","text":"okio / okio / ByteString / string string \u00b6 (jvm) open fun string(charset: Charset ): String Constructs a new String by decoding the bytes using charset .","title":"string - Okio"},{"location":"2.x/okio/okio/-byte-string/string/#string","text":"(jvm) open fun string(charset: Charset ): String Constructs a new String by decoding the bytes using charset .","title":"string"},{"location":"2.x/okio/okio/-byte-string/substring/","text":"okio / okio / ByteString / substring substring \u00b6 (js, jvm) fun substring(beginIndex: Int = 0, endIndex: Int = size): ByteString (native) open fun substring(beginIndex: Int , endIndex: Int ): ByteString Returns a byte string that is a substring of this byte string, beginning at the specified beginIndex and ends at the specified endIndex . Returns this byte string if beginIndex is 0 and endIndex is the length of this byte string.","title":"substring - Okio"},{"location":"2.x/okio/okio/-byte-string/substring/#substring","text":"(js, jvm) fun substring(beginIndex: Int = 0, endIndex: Int = size): ByteString (native) open fun substring(beginIndex: Int , endIndex: Int ): ByteString Returns a byte string that is a substring of this byte string, beginning at the specified beginIndex and ends at the specified endIndex . Returns this byte string if beginIndex is 0 and endIndex is the length of this byte string.","title":"substring"},{"location":"2.x/okio/okio/-byte-string/to-ascii-lowercase/","text":"okio / okio / ByteString / toAsciiLowercase toAsciiLowercase \u00b6 (js, jvm) fun toAsciiLowercase(): ByteString (native) open fun toAsciiLowercase(): ByteString Returns a byte string equal to this byte string, but with the bytes \u2018A\u2019 through \u2018Z\u2019 replaced with the corresponding byte in \u2018a\u2019 through \u2018z\u2019. Returns this byte string if it contains no bytes in \u2018A\u2019 through \u2018Z\u2019.","title":"toAsciiLowercase - Okio"},{"location":"2.x/okio/okio/-byte-string/to-ascii-lowercase/#toasciilowercase","text":"(js, jvm) fun toAsciiLowercase(): ByteString (native) open fun toAsciiLowercase(): ByteString Returns a byte string equal to this byte string, but with the bytes \u2018A\u2019 through \u2018Z\u2019 replaced with the corresponding byte in \u2018a\u2019 through \u2018z\u2019. Returns this byte string if it contains no bytes in \u2018A\u2019 through \u2018Z\u2019.","title":"toAsciiLowercase"},{"location":"2.x/okio/okio/-byte-string/to-ascii-uppercase/","text":"okio / okio / ByteString / toAsciiUppercase toAsciiUppercase \u00b6 (js, jvm) fun toAsciiUppercase(): ByteString (native) open fun toAsciiUppercase(): ByteString Returns a byte string equal to this byte string, but with the bytes \u2018a\u2019 through \u2018z\u2019 replaced with the corresponding byte in \u2018A\u2019 through \u2018Z\u2019. Returns this byte string if it contains no bytes in \u2018a\u2019 through \u2018z\u2019.","title":"toAsciiUppercase - Okio"},{"location":"2.x/okio/okio/-byte-string/to-ascii-uppercase/#toasciiuppercase","text":"(js, jvm) fun toAsciiUppercase(): ByteString (native) open fun toAsciiUppercase(): ByteString Returns a byte string equal to this byte string, but with the bytes \u2018a\u2019 through \u2018z\u2019 replaced with the corresponding byte in \u2018A\u2019 through \u2018Z\u2019. Returns this byte string if it contains no bytes in \u2018a\u2019 through \u2018z\u2019.","title":"toAsciiUppercase"},{"location":"2.x/okio/okio/-byte-string/to-byte-array/","text":"okio / okio / ByteString / toByteArray toByteArray \u00b6 (js, jvm) fun toByteArray(): ByteArray (native) open fun toByteArray(): <ERROR CLASS> Returns a byte array containing a copy of the bytes in this ByteString .","title":"toByteArray - Okio"},{"location":"2.x/okio/okio/-byte-string/to-byte-array/#tobytearray","text":"(js, jvm) fun toByteArray(): ByteArray (native) open fun toByteArray(): <ERROR CLASS> Returns a byte array containing a copy of the bytes in this ByteString .","title":"toByteArray"},{"location":"2.x/okio/okio/-byte-string/to-byte-string/","text":"okio / okio / ByteString / toByteString toByteString \u00b6 (js, jvm) @JvmStatic fun ByteArray .toByteString(offset: Int = 0, byteCount: Int = size): ByteString (native) fun ByteArray .toByteString(offset: Int , byteCount: Int ): ByteString Returns a new ByteString containing a copy of byteCount bytes of this ByteArray starting at offset . (jvm) @JvmStatic @JvmName(\"of\") fun ByteBuffer .toByteString(): ByteString Returns a ByteString containing a copy of this ByteBuffer .","title":"toByteString - Okio"},{"location":"2.x/okio/okio/-byte-string/to-byte-string/#tobytestring","text":"(js, jvm) @JvmStatic fun ByteArray .toByteString(offset: Int = 0, byteCount: Int = size): ByteString (native) fun ByteArray .toByteString(offset: Int , byteCount: Int ): ByteString Returns a new ByteString containing a copy of byteCount bytes of this ByteArray starting at offset . (jvm) @JvmStatic @JvmName(\"of\") fun ByteBuffer .toByteString(): ByteString Returns a ByteString containing a copy of this ByteBuffer .","title":"toByteString"},{"location":"2.x/okio/okio/-byte-string/to-string/","text":"okio / okio / ByteString / toString toString \u00b6 (js, jvm) open fun toString(): String (native) open fun toString(): <ERROR CLASS> Returns a human-readable string that describes the contents of this byte string. Typically this is a string like [text=Hello] or [hex=0000ffff] .","title":"toString - Okio"},{"location":"2.x/okio/okio/-byte-string/to-string/#tostring","text":"(js, jvm) open fun toString(): String (native) open fun toString(): <ERROR CLASS> Returns a human-readable string that describes the contents of this byte string. Typically this is a string like [text=Hello] or [hex=0000ffff] .","title":"toString"},{"location":"2.x/okio/okio/-byte-string/utf8/","text":"okio / okio / ByteString / utf8 utf8 \u00b6 (js, jvm) fun utf8(): String (native) open fun utf8(): String Constructs a new String by decoding the bytes as UTF-8 .","title":"utf8 - Okio"},{"location":"2.x/okio/okio/-byte-string/utf8/#utf8","text":"(js, jvm) fun utf8(): String (native) open fun utf8(): String Constructs a new String by decoding the bytes as UTF-8 .","title":"utf8"},{"location":"2.x/okio/okio/-byte-string/write/","text":"okio / okio / ByteString / write write \u00b6 (jvm) open fun write(out: OutputStream ): Unit Writes the contents of this byte string to out .","title":"write - Okio"},{"location":"2.x/okio/okio/-byte-string/write/#write","text":"(jvm) open fun write(out: OutputStream ): Unit Writes the contents of this byte string to out .","title":"write"},{"location":"2.x/okio/okio/-deflater-sink/","text":"okio / okio / DeflaterSink DeflaterSink \u00b6 (jvm) class DeflaterSink : Sink A sink that uses DEFLATE to compress data written to another source. Sync flush \u00b6 Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing. This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it. Constructors \u00b6 Name Summary (jvm) <init> DeflaterSink(sink: Sink , deflater: Deflater ) Functions \u00b6 Name Summary (jvm) close fun close(): Unit (jvm) flush fun flush(): Unit (jvm) timeout fun timeout(): Timeout (jvm) toString fun toString(): String (jvm) write fun write(source: Buffer , byteCount: Long ): Unit Extension Functions \u00b6 Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink","title":"DeflaterSink - Okio"},{"location":"2.x/okio/okio/-deflater-sink/#deflatersink","text":"(jvm) class DeflaterSink : Sink A sink that uses DEFLATE to compress data written to another source.","title":"DeflaterSink"},{"location":"2.x/okio/okio/-deflater-sink/#sync-flush","text":"Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing. This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it.","title":"Sync flush"},{"location":"2.x/okio/okio/-deflater-sink/#constructors","text":"Name Summary (jvm) <init> DeflaterSink(sink: Sink , deflater: Deflater )","title":"Constructors"},{"location":"2.x/okio/okio/-deflater-sink/#functions","text":"Name Summary (jvm) close fun close(): Unit (jvm) flush fun flush(): Unit (jvm) timeout fun timeout(): Timeout (jvm) toString fun toString(): String (jvm) write fun write(source: Buffer , byteCount: Long ): Unit","title":"Functions"},{"location":"2.x/okio/okio/-deflater-sink/#extension-functions","text":"Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink","title":"Extension Functions"},{"location":"2.x/okio/okio/-deflater-sink/-init-/","text":"okio / okio / DeflaterSink / <init> <init> \u00b6 (jvm) DeflaterSink(sink: Sink , deflater: Deflater )","title":" init "},{"location":"2.x/okio/okio/-deflater-sink/-init-/#init","text":"(jvm) DeflaterSink(sink: Sink , deflater: Deflater )","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-deflater-sink/close/","text":"okio / okio / DeflaterSink / close close \u00b6 (jvm) fun close(): Unit","title":"close - Okio"},{"location":"2.x/okio/okio/-deflater-sink/close/#close","text":"(jvm) fun close(): Unit","title":"close"},{"location":"2.x/okio/okio/-deflater-sink/flush/","text":"okio / okio / DeflaterSink / flush flush \u00b6 (jvm) fun flush(): Unit","title":"flush - Okio"},{"location":"2.x/okio/okio/-deflater-sink/flush/#flush","text":"(jvm) fun flush(): Unit","title":"flush"},{"location":"2.x/okio/okio/-deflater-sink/timeout/","text":"okio / okio / DeflaterSink / timeout timeout \u00b6 (jvm) fun timeout(): Timeout","title":"timeout - Okio"},{"location":"2.x/okio/okio/-deflater-sink/timeout/#timeout","text":"(jvm) fun timeout(): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-deflater-sink/to-string/","text":"okio / okio / DeflaterSink / toString toString \u00b6 (jvm) fun toString(): String","title":"toString - Okio"},{"location":"2.x/okio/okio/-deflater-sink/to-string/#tostring","text":"(jvm) fun toString(): String","title":"toString"},{"location":"2.x/okio/okio/-deflater-sink/write/","text":"okio / okio / DeflaterSink / write write \u00b6 (jvm) fun write(source: Buffer , byteCount: Long ): Unit","title":"write - Okio"},{"location":"2.x/okio/okio/-deflater-sink/write/#write","text":"(jvm) fun write(source: Buffer , byteCount: Long ): Unit","title":"write"},{"location":"2.x/okio/okio/-e-o-f-exception/","text":"okio / okio / EOFException EOFException \u00b6 (js, jvm, native) open class EOFException : IOException Constructors \u00b6 Name Summary <init> (js, jvm) <init>(message: String ? = null) (native) <init>(message: String ?)","title":"EOFException - Okio"},{"location":"2.x/okio/okio/-e-o-f-exception/#eofexception","text":"(js, jvm, native) open class EOFException : IOException","title":"EOFException"},{"location":"2.x/okio/okio/-e-o-f-exception/#constructors","text":"Name Summary <init> (js, jvm) <init>(message: String ? = null) (native) <init>(message: String ?)","title":"Constructors"},{"location":"2.x/okio/okio/-e-o-f-exception/-init-/","text":"okio / okio / EOFException / <init> <init> \u00b6 (js, jvm) <init>(message: String ? = null) (native) <init>(message: String ?)","title":" init "},{"location":"2.x/okio/okio/-e-o-f-exception/-init-/#init","text":"(js, jvm) <init>(message: String ? = null) (native) <init>(message: String ?)","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-forwarding-sink/","text":"okio / okio / ForwardingSink ForwardingSink \u00b6 (jvm) abstract class ForwardingSink : Sink A Sink which forwards calls to another. Useful for subclassing. Constructors \u00b6 Name Summary (jvm) <init> A Sink which forwards calls to another. Useful for subclassing. ForwardingSink(delegate: Sink ) Properties \u00b6 Name Summary (jvm) delegate Sink to which this instance is delegating. val delegate: Sink Functions \u00b6 Name Summary (jvm) close open fun close(): Unit (jvm) delegate fun ~~delegate~~(): Sink (jvm) flush open fun flush(): Unit (jvm) timeout open fun timeout(): Timeout (jvm) toString open fun toString(): String (jvm) write open fun write(source: Buffer , byteCount: Long ): Unit Extension Functions \u00b6 Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink Inheritors \u00b6 Name Summary (jvm) HashingSink A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value. class HashingSink : ForwardingSink","title":"ForwardingSink - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/#forwardingsink","text":"(jvm) abstract class ForwardingSink : Sink A Sink which forwards calls to another. Useful for subclassing.","title":"ForwardingSink"},{"location":"2.x/okio/okio/-forwarding-sink/#constructors","text":"Name Summary (jvm) <init> A Sink which forwards calls to another. Useful for subclassing. ForwardingSink(delegate: Sink )","title":"Constructors"},{"location":"2.x/okio/okio/-forwarding-sink/#properties","text":"Name Summary (jvm) delegate Sink to which this instance is delegating. val delegate: Sink","title":"Properties"},{"location":"2.x/okio/okio/-forwarding-sink/#functions","text":"Name Summary (jvm) close open fun close(): Unit (jvm) delegate fun ~~delegate~~(): Sink (jvm) flush open fun flush(): Unit (jvm) timeout open fun timeout(): Timeout (jvm) toString open fun toString(): String (jvm) write open fun write(source: Buffer , byteCount: Long ): Unit","title":"Functions"},{"location":"2.x/okio/okio/-forwarding-sink/#extension-functions","text":"Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink","title":"Extension Functions"},{"location":"2.x/okio/okio/-forwarding-sink/#inheritors","text":"Name Summary (jvm) HashingSink A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value. class HashingSink : ForwardingSink","title":"Inheritors"},{"location":"2.x/okio/okio/-forwarding-sink/-init-/","text":"okio / okio / ForwardingSink / <init> <init> \u00b6 (jvm) ForwardingSink(delegate: Sink ) A Sink which forwards calls to another. Useful for subclassing.","title":" init "},{"location":"2.x/okio/okio/-forwarding-sink/-init-/#init","text":"(jvm) ForwardingSink(delegate: Sink ) A Sink which forwards calls to another. Useful for subclassing.","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-forwarding-sink/close/","text":"okio / okio / ForwardingSink / close close \u00b6 (jvm) open fun close(): Unit","title":"close - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/close/#close","text":"(jvm) open fun close(): Unit","title":"close"},{"location":"2.x/okio/okio/-forwarding-sink/delegate/","text":"okio / okio / ForwardingSink / delegate delegate \u00b6 (jvm) @JvmName(\"-deprecated_delegate\") fun ~~delegate~~(): Sink Deprecated: moved to val (jvm) val delegate: Sink Sink to which this instance is delegating.","title":"delegate - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/delegate/#delegate","text":"(jvm) @JvmName(\"-deprecated_delegate\") fun ~~delegate~~(): Sink Deprecated: moved to val (jvm) val delegate: Sink Sink to which this instance is delegating.","title":"delegate"},{"location":"2.x/okio/okio/-forwarding-sink/flush/","text":"okio / okio / ForwardingSink / flush flush \u00b6 (jvm) open fun flush(): Unit","title":"flush - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/flush/#flush","text":"(jvm) open fun flush(): Unit","title":"flush"},{"location":"2.x/okio/okio/-forwarding-sink/timeout/","text":"okio / okio / ForwardingSink / timeout timeout \u00b6 (jvm) open fun timeout(): Timeout","title":"timeout - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/timeout/#timeout","text":"(jvm) open fun timeout(): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-forwarding-sink/to-string/","text":"okio / okio / ForwardingSink / toString toString \u00b6 (jvm) open fun toString(): String","title":"toString - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/to-string/#tostring","text":"(jvm) open fun toString(): String","title":"toString"},{"location":"2.x/okio/okio/-forwarding-sink/write/","text":"okio / okio / ForwardingSink / write write \u00b6 (jvm) open fun write(source: Buffer , byteCount: Long ): Unit","title":"write - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/write/#write","text":"(jvm) open fun write(source: Buffer , byteCount: Long ): Unit","title":"write"},{"location":"2.x/okio/okio/-forwarding-source/","text":"okio / okio / ForwardingSource ForwardingSource \u00b6 (jvm) abstract class ForwardingSource : Source A Source which forwards calls to another. Useful for subclassing. Constructors \u00b6 Name Summary (jvm) <init> A Source which forwards calls to another. Useful for subclassing. ForwardingSource(delegate: Source ) Properties \u00b6 Name Summary (jvm) delegate Source to which this instance is delegating. val delegate: Source Functions \u00b6 Name Summary (jvm) close open fun close(): Unit (jvm) delegate fun ~~delegate~~(): Source (jvm) read open fun read(sink: Buffer , byteCount: Long ): Long (jvm) timeout open fun timeout(): Timeout (jvm) toString open fun toString(): String Extension Functions \u00b6 Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource Inheritors \u00b6 Name Summary (jvm) HashingSource A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value. class HashingSource : ForwardingSource","title":"ForwardingSource - Okio"},{"location":"2.x/okio/okio/-forwarding-source/#forwardingsource","text":"(jvm) abstract class ForwardingSource : Source A Source which forwards calls to another. Useful for subclassing.","title":"ForwardingSource"},{"location":"2.x/okio/okio/-forwarding-source/#constructors","text":"Name Summary (jvm) <init> A Source which forwards calls to another. Useful for subclassing. ForwardingSource(delegate: Source )","title":"Constructors"},{"location":"2.x/okio/okio/-forwarding-source/#properties","text":"Name Summary (jvm) delegate Source to which this instance is delegating. val delegate: Source","title":"Properties"},{"location":"2.x/okio/okio/-forwarding-source/#functions","text":"Name Summary (jvm) close open fun close(): Unit (jvm) delegate fun ~~delegate~~(): Source (jvm) read open fun read(sink: Buffer , byteCount: Long ): Long (jvm) timeout open fun timeout(): Timeout (jvm) toString open fun toString(): String","title":"Functions"},{"location":"2.x/okio/okio/-forwarding-source/#extension-functions","text":"Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"Extension Functions"},{"location":"2.x/okio/okio/-forwarding-source/#inheritors","text":"Name Summary (jvm) HashingSource A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value. class HashingSource : ForwardingSource","title":"Inheritors"},{"location":"2.x/okio/okio/-forwarding-source/-init-/","text":"okio / okio / ForwardingSource / <init> <init> \u00b6 (jvm) ForwardingSource(delegate: Source ) A Source which forwards calls to another. Useful for subclassing.","title":" init "},{"location":"2.x/okio/okio/-forwarding-source/-init-/#init","text":"(jvm) ForwardingSource(delegate: Source ) A Source which forwards calls to another. Useful for subclassing.","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-forwarding-source/close/","text":"okio / okio / ForwardingSource / close close \u00b6 (jvm) open fun close(): Unit","title":"close - Okio"},{"location":"2.x/okio/okio/-forwarding-source/close/#close","text":"(jvm) open fun close(): Unit","title":"close"},{"location":"2.x/okio/okio/-forwarding-source/delegate/","text":"okio / okio / ForwardingSource / delegate delegate \u00b6 (jvm) @JvmName(\"-deprecated_delegate\") fun ~~delegate~~(): Source Deprecated: moved to val (jvm) val delegate: Source Source to which this instance is delegating.","title":"delegate - Okio"},{"location":"2.x/okio/okio/-forwarding-source/delegate/#delegate","text":"(jvm) @JvmName(\"-deprecated_delegate\") fun ~~delegate~~(): Source Deprecated: moved to val (jvm) val delegate: Source Source to which this instance is delegating.","title":"delegate"},{"location":"2.x/okio/okio/-forwarding-source/read/","text":"okio / okio / ForwardingSource / read read \u00b6 (jvm) open fun read(sink: Buffer , byteCount: Long ): Long","title":"read - Okio"},{"location":"2.x/okio/okio/-forwarding-source/read/#read","text":"(jvm) open fun read(sink: Buffer , byteCount: Long ): Long","title":"read"},{"location":"2.x/okio/okio/-forwarding-source/timeout/","text":"okio / okio / ForwardingSource / timeout timeout \u00b6 (jvm) open fun timeout(): Timeout","title":"timeout - Okio"},{"location":"2.x/okio/okio/-forwarding-source/timeout/#timeout","text":"(jvm) open fun timeout(): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-forwarding-source/to-string/","text":"okio / okio / ForwardingSource / toString toString \u00b6 (jvm) open fun toString(): String","title":"toString - Okio"},{"location":"2.x/okio/okio/-forwarding-source/to-string/#tostring","text":"(jvm) open fun toString(): String","title":"toString"},{"location":"2.x/okio/okio/-forwarding-timeout/","text":"okio / okio / ForwardingTimeout ForwardingTimeout \u00b6 (jvm) open class ForwardingTimeout : Timeout A Timeout which forwards calls to another. Useful for subclassing. Constructors \u00b6 Name Summary (jvm) <init> A Timeout which forwards calls to another. Useful for subclassing. ForwardingTimeout(delegate: Timeout ) Properties \u00b6 Name Summary (jvm) delegate var delegate: Timeout Functions \u00b6 Name Summary (jvm) clearDeadline Clears the deadline. open fun clearDeadline(): Timeout (jvm) clearTimeout Clears the timeout. Operating system timeouts may still apply. open fun clearTimeout(): Timeout (jvm) deadlineNanoTime Returns the nano time when the deadline will be reached. open fun deadlineNanoTime(): Long Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. open fun deadlineNanoTime(deadlineNanoTime: Long ): Timeout (jvm) hasDeadline Returns true if a deadline is enabled. open fun hasDeadline(): Boolean (jvm) setDelegate fun setDelegate(delegate: Timeout ): ForwardingTimeout (jvm) throwIfReached Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. open fun throwIfReached(): Unit (jvm) timeout Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail. open fun timeout(timeout: Long , unit: TimeUnit ): Timeout (jvm) timeoutNanos Returns the timeout in nanoseconds, or 0 for no timeout. open fun timeoutNanos(): Long Inherited Functions \u00b6 Name Summary (jvm) deadline Set a deadline of now plus duration time. fun deadline(duration: Long , unit: TimeUnit ): Timeout (jvm) intersectWith Applies the minimum intersection between this timeout and other , run block , then finally rollback this timeout\u2019s values. fun intersectWith(other: Timeout , block: () -> Unit ): Unit (jvm) waitUntilNotified Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor . fun waitUntilNotified(monitor: Any ): Unit","title":"ForwardingTimeout - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/#forwardingtimeout","text":"(jvm) open class ForwardingTimeout : Timeout A Timeout which forwards calls to another. Useful for subclassing.","title":"ForwardingTimeout"},{"location":"2.x/okio/okio/-forwarding-timeout/#constructors","text":"Name Summary (jvm) <init> A Timeout which forwards calls to another. Useful for subclassing. ForwardingTimeout(delegate: Timeout )","title":"Constructors"},{"location":"2.x/okio/okio/-forwarding-timeout/#properties","text":"Name Summary (jvm) delegate var delegate: Timeout","title":"Properties"},{"location":"2.x/okio/okio/-forwarding-timeout/#functions","text":"Name Summary (jvm) clearDeadline Clears the deadline. open fun clearDeadline(): Timeout (jvm) clearTimeout Clears the timeout. Operating system timeouts may still apply. open fun clearTimeout(): Timeout (jvm) deadlineNanoTime Returns the nano time when the deadline will be reached. open fun deadlineNanoTime(): Long Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. open fun deadlineNanoTime(deadlineNanoTime: Long ): Timeout (jvm) hasDeadline Returns true if a deadline is enabled. open fun hasDeadline(): Boolean (jvm) setDelegate fun setDelegate(delegate: Timeout ): ForwardingTimeout (jvm) throwIfReached Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. open fun throwIfReached(): Unit (jvm) timeout Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail. open fun timeout(timeout: Long , unit: TimeUnit ): Timeout (jvm) timeoutNanos Returns the timeout in nanoseconds, or 0 for no timeout. open fun timeoutNanos(): Long","title":"Functions"},{"location":"2.x/okio/okio/-forwarding-timeout/#inherited-functions","text":"Name Summary (jvm) deadline Set a deadline of now plus duration time. fun deadline(duration: Long , unit: TimeUnit ): Timeout (jvm) intersectWith Applies the minimum intersection between this timeout and other , run block , then finally rollback this timeout\u2019s values. fun intersectWith(other: Timeout , block: () -> Unit ): Unit (jvm) waitUntilNotified Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor . fun waitUntilNotified(monitor: Any ): Unit","title":"Inherited Functions"},{"location":"2.x/okio/okio/-forwarding-timeout/-init-/","text":"okio / okio / ForwardingTimeout / <init> <init> \u00b6 (jvm) ForwardingTimeout(delegate: Timeout ) A Timeout which forwards calls to another. Useful for subclassing.","title":" init "},{"location":"2.x/okio/okio/-forwarding-timeout/-init-/#init","text":"(jvm) ForwardingTimeout(delegate: Timeout ) A Timeout which forwards calls to another. Useful for subclassing.","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-forwarding-timeout/clear-deadline/","text":"okio / okio / ForwardingTimeout / clearDeadline clearDeadline \u00b6 (jvm) open fun clearDeadline(): Timeout Clears the deadline.","title":"clearDeadline - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/clear-deadline/#cleardeadline","text":"(jvm) open fun clearDeadline(): Timeout Clears the deadline.","title":"clearDeadline"},{"location":"2.x/okio/okio/-forwarding-timeout/clear-timeout/","text":"okio / okio / ForwardingTimeout / clearTimeout clearTimeout \u00b6 (jvm) open fun clearTimeout(): Timeout Clears the timeout. Operating system timeouts may still apply.","title":"clearTimeout - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/clear-timeout/#cleartimeout","text":"(jvm) open fun clearTimeout(): Timeout Clears the timeout. Operating system timeouts may still apply.","title":"clearTimeout"},{"location":"2.x/okio/okio/-forwarding-timeout/deadline-nano-time/","text":"okio / okio / ForwardingTimeout / deadlineNanoTime deadlineNanoTime \u00b6 (jvm) open fun deadlineNanoTime(): Long Returns the nano time when the deadline will be reached. Exceptions \u00b6 IllegalStateException - if no deadline is set.(jvm) open fun deadlineNanoTime(deadlineNanoTime: Long ): Timeout Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations.","title":"deadlineNanoTime - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/deadline-nano-time/#deadlinenanotime","text":"(jvm) open fun deadlineNanoTime(): Long Returns the nano time when the deadline will be reached.","title":"deadlineNanoTime"},{"location":"2.x/okio/okio/-forwarding-timeout/deadline-nano-time/#exceptions","text":"IllegalStateException - if no deadline is set.(jvm) open fun deadlineNanoTime(deadlineNanoTime: Long ): Timeout Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations.","title":"Exceptions"},{"location":"2.x/okio/okio/-forwarding-timeout/delegate/","text":"okio / okio / ForwardingTimeout / delegate delegate \u00b6 (jvm) var delegate: Timeout","title":"delegate - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/delegate/#delegate","text":"(jvm) var delegate: Timeout","title":"delegate"},{"location":"2.x/okio/okio/-forwarding-timeout/has-deadline/","text":"okio / okio / ForwardingTimeout / hasDeadline hasDeadline \u00b6 (jvm) open fun hasDeadline(): Boolean Returns true if a deadline is enabled.","title":"hasDeadline - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/has-deadline/#hasdeadline","text":"(jvm) open fun hasDeadline(): Boolean Returns true if a deadline is enabled.","title":"hasDeadline"},{"location":"2.x/okio/okio/-forwarding-timeout/set-delegate/","text":"okio / okio / ForwardingTimeout / setDelegate setDelegate \u00b6 (jvm) fun setDelegate(delegate: Timeout ): ForwardingTimeout","title":"setDelegate - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/set-delegate/#setdelegate","text":"(jvm) fun setDelegate(delegate: Timeout ): ForwardingTimeout","title":"setDelegate"},{"location":"2.x/okio/okio/-forwarding-timeout/throw-if-reached/","text":"okio / okio / ForwardingTimeout / throwIfReached throwIfReached \u00b6 (jvm) open fun throwIfReached(): Unit Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation.","title":"throwIfReached - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/throw-if-reached/#throwifreached","text":"(jvm) open fun throwIfReached(): Unit Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation.","title":"throwIfReached"},{"location":"2.x/okio/okio/-forwarding-timeout/timeout-nanos/","text":"okio / okio / ForwardingTimeout / timeoutNanos timeoutNanos \u00b6 (jvm) open fun timeoutNanos(): Long Returns the timeout in nanoseconds, or 0 for no timeout.","title":"timeoutNanos - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/timeout-nanos/#timeoutnanos","text":"(jvm) open fun timeoutNanos(): Long Returns the timeout in nanoseconds, or 0 for no timeout.","title":"timeoutNanos"},{"location":"2.x/okio/okio/-forwarding-timeout/timeout/","text":"okio / okio / ForwardingTimeout / timeout timeout \u00b6 (jvm) open fun timeout(timeout: Long , unit: TimeUnit ): Timeout Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail. If timeout == 0 , operations will run indefinitely. (Operating system timeouts may still apply.)","title":"timeout - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/timeout/#timeout","text":"(jvm) open fun timeout(timeout: Long , unit: TimeUnit ): Timeout Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail. If timeout == 0 , operations will run indefinitely. (Operating system timeouts may still apply.)","title":"timeout"},{"location":"2.x/okio/okio/-gzip-sink/","text":"okio / okio / GzipSink GzipSink \u00b6 (jvm) class GzipSink : Sink A sink that uses GZIP to compress written data to another sink. Sync flush \u00b6 Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing. This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it. Constructors \u00b6 Name Summary (jvm) <init> A sink that uses GZIP to compress written data to another sink. GzipSink(sink: Sink ) Properties \u00b6 Name Summary (jvm) deflater The deflater used to compress the body. val deflater: Deflater Functions \u00b6 Name Summary (jvm) close fun close(): Unit (jvm) deflater fun ~~deflater~~(): Deflater (jvm) flush fun flush(): Unit (jvm) timeout fun timeout(): Timeout (jvm) write fun write(source: Buffer , byteCount: Long ): Unit Extension Functions \u00b6 Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink","title":"GzipSink - Okio"},{"location":"2.x/okio/okio/-gzip-sink/#gzipsink","text":"(jvm) class GzipSink : Sink A sink that uses GZIP to compress written data to another sink.","title":"GzipSink"},{"location":"2.x/okio/okio/-gzip-sink/#sync-flush","text":"Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing. This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it.","title":"Sync flush"},{"location":"2.x/okio/okio/-gzip-sink/#constructors","text":"Name Summary (jvm) <init> A sink that uses GZIP to compress written data to another sink. GzipSink(sink: Sink )","title":"Constructors"},{"location":"2.x/okio/okio/-gzip-sink/#properties","text":"Name Summary (jvm) deflater The deflater used to compress the body. val deflater: Deflater","title":"Properties"},{"location":"2.x/okio/okio/-gzip-sink/#functions","text":"Name Summary (jvm) close fun close(): Unit (jvm) deflater fun ~~deflater~~(): Deflater (jvm) flush fun flush(): Unit (jvm) timeout fun timeout(): Timeout (jvm) write fun write(source: Buffer , byteCount: Long ): Unit","title":"Functions"},{"location":"2.x/okio/okio/-gzip-sink/#extension-functions","text":"Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink","title":"Extension Functions"},{"location":"2.x/okio/okio/-gzip-sink/-init-/","text":"okio / okio / GzipSink / <init> <init> \u00b6 (jvm) GzipSink(sink: Sink ) A sink that uses GZIP to compress written data to another sink. Sync flush \u00b6 Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing. This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it.","title":" init "},{"location":"2.x/okio/okio/-gzip-sink/-init-/#init","text":"(jvm) GzipSink(sink: Sink ) A sink that uses GZIP to compress written data to another sink.","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-gzip-sink/-init-/#sync-flush","text":"Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing. This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it.","title":"Sync flush"},{"location":"2.x/okio/okio/-gzip-sink/close/","text":"okio / okio / GzipSink / close close \u00b6 (jvm) fun close(): Unit","title":"close - Okio"},{"location":"2.x/okio/okio/-gzip-sink/close/#close","text":"(jvm) fun close(): Unit","title":"close"},{"location":"2.x/okio/okio/-gzip-sink/deflater/","text":"okio / okio / GzipSink / deflater deflater \u00b6 (jvm) val deflater: Deflater The deflater used to compress the body. Getter The deflater used to compress the body. (jvm) @JvmName(\"-deprecated_deflater\") fun ~~deflater~~(): Deflater Deprecated: moved to val","title":"deflater - Okio"},{"location":"2.x/okio/okio/-gzip-sink/deflater/#deflater","text":"(jvm) val deflater: Deflater The deflater used to compress the body. Getter The deflater used to compress the body. (jvm) @JvmName(\"-deprecated_deflater\") fun ~~deflater~~(): Deflater Deprecated: moved to val","title":"deflater"},{"location":"2.x/okio/okio/-gzip-sink/flush/","text":"okio / okio / GzipSink / flush flush \u00b6 (jvm) fun flush(): Unit","title":"flush - Okio"},{"location":"2.x/okio/okio/-gzip-sink/flush/#flush","text":"(jvm) fun flush(): Unit","title":"flush"},{"location":"2.x/okio/okio/-gzip-sink/timeout/","text":"okio / okio / GzipSink / timeout timeout \u00b6 (jvm) fun timeout(): Timeout","title":"timeout - Okio"},{"location":"2.x/okio/okio/-gzip-sink/timeout/#timeout","text":"(jvm) fun timeout(): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-gzip-sink/write/","text":"okio / okio / GzipSink / write write \u00b6 (jvm) fun write(source: Buffer , byteCount: Long ): Unit","title":"write - Okio"},{"location":"2.x/okio/okio/-gzip-sink/write/#write","text":"(jvm) fun write(source: Buffer , byteCount: Long ): Unit","title":"write"},{"location":"2.x/okio/okio/-gzip-source/","text":"okio / okio / GzipSource GzipSource \u00b6 (jvm) class GzipSource : Source A source that uses GZIP to decompress data read from another source. Constructors \u00b6 Name Summary (jvm) <init> A source that uses GZIP to decompress data read from another source. GzipSource(source: Source ) Functions \u00b6 Name Summary (jvm) close fun close(): Unit (jvm) read fun read(sink: Buffer , byteCount: Long ): Long (jvm) timeout fun timeout(): Timeout Extension Functions \u00b6 Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"GzipSource - Okio"},{"location":"2.x/okio/okio/-gzip-source/#gzipsource","text":"(jvm) class GzipSource : Source A source that uses GZIP to decompress data read from another source.","title":"GzipSource"},{"location":"2.x/okio/okio/-gzip-source/#constructors","text":"Name Summary (jvm) <init> A source that uses GZIP to decompress data read from another source. GzipSource(source: Source )","title":"Constructors"},{"location":"2.x/okio/okio/-gzip-source/#functions","text":"Name Summary (jvm) close fun close(): Unit (jvm) read fun read(sink: Buffer , byteCount: Long ): Long (jvm) timeout fun timeout(): Timeout","title":"Functions"},{"location":"2.x/okio/okio/-gzip-source/#extension-functions","text":"Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"Extension Functions"},{"location":"2.x/okio/okio/-gzip-source/-init-/","text":"okio / okio / GzipSource / <init> <init> \u00b6 (jvm) GzipSource(source: Source ) A source that uses GZIP to decompress data read from another source.","title":" init "},{"location":"2.x/okio/okio/-gzip-source/-init-/#init","text":"(jvm) GzipSource(source: Source ) A source that uses GZIP to decompress data read from another source.","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-gzip-source/close/","text":"okio / okio / GzipSource / close close \u00b6 (jvm) fun close(): Unit","title":"close - Okio"},{"location":"2.x/okio/okio/-gzip-source/close/#close","text":"(jvm) fun close(): Unit","title":"close"},{"location":"2.x/okio/okio/-gzip-source/read/","text":"okio / okio / GzipSource / read read \u00b6 (jvm) fun read(sink: Buffer , byteCount: Long ): Long","title":"read - Okio"},{"location":"2.x/okio/okio/-gzip-source/read/#read","text":"(jvm) fun read(sink: Buffer , byteCount: Long ): Long","title":"read"},{"location":"2.x/okio/okio/-gzip-source/timeout/","text":"okio / okio / GzipSource / timeout timeout \u00b6 (jvm) fun timeout(): Timeout","title":"timeout - Okio"},{"location":"2.x/okio/okio/-gzip-source/timeout/#timeout","text":"(jvm) fun timeout(): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-hashing-sink/","text":"okio / okio / HashingSink HashingSink \u00b6 (jvm) class HashingSink : ForwardingSink A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value. In this example we use HashingSink with a BufferedSink to make writing to the sink easier. HashingSink hashingSink = HashingSink.sha256(s); BufferedSink bufferedSink = Okio.buffer(hashingSink); ... // Write to bufferedSink and either flush or close it. ByteString hash = hashingSink.hash(); Properties \u00b6 Name Summary (jvm) hash Returns the hash of the bytes accepted thus far and resets the internal state of this sink. val hash: ByteString Functions \u00b6 Name Summary (jvm) hash fun ~~hash~~(): ByteString (jvm) write fun write(source: Buffer , byteCount: Long ): Unit Companion Object Functions \u00b6 Name Summary (jvm) hmacSha1 Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. fun hmacSha1(sink: Sink , key: ByteString ): HashingSink (jvm) hmacSha256 Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. fun hmacSha256(sink: Sink , key: ByteString ): HashingSink (jvm) hmacSha512 Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. fun hmacSha512(sink: Sink , key: ByteString ): HashingSink (jvm) md5 Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. fun md5(sink: Sink ): HashingSink (jvm) sha1 Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. fun sha1(sink: Sink ): HashingSink (jvm) sha256 Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. fun sha256(sink: Sink ): HashingSink (jvm) sha512 Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. fun sha512(sink: Sink ): HashingSink Extension Functions \u00b6 Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink","title":"HashingSink - Okio"},{"location":"2.x/okio/okio/-hashing-sink/#hashingsink","text":"(jvm) class HashingSink : ForwardingSink A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value. In this example we use HashingSink with a BufferedSink to make writing to the sink easier. HashingSink hashingSink = HashingSink.sha256(s); BufferedSink bufferedSink = Okio.buffer(hashingSink); ... // Write to bufferedSink and either flush or close it. ByteString hash = hashingSink.hash();","title":"HashingSink"},{"location":"2.x/okio/okio/-hashing-sink/#properties","text":"Name Summary (jvm) hash Returns the hash of the bytes accepted thus far and resets the internal state of this sink. val hash: ByteString","title":"Properties"},{"location":"2.x/okio/okio/-hashing-sink/#functions","text":"Name Summary (jvm) hash fun ~~hash~~(): ByteString (jvm) write fun write(source: Buffer , byteCount: Long ): Unit","title":"Functions"},{"location":"2.x/okio/okio/-hashing-sink/#companion-object-functions","text":"Name Summary (jvm) hmacSha1 Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. fun hmacSha1(sink: Sink , key: ByteString ): HashingSink (jvm) hmacSha256 Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. fun hmacSha256(sink: Sink , key: ByteString ): HashingSink (jvm) hmacSha512 Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. fun hmacSha512(sink: Sink , key: ByteString ): HashingSink (jvm) md5 Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. fun md5(sink: Sink ): HashingSink (jvm) sha1 Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. fun sha1(sink: Sink ): HashingSink (jvm) sha256 Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. fun sha256(sink: Sink ): HashingSink (jvm) sha512 Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. fun sha512(sink: Sink ): HashingSink","title":"Companion Object Functions"},{"location":"2.x/okio/okio/-hashing-sink/#extension-functions","text":"Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink","title":"Extension Functions"},{"location":"2.x/okio/okio/-hashing-sink/hash/","text":"okio / okio / HashingSink / hash hash \u00b6 (jvm) val hash: ByteString Returns the hash of the bytes accepted thus far and resets the internal state of this sink. Warning: This method is not idempotent. Each time this method is called its internal state is cleared. This starts a new hash with zero bytes accepted. (jvm) @JvmName(\"-deprecated_hash\") fun ~~hash~~(): ByteString Deprecated: moved to val","title":"hash - Okio"},{"location":"2.x/okio/okio/-hashing-sink/hash/#hash","text":"(jvm) val hash: ByteString Returns the hash of the bytes accepted thus far and resets the internal state of this sink. Warning: This method is not idempotent. Each time this method is called its internal state is cleared. This starts a new hash with zero bytes accepted. (jvm) @JvmName(\"-deprecated_hash\") fun ~~hash~~(): ByteString Deprecated: moved to val","title":"hash"},{"location":"2.x/okio/okio/-hashing-sink/hmac-sha1/","text":"okio / okio / HashingSink / hmacSha1 hmacSha1 \u00b6 (jvm) @JvmStatic fun hmacSha1(sink: Sink , key: ByteString ): HashingSink Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes.","title":"hmacSha1 - Okio"},{"location":"2.x/okio/okio/-hashing-sink/hmac-sha1/#hmacsha1","text":"(jvm) @JvmStatic fun hmacSha1(sink: Sink , key: ByteString ): HashingSink Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes.","title":"hmacSha1"},{"location":"2.x/okio/okio/-hashing-sink/hmac-sha256/","text":"okio / okio / HashingSink / hmacSha256 hmacSha256 \u00b6 (jvm) @JvmStatic fun hmacSha256(sink: Sink , key: ByteString ): HashingSink Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes.","title":"hmacSha256 - Okio"},{"location":"2.x/okio/okio/-hashing-sink/hmac-sha256/#hmacsha256","text":"(jvm) @JvmStatic fun hmacSha256(sink: Sink , key: ByteString ): HashingSink Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes.","title":"hmacSha256"},{"location":"2.x/okio/okio/-hashing-sink/hmac-sha512/","text":"okio / okio / HashingSink / hmacSha512 hmacSha512 \u00b6 (jvm) @JvmStatic fun hmacSha512(sink: Sink , key: ByteString ): HashingSink Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes.","title":"hmacSha512 - Okio"},{"location":"2.x/okio/okio/-hashing-sink/hmac-sha512/#hmacsha512","text":"(jvm) @JvmStatic fun hmacSha512(sink: Sink , key: ByteString ): HashingSink Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes.","title":"hmacSha512"},{"location":"2.x/okio/okio/-hashing-sink/md5/","text":"okio / okio / HashingSink / md5 md5 \u00b6 (jvm) @JvmStatic fun md5(sink: Sink ): HashingSink Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes.","title":"md5 - Okio"},{"location":"2.x/okio/okio/-hashing-sink/md5/#md5","text":"(jvm) @JvmStatic fun md5(sink: Sink ): HashingSink Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes.","title":"md5"},{"location":"2.x/okio/okio/-hashing-sink/sha1/","text":"okio / okio / HashingSink / sha1 sha1 \u00b6 (jvm) @JvmStatic fun sha1(sink: Sink ): HashingSink Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes.","title":"sha1 - Okio"},{"location":"2.x/okio/okio/-hashing-sink/sha1/#sha1","text":"(jvm) @JvmStatic fun sha1(sink: Sink ): HashingSink Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes.","title":"sha1"},{"location":"2.x/okio/okio/-hashing-sink/sha256/","text":"okio / okio / HashingSink / sha256 sha256 \u00b6 (jvm) @JvmStatic fun sha256(sink: Sink ): HashingSink Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes.","title":"sha256 - Okio"},{"location":"2.x/okio/okio/-hashing-sink/sha256/#sha256","text":"(jvm) @JvmStatic fun sha256(sink: Sink ): HashingSink Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes.","title":"sha256"},{"location":"2.x/okio/okio/-hashing-sink/sha512/","text":"okio / okio / HashingSink / sha512 sha512 \u00b6 (jvm) @JvmStatic fun sha512(sink: Sink ): HashingSink Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes.","title":"sha512 - Okio"},{"location":"2.x/okio/okio/-hashing-sink/sha512/#sha512","text":"(jvm) @JvmStatic fun sha512(sink: Sink ): HashingSink Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes.","title":"sha512"},{"location":"2.x/okio/okio/-hashing-sink/write/","text":"okio / okio / HashingSink / write write \u00b6 (jvm) fun write(source: Buffer , byteCount: Long ): Unit","title":"write - Okio"},{"location":"2.x/okio/okio/-hashing-sink/write/#write","text":"(jvm) fun write(source: Buffer , byteCount: Long ): Unit","title":"write"},{"location":"2.x/okio/okio/-hashing-source/","text":"okio / okio / HashingSource HashingSource \u00b6 (jvm) class HashingSource : ForwardingSource A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value. In this example we use HashingSource with a BufferedSource to make reading from the source easier. HashingSource hashingSource = HashingSource.sha256(rawSource); BufferedSource bufferedSource = Okio.buffer(hashingSource); ... // Read all of bufferedSource. ByteString hash = hashingSource.hash(); Properties \u00b6 Name Summary (jvm) hash Returns the hash of the bytes supplied thus far and resets the internal state of this source. val hash: ByteString Functions \u00b6 Name Summary (jvm) hash fun ~~hash~~(): ByteString (jvm) read fun read(sink: Buffer , byteCount: Long ): Long Companion Object Functions \u00b6 Name Summary (jvm) hmacSha1 Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. fun hmacSha1(source: Source , key: ByteString ): HashingSource (jvm) hmacSha256 Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. fun hmacSha256(source: Source , key: ByteString ): HashingSource (jvm) hmacSha512 Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. fun hmacSha512(source: Source , key: ByteString ): HashingSource (jvm) md5 Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. fun md5(source: Source ): HashingSource (jvm) sha1 Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. fun sha1(source: Source ): HashingSource (jvm) sha256 Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. fun sha256(source: Source ): HashingSource (jvm) sha512 Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. fun sha512(source: Source ): HashingSource Extension Functions \u00b6 Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"HashingSource - Okio"},{"location":"2.x/okio/okio/-hashing-source/#hashingsource","text":"(jvm) class HashingSource : ForwardingSource A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value. In this example we use HashingSource with a BufferedSource to make reading from the source easier. HashingSource hashingSource = HashingSource.sha256(rawSource); BufferedSource bufferedSource = Okio.buffer(hashingSource); ... // Read all of bufferedSource. ByteString hash = hashingSource.hash();","title":"HashingSource"},{"location":"2.x/okio/okio/-hashing-source/#properties","text":"Name Summary (jvm) hash Returns the hash of the bytes supplied thus far and resets the internal state of this source. val hash: ByteString","title":"Properties"},{"location":"2.x/okio/okio/-hashing-source/#functions","text":"Name Summary (jvm) hash fun ~~hash~~(): ByteString (jvm) read fun read(sink: Buffer , byteCount: Long ): Long","title":"Functions"},{"location":"2.x/okio/okio/-hashing-source/#companion-object-functions","text":"Name Summary (jvm) hmacSha1 Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. fun hmacSha1(source: Source , key: ByteString ): HashingSource (jvm) hmacSha256 Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. fun hmacSha256(source: Source , key: ByteString ): HashingSource (jvm) hmacSha512 Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. fun hmacSha512(source: Source , key: ByteString ): HashingSource (jvm) md5 Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. fun md5(source: Source ): HashingSource (jvm) sha1 Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. fun sha1(source: Source ): HashingSource (jvm) sha256 Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. fun sha256(source: Source ): HashingSource (jvm) sha512 Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. fun sha512(source: Source ): HashingSource","title":"Companion Object Functions"},{"location":"2.x/okio/okio/-hashing-source/#extension-functions","text":"Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"Extension Functions"},{"location":"2.x/okio/okio/-hashing-source/hash/","text":"okio / okio / HashingSource / hash hash \u00b6 (jvm) val hash: ByteString Returns the hash of the bytes supplied thus far and resets the internal state of this source. Warning: This method is not idempotent. Each time this method is called its internal state is cleared. This starts a new hash with zero bytes supplied. (jvm) @JvmName(\"-deprecated_hash\") fun ~~hash~~(): ByteString Deprecated: moved to val","title":"hash - Okio"},{"location":"2.x/okio/okio/-hashing-source/hash/#hash","text":"(jvm) val hash: ByteString Returns the hash of the bytes supplied thus far and resets the internal state of this source. Warning: This method is not idempotent. Each time this method is called its internal state is cleared. This starts a new hash with zero bytes supplied. (jvm) @JvmName(\"-deprecated_hash\") fun ~~hash~~(): ByteString Deprecated: moved to val","title":"hash"},{"location":"2.x/okio/okio/-hashing-source/hmac-sha1/","text":"okio / okio / HashingSource / hmacSha1 hmacSha1 \u00b6 (jvm) @JvmStatic fun hmacSha1(source: Source , key: ByteString ): HashingSource Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes.","title":"hmacSha1 - Okio"},{"location":"2.x/okio/okio/-hashing-source/hmac-sha1/#hmacsha1","text":"(jvm) @JvmStatic fun hmacSha1(source: Source , key: ByteString ): HashingSource Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes.","title":"hmacSha1"},{"location":"2.x/okio/okio/-hashing-source/hmac-sha256/","text":"okio / okio / HashingSource / hmacSha256 hmacSha256 \u00b6 (jvm) @JvmStatic fun hmacSha256(source: Source , key: ByteString ): HashingSource Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes.","title":"hmacSha256 - Okio"},{"location":"2.x/okio/okio/-hashing-source/hmac-sha256/#hmacsha256","text":"(jvm) @JvmStatic fun hmacSha256(source: Source , key: ByteString ): HashingSource Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes.","title":"hmacSha256"},{"location":"2.x/okio/okio/-hashing-source/hmac-sha512/","text":"okio / okio / HashingSource / hmacSha512 hmacSha512 \u00b6 (jvm) @JvmStatic fun hmacSha512(source: Source , key: ByteString ): HashingSource Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes.","title":"hmacSha512 - Okio"},{"location":"2.x/okio/okio/-hashing-source/hmac-sha512/#hmacsha512","text":"(jvm) @JvmStatic fun hmacSha512(source: Source , key: ByteString ): HashingSource Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes.","title":"hmacSha512"},{"location":"2.x/okio/okio/-hashing-source/md5/","text":"okio / okio / HashingSource / md5 md5 \u00b6 (jvm) @JvmStatic fun md5(source: Source ): HashingSource Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes.","title":"md5 - Okio"},{"location":"2.x/okio/okio/-hashing-source/md5/#md5","text":"(jvm) @JvmStatic fun md5(source: Source ): HashingSource Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes.","title":"md5"},{"location":"2.x/okio/okio/-hashing-source/read/","text":"okio / okio / HashingSource / read read \u00b6 (jvm) fun read(sink: Buffer , byteCount: Long ): Long","title":"read - Okio"},{"location":"2.x/okio/okio/-hashing-source/read/#read","text":"(jvm) fun read(sink: Buffer , byteCount: Long ): Long","title":"read"},{"location":"2.x/okio/okio/-hashing-source/sha1/","text":"okio / okio / HashingSource / sha1 sha1 \u00b6 (jvm) @JvmStatic fun sha1(source: Source ): HashingSource Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes.","title":"sha1 - Okio"},{"location":"2.x/okio/okio/-hashing-source/sha1/#sha1","text":"(jvm) @JvmStatic fun sha1(source: Source ): HashingSource Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes.","title":"sha1"},{"location":"2.x/okio/okio/-hashing-source/sha256/","text":"okio / okio / HashingSource / sha256 sha256 \u00b6 (jvm) @JvmStatic fun sha256(source: Source ): HashingSource Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes.","title":"sha256 - Okio"},{"location":"2.x/okio/okio/-hashing-source/sha256/#sha256","text":"(jvm) @JvmStatic fun sha256(source: Source ): HashingSource Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes.","title":"sha256"},{"location":"2.x/okio/okio/-hashing-source/sha512/","text":"okio / okio / HashingSource / sha512 sha512 \u00b6 (jvm) @JvmStatic fun sha512(source: Source ): HashingSource Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes.","title":"sha512 - Okio"},{"location":"2.x/okio/okio/-hashing-source/sha512/#sha512","text":"(jvm) @JvmStatic fun sha512(source: Source ): HashingSource Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes.","title":"sha512"},{"location":"2.x/okio/okio/-i-o-exception/","text":"okio / okio / IOException IOException \u00b6 (js, jvm) open class IOException : Exception (native) open class IOException : Exception Constructors \u00b6 Name Summary <init> (js, jvm) <init>(message: String ? = null) (native) <init>(message: String ?) Inheritors \u00b6 Name Summary (js, jvm, native) EOFException open class EOFException : IOException","title":"IOException - Okio"},{"location":"2.x/okio/okio/-i-o-exception/#ioexception","text":"(js, jvm) open class IOException : Exception (native) open class IOException : Exception","title":"IOException"},{"location":"2.x/okio/okio/-i-o-exception/#constructors","text":"Name Summary <init> (js, jvm) <init>(message: String ? = null) (native) <init>(message: String ?)","title":"Constructors"},{"location":"2.x/okio/okio/-i-o-exception/#inheritors","text":"Name Summary (js, jvm, native) EOFException open class EOFException : IOException","title":"Inheritors"},{"location":"2.x/okio/okio/-i-o-exception/-init-/","text":"okio / okio / IOException / <init> <init> \u00b6 (js, jvm) <init>(message: String ? = null) (native) <init>(message: String ?)","title":" init "},{"location":"2.x/okio/okio/-i-o-exception/-init-/#init","text":"(js, jvm) <init>(message: String ? = null) (native) <init>(message: String ?)","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-inflater-source/","text":"okio / okio / InflaterSource InflaterSource \u00b6 (jvm) class InflaterSource : Source A source that uses DEFLATE to decompress data read from another source. Constructors \u00b6 Name Summary (jvm) <init> InflaterSource(source: Source , inflater: Inflater ) Functions \u00b6 Name Summary (jvm) close fun close(): Unit (jvm) read fun read(sink: Buffer , byteCount: Long ): Long (jvm) readOrInflate Consume deflated bytes from the underlying source, and write any inflated bytes to sink . Returns the number of inflated bytes written to sink . This may return 0L, though it will always consume 1 or more bytes from the underlying source if it is not exhausted. fun readOrInflate(sink: Buffer , byteCount: Long ): Long (jvm) refill Refills the inflater with compressed data if it needs input. (And only if it needs input). Returns true if the inflater required input but the source was exhausted. fun refill(): Boolean (jvm) timeout fun timeout(): Timeout Extension Functions \u00b6 Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"InflaterSource - Okio"},{"location":"2.x/okio/okio/-inflater-source/#inflatersource","text":"(jvm) class InflaterSource : Source A source that uses DEFLATE to decompress data read from another source.","title":"InflaterSource"},{"location":"2.x/okio/okio/-inflater-source/#constructors","text":"Name Summary (jvm) <init> InflaterSource(source: Source , inflater: Inflater )","title":"Constructors"},{"location":"2.x/okio/okio/-inflater-source/#functions","text":"Name Summary (jvm) close fun close(): Unit (jvm) read fun read(sink: Buffer , byteCount: Long ): Long (jvm) readOrInflate Consume deflated bytes from the underlying source, and write any inflated bytes to sink . Returns the number of inflated bytes written to sink . This may return 0L, though it will always consume 1 or more bytes from the underlying source if it is not exhausted. fun readOrInflate(sink: Buffer , byteCount: Long ): Long (jvm) refill Refills the inflater with compressed data if it needs input. (And only if it needs input). Returns true if the inflater required input but the source was exhausted. fun refill(): Boolean (jvm) timeout fun timeout(): Timeout","title":"Functions"},{"location":"2.x/okio/okio/-inflater-source/#extension-functions","text":"Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"Extension Functions"},{"location":"2.x/okio/okio/-inflater-source/-init-/","text":"okio / okio / InflaterSource / <init> <init> \u00b6 (jvm) InflaterSource(source: Source , inflater: Inflater )","title":" init "},{"location":"2.x/okio/okio/-inflater-source/-init-/#init","text":"(jvm) InflaterSource(source: Source , inflater: Inflater )","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-inflater-source/close/","text":"okio / okio / InflaterSource / close close \u00b6 (jvm) fun close(): Unit","title":"close - Okio"},{"location":"2.x/okio/okio/-inflater-source/close/#close","text":"(jvm) fun close(): Unit","title":"close"},{"location":"2.x/okio/okio/-inflater-source/read-or-inflate/","text":"okio / okio / InflaterSource / readOrInflate readOrInflate \u00b6 (jvm) fun readOrInflate(sink: Buffer , byteCount: Long ): Long Consume deflated bytes from the underlying source, and write any inflated bytes to sink . Returns the number of inflated bytes written to sink . This may return 0L, though it will always consume 1 or more bytes from the underlying source if it is not exhausted. Use this instead of read when it is useful to consume the deflated stream even when doing so doesn\u2019t yield inflated bytes.","title":"readOrInflate - Okio"},{"location":"2.x/okio/okio/-inflater-source/read-or-inflate/#readorinflate","text":"(jvm) fun readOrInflate(sink: Buffer , byteCount: Long ): Long Consume deflated bytes from the underlying source, and write any inflated bytes to sink . Returns the number of inflated bytes written to sink . This may return 0L, though it will always consume 1 or more bytes from the underlying source if it is not exhausted. Use this instead of read when it is useful to consume the deflated stream even when doing so doesn\u2019t yield inflated bytes.","title":"readOrInflate"},{"location":"2.x/okio/okio/-inflater-source/read/","text":"okio / okio / InflaterSource / read read \u00b6 (jvm) fun read(sink: Buffer , byteCount: Long ): Long","title":"read - Okio"},{"location":"2.x/okio/okio/-inflater-source/read/#read","text":"(jvm) fun read(sink: Buffer , byteCount: Long ): Long","title":"read"},{"location":"2.x/okio/okio/-inflater-source/refill/","text":"okio / okio / InflaterSource / refill refill \u00b6 (jvm) fun refill(): Boolean Refills the inflater with compressed data if it needs input. (And only if it needs input). Returns true if the inflater required input but the source was exhausted.","title":"refill - Okio"},{"location":"2.x/okio/okio/-inflater-source/refill/#refill","text":"(jvm) fun refill(): Boolean Refills the inflater with compressed data if it needs input. (And only if it needs input). Returns true if the inflater required input but the source was exhausted.","title":"refill"},{"location":"2.x/okio/okio/-inflater-source/timeout/","text":"okio / okio / InflaterSource / timeout timeout \u00b6 (jvm) fun timeout(): Timeout","title":"timeout - Okio"},{"location":"2.x/okio/okio/-inflater-source/timeout/#timeout","text":"(jvm) fun timeout(): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-options/","text":"okio / okio / Options Options \u00b6 (js) class Options : AbstractList < ByteString >, RandomAccess (jvm) class Options : AbstractList < ByteString >, RandomAccess An indexed set of values that may be read with BufferedSource.select . Properties \u00b6 Name Summary (js, jvm) size val size: Int Functions \u00b6 Name Summary (js, jvm) get fun get(index: Int ): ByteString Companion Object Functions \u00b6 Name Summary (js, jvm) of fun of(vararg byteStrings: ByteString ): Options","title":"Options - Okio"},{"location":"2.x/okio/okio/-options/#options","text":"(js) class Options : AbstractList < ByteString >, RandomAccess (jvm) class Options : AbstractList < ByteString >, RandomAccess An indexed set of values that may be read with BufferedSource.select .","title":"Options"},{"location":"2.x/okio/okio/-options/#properties","text":"Name Summary (js, jvm) size val size: Int","title":"Properties"},{"location":"2.x/okio/okio/-options/#functions","text":"Name Summary (js, jvm) get fun get(index: Int ): ByteString","title":"Functions"},{"location":"2.x/okio/okio/-options/#companion-object-functions","text":"Name Summary (js, jvm) of fun of(vararg byteStrings: ByteString ): Options","title":"Companion Object Functions"},{"location":"2.x/okio/okio/-options/get/","text":"okio / okio / Options / get get \u00b6 (js, jvm) fun get(index: Int ): ByteString","title":"get - Okio"},{"location":"2.x/okio/okio/-options/get/#get","text":"(js, jvm) fun get(index: Int ): ByteString","title":"get"},{"location":"2.x/okio/okio/-options/of/","text":"okio / okio / Options / of of \u00b6 (js, jvm) @JvmStatic fun of(vararg byteStrings: ByteString ): Options","title":"of - Okio"},{"location":"2.x/okio/okio/-options/of/#of","text":"(js, jvm) @JvmStatic fun of(vararg byteStrings: ByteString ): Options","title":"of"},{"location":"2.x/okio/okio/-options/size/","text":"okio / okio / Options / size size \u00b6 (js, jvm) val size: Int","title":"size - Okio"},{"location":"2.x/okio/okio/-options/size/#size","text":"(js, jvm) val size: Int","title":"size"},{"location":"2.x/okio/okio/-pipe/","text":"okio / okio / Pipe Pipe \u00b6 (jvm) class Pipe A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source. This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum size. When a producer thread outruns its consumer the buffer fills up and eventually writes to the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its producer reads block until there is data to be read. Limits on the amount of time spent waiting for the other party can be configured with timeouts on the source and the sink. When the sink is closed, source reads will continue to complete normally until the buffer has been exhausted. At that point reads will return -1, indicating the end of the stream. But if the source is closed first, writes to the sink will immediately fail with an IOException . A pipe may be canceled to immediately fail writes to the sink and reads from the source. Constructors \u00b6 Name Summary (jvm) <init> A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source. Pipe(maxBufferSize: Long ) Properties \u00b6 Name Summary (jvm) sink val sink: Sink (jvm) source val source: Source Functions \u00b6 Name Summary (jvm) cancel Fail any in-flight and future operations. After canceling: fun cancel(): Unit (jvm) fold Writes any buffered contents of this pipe to sink , then replace this pipe\u2019s source with sink . This pipe\u2019s source is closed and attempts to read it will throw an IllegalStateException . fun fold(sink: Sink ): Unit (jvm) sink fun ~~sink~~(): Sink (jvm) source fun ~~source~~(): Source","title":"Pipe - Okio"},{"location":"2.x/okio/okio/-pipe/#pipe","text":"(jvm) class Pipe A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source. This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum size. When a producer thread outruns its consumer the buffer fills up and eventually writes to the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its producer reads block until there is data to be read. Limits on the amount of time spent waiting for the other party can be configured with timeouts on the source and the sink. When the sink is closed, source reads will continue to complete normally until the buffer has been exhausted. At that point reads will return -1, indicating the end of the stream. But if the source is closed first, writes to the sink will immediately fail with an IOException . A pipe may be canceled to immediately fail writes to the sink and reads from the source.","title":"Pipe"},{"location":"2.x/okio/okio/-pipe/#constructors","text":"Name Summary (jvm) <init> A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source. Pipe(maxBufferSize: Long )","title":"Constructors"},{"location":"2.x/okio/okio/-pipe/#properties","text":"Name Summary (jvm) sink val sink: Sink (jvm) source val source: Source","title":"Properties"},{"location":"2.x/okio/okio/-pipe/#functions","text":"Name Summary (jvm) cancel Fail any in-flight and future operations. After canceling: fun cancel(): Unit (jvm) fold Writes any buffered contents of this pipe to sink , then replace this pipe\u2019s source with sink . This pipe\u2019s source is closed and attempts to read it will throw an IllegalStateException . fun fold(sink: Sink ): Unit (jvm) sink fun ~~sink~~(): Sink (jvm) source fun ~~source~~(): Source","title":"Functions"},{"location":"2.x/okio/okio/-pipe/-init-/","text":"okio / okio / Pipe / <init> <init> \u00b6 (jvm) Pipe(maxBufferSize: Long ) A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source. This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum size. When a producer thread outruns its consumer the buffer fills up and eventually writes to the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its producer reads block until there is data to be read. Limits on the amount of time spent waiting for the other party can be configured with timeouts on the source and the sink. When the sink is closed, source reads will continue to complete normally until the buffer has been exhausted. At that point reads will return -1, indicating the end of the stream. But if the source is closed first, writes to the sink will immediately fail with an IOException . A pipe may be canceled to immediately fail writes to the sink and reads from the source.","title":" init "},{"location":"2.x/okio/okio/-pipe/-init-/#init","text":"(jvm) Pipe(maxBufferSize: Long ) A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source. This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum size. When a producer thread outruns its consumer the buffer fills up and eventually writes to the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its producer reads block until there is data to be read. Limits on the amount of time spent waiting for the other party can be configured with timeouts on the source and the sink. When the sink is closed, source reads will continue to complete normally until the buffer has been exhausted. At that point reads will return -1, indicating the end of the stream. But if the source is closed first, writes to the sink will immediately fail with an IOException . A pipe may be canceled to immediately fail writes to the sink and reads from the source.","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-pipe/cancel/","text":"okio / okio / Pipe / cancel cancel \u00b6 (jvm) fun cancel(): Unit Fail any in-flight and future operations. After canceling: Any attempt to write or flush sink will fail immediately with an IOException . Any attempt to read source will fail immediately with an IOException . Any attempt to fold will fail immediately with an IOException . Closing the source and the sink will complete normally even after a pipe has been canceled. If this sink has been folded, closing it will close the folded sink. This operation may block. This operation may be called by any thread at any time. It is safe to call concurrently while operating on the source or the sink.","title":"cancel - Okio"},{"location":"2.x/okio/okio/-pipe/cancel/#cancel","text":"(jvm) fun cancel(): Unit Fail any in-flight and future operations. After canceling: Any attempt to write or flush sink will fail immediately with an IOException . Any attempt to read source will fail immediately with an IOException . Any attempt to fold will fail immediately with an IOException . Closing the source and the sink will complete normally even after a pipe has been canceled. If this sink has been folded, closing it will close the folded sink. This operation may block. This operation may be called by any thread at any time. It is safe to call concurrently while operating on the source or the sink.","title":"cancel"},{"location":"2.x/okio/okio/-pipe/fold/","text":"okio / okio / Pipe / fold fold \u00b6 (jvm) fun fold(sink: Sink ): Unit Writes any buffered contents of this pipe to sink , then replace this pipe\u2019s source with sink . This pipe\u2019s source is closed and attempts to read it will throw an IllegalStateException . This method must not be called while concurrently accessing this pipe\u2019s source. It is safe, however, to call this while concurrently writing this pipe\u2019s sink.","title":"fold - Okio"},{"location":"2.x/okio/okio/-pipe/fold/#fold","text":"(jvm) fun fold(sink: Sink ): Unit Writes any buffered contents of this pipe to sink , then replace this pipe\u2019s source with sink . This pipe\u2019s source is closed and attempts to read it will throw an IllegalStateException . This method must not be called while concurrently accessing this pipe\u2019s source. It is safe, however, to call this while concurrently writing this pipe\u2019s sink.","title":"fold"},{"location":"2.x/okio/okio/-pipe/sink/","text":"okio / okio / Pipe / sink sink \u00b6 (jvm) val sink: Sink @JvmName(\"-deprecated_sink\") fun ~~sink~~(): Sink Deprecated: moved to val","title":"sink - Okio"},{"location":"2.x/okio/okio/-pipe/sink/#sink","text":"(jvm) val sink: Sink @JvmName(\"-deprecated_sink\") fun ~~sink~~(): Sink Deprecated: moved to val","title":"sink"},{"location":"2.x/okio/okio/-pipe/source/","text":"okio / okio / Pipe / source source \u00b6 (jvm) val source: Source @JvmName(\"-deprecated_source\") fun ~~source~~(): Source Deprecated: moved to val","title":"source - Okio"},{"location":"2.x/okio/okio/-pipe/source/#source","text":"(jvm) val source: Source @JvmName(\"-deprecated_source\") fun ~~source~~(): Source Deprecated: moved to val","title":"source"},{"location":"2.x/okio/okio/-sink/","text":"okio / okio / Sink Sink \u00b6 (js, jvm, native) interface Sink (js) Receives a stream of bytes. Use this interface to write data wherever it\u2019s needed: to the network, storage, or a buffer in memory. Sinks may be layered to transform received data, such as to compress, encrypt, throttle, or add protocol framing. Most application code shouldn\u2019t operate on a sink directly, but rather on a BufferedSink which is both more efficient and more convenient. Use buffer to wrap any sink with a buffer. Sinks are easy to test: just use a Buffer in your tests, and read from it to confirm it received the data that was expected. Comparison with OutputStream \u00b6 This interface is functionally equivalent to java.io.OutputStream . OutputStream requires multiple layers when emitted data is heterogeneous: a DataOutputStream for primitive values, a BufferedOutputStream for buffering, and OutputStreamWriter for charset encoding. This library uses BufferedSink for all of the above. Sink is also easier to layer: there is no write() method that is awkward to implement efficiently. Interop with OutputStream \u00b6 Use sink to adapt an OutputStream to a sink. Use outputStream() to adapt a sink to an OutputStream . (jvm) Receives a stream of bytes. Use this interface to write data wherever it\u2019s needed: to the network, storage, or a buffer in memory. Sinks may be layered to transform received data, such as to compress, encrypt, throttle, or add protocol framing. Most application code shouldn\u2019t operate on a sink directly, but rather on a BufferedSink which is both more efficient and more convenient. Use buffer to wrap any sink with a buffer. Sinks are easy to test: just use a Buffer in your tests, and read from it to confirm it received the data that was expected. Comparison with OutputStream \u00b6 This interface is functionally equivalent to java.io.OutputStream . OutputStream requires multiple layers when emitted data is heterogeneous: a DataOutputStream for primitive values, a BufferedOutputStream for buffering, and OutputStreamWriter for charset encoding. This library uses BufferedSink for all of the above. Sink is also easier to layer: there is no write() method that is awkward to implement efficiently. Interop with OutputStream \u00b6 Use sink to adapt an OutputStream to a sink. Use outputStream() to adapt a sink to an OutputStream . Functions \u00b6 Name Summary (js, jvm, native) close Pushes all buffered bytes to their final destination and releases the resources held by this sink. It is an error to write a closed sink. It is safe to close a sink more than once. abstract fun close(): Unit (js, jvm, native) flush Pushes all buffered bytes to their final destination. abstract fun flush(): Unit (js, jvm, native) timeout Returns the timeout for this sink. abstract fun timeout(): Timeout (js, jvm, native) write Removes byteCount bytes from source and appends them to this. abstract fun write(source: Buffer , byteCount: Long ): Unit Extension Functions \u00b6 Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink Inheritors \u00b6 Name Summary (js, jvm, native) BufferedSink A sink that keeps a buffer internally so that callers can do small writes without a performance penalty. interface BufferedSink : Sink (jvm) DeflaterSink A sink that uses DEFLATE to compress data written to another source. class DeflaterSink : Sink (jvm) ForwardingSink A Sink which forwards calls to another. Useful for subclassing. abstract class ForwardingSink : Sink (jvm) GzipSink A sink that uses GZIP to compress written data to another sink. class GzipSink : Sink","title":"Sink - Okio"},{"location":"2.x/okio/okio/-sink/#sink","text":"(js, jvm, native) interface Sink (js) Receives a stream of bytes. Use this interface to write data wherever it\u2019s needed: to the network, storage, or a buffer in memory. Sinks may be layered to transform received data, such as to compress, encrypt, throttle, or add protocol framing. Most application code shouldn\u2019t operate on a sink directly, but rather on a BufferedSink which is both more efficient and more convenient. Use buffer to wrap any sink with a buffer. Sinks are easy to test: just use a Buffer in your tests, and read from it to confirm it received the data that was expected.","title":"Sink"},{"location":"2.x/okio/okio/-sink/#comparison-with-outputstream","text":"This interface is functionally equivalent to java.io.OutputStream . OutputStream requires multiple layers when emitted data is heterogeneous: a DataOutputStream for primitive values, a BufferedOutputStream for buffering, and OutputStreamWriter for charset encoding. This library uses BufferedSink for all of the above. Sink is also easier to layer: there is no write() method that is awkward to implement efficiently.","title":"Comparison with OutputStream"},{"location":"2.x/okio/okio/-sink/#interop-with-outputstream","text":"Use sink to adapt an OutputStream to a sink. Use outputStream() to adapt a sink to an OutputStream . (jvm) Receives a stream of bytes. Use this interface to write data wherever it\u2019s needed: to the network, storage, or a buffer in memory. Sinks may be layered to transform received data, such as to compress, encrypt, throttle, or add protocol framing. Most application code shouldn\u2019t operate on a sink directly, but rather on a BufferedSink which is both more efficient and more convenient. Use buffer to wrap any sink with a buffer. Sinks are easy to test: just use a Buffer in your tests, and read from it to confirm it received the data that was expected.","title":"Interop with OutputStream"},{"location":"2.x/okio/okio/-sink/#comparison-with-outputstream_1","text":"This interface is functionally equivalent to java.io.OutputStream . OutputStream requires multiple layers when emitted data is heterogeneous: a DataOutputStream for primitive values, a BufferedOutputStream for buffering, and OutputStreamWriter for charset encoding. This library uses BufferedSink for all of the above. Sink is also easier to layer: there is no write() method that is awkward to implement efficiently.","title":"Comparison with OutputStream"},{"location":"2.x/okio/okio/-sink/#interop-with-outputstream_1","text":"Use sink to adapt an OutputStream to a sink. Use outputStream() to adapt a sink to an OutputStream .","title":"Interop with OutputStream"},{"location":"2.x/okio/okio/-sink/#functions","text":"Name Summary (js, jvm, native) close Pushes all buffered bytes to their final destination and releases the resources held by this sink. It is an error to write a closed sink. It is safe to close a sink more than once. abstract fun close(): Unit (js, jvm, native) flush Pushes all buffered bytes to their final destination. abstract fun flush(): Unit (js, jvm, native) timeout Returns the timeout for this sink. abstract fun timeout(): Timeout (js, jvm, native) write Removes byteCount bytes from source and appends them to this. abstract fun write(source: Buffer , byteCount: Long ): Unit","title":"Functions"},{"location":"2.x/okio/okio/-sink/#extension-functions","text":"Name Summary (jvm) deflate Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. fun Sink .deflate(deflater: Deflater = Deflater()): DeflaterSink (jvm) gzip Returns a GzipSink that gzip-compresses to this Sink while writing. fun Sink .gzip(): GzipSink","title":"Extension Functions"},{"location":"2.x/okio/okio/-sink/#inheritors","text":"Name Summary (js, jvm, native) BufferedSink A sink that keeps a buffer internally so that callers can do small writes without a performance penalty. interface BufferedSink : Sink (jvm) DeflaterSink A sink that uses DEFLATE to compress data written to another source. class DeflaterSink : Sink (jvm) ForwardingSink A Sink which forwards calls to another. Useful for subclassing. abstract class ForwardingSink : Sink (jvm) GzipSink A sink that uses GZIP to compress written data to another sink. class GzipSink : Sink","title":"Inheritors"},{"location":"2.x/okio/okio/-sink/close/","text":"okio / okio / Sink / close close \u00b6 (js, jvm, native) abstract fun close(): Unit Pushes all buffered bytes to their final destination and releases the resources held by this sink. It is an error to write a closed sink. It is safe to close a sink more than once.","title":"close - Okio"},{"location":"2.x/okio/okio/-sink/close/#close","text":"(js, jvm, native) abstract fun close(): Unit Pushes all buffered bytes to their final destination and releases the resources held by this sink. It is an error to write a closed sink. It is safe to close a sink more than once.","title":"close"},{"location":"2.x/okio/okio/-sink/flush/","text":"okio / okio / Sink / flush flush \u00b6 (js, jvm, native) abstract fun flush(): Unit Pushes all buffered bytes to their final destination.","title":"flush - Okio"},{"location":"2.x/okio/okio/-sink/flush/#flush","text":"(js, jvm, native) abstract fun flush(): Unit Pushes all buffered bytes to their final destination.","title":"flush"},{"location":"2.x/okio/okio/-sink/timeout/","text":"okio / okio / Sink / timeout timeout \u00b6 (js, jvm, native) abstract fun timeout(): Timeout Returns the timeout for this sink.","title":"timeout - Okio"},{"location":"2.x/okio/okio/-sink/timeout/#timeout","text":"(js, jvm, native) abstract fun timeout(): Timeout Returns the timeout for this sink.","title":"timeout"},{"location":"2.x/okio/okio/-sink/write/","text":"okio / okio / Sink / write write \u00b6 (js, jvm, native) abstract fun write(source: Buffer , byteCount: Long ): Unit Removes byteCount bytes from source and appends them to this.","title":"write - Okio"},{"location":"2.x/okio/okio/-sink/write/#write","text":"(js, jvm, native) abstract fun write(source: Buffer , byteCount: Long ): Unit Removes byteCount bytes from source and appends them to this.","title":"write"},{"location":"2.x/okio/okio/-source/","text":"okio / okio / Source Source \u00b6 (js, jvm, native) interface Source (js) Supplies a stream of bytes. Use this interface to read data from wherever it\u2019s located: from the network, storage, or a buffer in memory. Sources may be layered to transform supplied data, such as to decompress, decrypt, or remove protocol framing. Most applications shouldn\u2019t operate on a source directly, but rather on a BufferedSource which is both more efficient and more convenient. Use buffer to wrap any source with a buffer. Sources are easy to test: just use a Buffer in your tests, and fill it with the data your application is to read. Comparison with InputStream \u00b6 This interface is functionally equivalent to java.io.InputStream . InputStream requires multiple layers when consumed data is heterogeneous: a DataInputStream for primitive values, a BufferedInputStream for buffering, and InputStreamReader for strings. This library uses BufferedSource for all of the above. Source avoids the impossible-to-implement available() method. Instead callers specify how many bytes they require . Source omits the unsafe-to-compose mark and reset state that\u2019s tracked by InputStream ; instead, callers just buffer what they need. When implementing a source, you don\u2019t need to worry about the read() method that is awkward to implement efficiently and returns one of 257 possible values. And source has a stronger skip method: BufferedSource.skip won\u2019t return prematurely. Interop with InputStream \u00b6 Use source to adapt an InputStream to a source. Use BufferedSource.inputStream to adapt a source to an InputStream . (jvm) Supplies a stream of bytes. Use this interface to read data from wherever it\u2019s located: from the network, storage, or a buffer in memory. Sources may be layered to transform supplied data, such as to decompress, decrypt, or remove protocol framing. Most applications shouldn\u2019t operate on a source directly, but rather on a BufferedSource which is both more efficient and more convenient. Use buffer to wrap any source with a buffer. Sources are easy to test: just use a Buffer in your tests, and fill it with the data your application is to read. Comparison with InputStream \u00b6 This interface is functionally equivalent to java.io.InputStream . InputStream requires multiple layers when consumed data is heterogeneous: a DataInputStream for primitive values, a BufferedInputStream for buffering, and InputStreamReader for strings. This library uses BufferedSource for all of the above. Source avoids the impossible-to-implement available() method. Instead callers specify how many bytes they require . Source omits the unsafe-to-compose mark and reset state that\u2019s tracked by InputStream ; instead, callers just buffer what they need. When implementing a source, you don\u2019t need to worry about the read() method that is awkward to implement efficiently and returns one of 257 possible values. And source has a stronger skip method: BufferedSource.skip won\u2019t return prematurely. Interop with InputStream \u00b6 Use source to adapt an InputStream to a source. Use BufferedSource.inputStream to adapt a source to an InputStream . Functions \u00b6 Name Summary (js, jvm, native) close Closes this source and releases the resources held by this source. It is an error to read a closed source. It is safe to close a source more than once. abstract fun close(): Unit (js, jvm, native) read Removes at least 1, and up to byteCount bytes from this and appends them to sink . Returns the number of bytes read, or -1 if this source is exhausted. abstract fun read(sink: Buffer , byteCount: Long ): Long (js, jvm, native) timeout Returns the timeout for this source. abstract fun timeout(): Timeout Extension Functions \u00b6 Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource Inheritors \u00b6 Name Summary (js, jvm, native) BufferedSource A source that keeps a buffer internally so that callers can do small reads without a performance penalty. It also allows clients to read ahead, buffering as much as necessary before consuming input. interface BufferedSource : Source (jvm) ForwardingSource A Source which forwards calls to another. Useful for subclassing. abstract class ForwardingSource : Source (jvm) GzipSource A source that uses GZIP to decompress data read from another source. class GzipSource : Source (jvm) InflaterSource A source that uses DEFLATE to decompress data read from another source. class InflaterSource : Source","title":"Source - Okio"},{"location":"2.x/okio/okio/-source/#source","text":"(js, jvm, native) interface Source (js) Supplies a stream of bytes. Use this interface to read data from wherever it\u2019s located: from the network, storage, or a buffer in memory. Sources may be layered to transform supplied data, such as to decompress, decrypt, or remove protocol framing. Most applications shouldn\u2019t operate on a source directly, but rather on a BufferedSource which is both more efficient and more convenient. Use buffer to wrap any source with a buffer. Sources are easy to test: just use a Buffer in your tests, and fill it with the data your application is to read.","title":"Source"},{"location":"2.x/okio/okio/-source/#comparison-with-inputstream","text":"This interface is functionally equivalent to java.io.InputStream . InputStream requires multiple layers when consumed data is heterogeneous: a DataInputStream for primitive values, a BufferedInputStream for buffering, and InputStreamReader for strings. This library uses BufferedSource for all of the above. Source avoids the impossible-to-implement available() method. Instead callers specify how many bytes they require . Source omits the unsafe-to-compose mark and reset state that\u2019s tracked by InputStream ; instead, callers just buffer what they need. When implementing a source, you don\u2019t need to worry about the read() method that is awkward to implement efficiently and returns one of 257 possible values. And source has a stronger skip method: BufferedSource.skip won\u2019t return prematurely.","title":"Comparison with InputStream"},{"location":"2.x/okio/okio/-source/#interop-with-inputstream","text":"Use source to adapt an InputStream to a source. Use BufferedSource.inputStream to adapt a source to an InputStream . (jvm) Supplies a stream of bytes. Use this interface to read data from wherever it\u2019s located: from the network, storage, or a buffer in memory. Sources may be layered to transform supplied data, such as to decompress, decrypt, or remove protocol framing. Most applications shouldn\u2019t operate on a source directly, but rather on a BufferedSource which is both more efficient and more convenient. Use buffer to wrap any source with a buffer. Sources are easy to test: just use a Buffer in your tests, and fill it with the data your application is to read.","title":"Interop with InputStream"},{"location":"2.x/okio/okio/-source/#comparison-with-inputstream_1","text":"This interface is functionally equivalent to java.io.InputStream . InputStream requires multiple layers when consumed data is heterogeneous: a DataInputStream for primitive values, a BufferedInputStream for buffering, and InputStreamReader for strings. This library uses BufferedSource for all of the above. Source avoids the impossible-to-implement available() method. Instead callers specify how many bytes they require . Source omits the unsafe-to-compose mark and reset state that\u2019s tracked by InputStream ; instead, callers just buffer what they need. When implementing a source, you don\u2019t need to worry about the read() method that is awkward to implement efficiently and returns one of 257 possible values. And source has a stronger skip method: BufferedSource.skip won\u2019t return prematurely.","title":"Comparison with InputStream"},{"location":"2.x/okio/okio/-source/#interop-with-inputstream_1","text":"Use source to adapt an InputStream to a source. Use BufferedSource.inputStream to adapt a source to an InputStream .","title":"Interop with InputStream"},{"location":"2.x/okio/okio/-source/#functions","text":"Name Summary (js, jvm, native) close Closes this source and releases the resources held by this source. It is an error to read a closed source. It is safe to close a source more than once. abstract fun close(): Unit (js, jvm, native) read Removes at least 1, and up to byteCount bytes from this and appends them to sink . Returns the number of bytes read, or -1 if this source is exhausted. abstract fun read(sink: Buffer , byteCount: Long ): Long (js, jvm, native) timeout Returns the timeout for this source. abstract fun timeout(): Timeout","title":"Functions"},{"location":"2.x/okio/okio/-source/#extension-functions","text":"Name Summary (jvm) gzip Returns a GzipSource that gzip-decompresses this Source while reading. fun Source .gzip(): GzipSource (jvm) inflate Returns an InflaterSource that DEFLATE-decompresses this Source while reading. fun Source .inflate(inflater: Inflater = Inflater()): InflaterSource","title":"Extension Functions"},{"location":"2.x/okio/okio/-source/#inheritors","text":"Name Summary (js, jvm, native) BufferedSource A source that keeps a buffer internally so that callers can do small reads without a performance penalty. It also allows clients to read ahead, buffering as much as necessary before consuming input. interface BufferedSource : Source (jvm) ForwardingSource A Source which forwards calls to another. Useful for subclassing. abstract class ForwardingSource : Source (jvm) GzipSource A source that uses GZIP to decompress data read from another source. class GzipSource : Source (jvm) InflaterSource A source that uses DEFLATE to decompress data read from another source. class InflaterSource : Source","title":"Inheritors"},{"location":"2.x/okio/okio/-source/close/","text":"okio / okio / Source / close close \u00b6 (js, jvm, native) abstract fun close(): Unit Closes this source and releases the resources held by this source. It is an error to read a closed source. It is safe to close a source more than once.","title":"close - Okio"},{"location":"2.x/okio/okio/-source/close/#close","text":"(js, jvm, native) abstract fun close(): Unit Closes this source and releases the resources held by this source. It is an error to read a closed source. It is safe to close a source more than once.","title":"close"},{"location":"2.x/okio/okio/-source/read/","text":"okio / okio / Source / read read \u00b6 (js, jvm, native) abstract fun read(sink: Buffer , byteCount: Long ): Long Removes at least 1, and up to byteCount bytes from this and appends them to sink . Returns the number of bytes read, or -1 if this source is exhausted.","title":"read - Okio"},{"location":"2.x/okio/okio/-source/read/#read","text":"(js, jvm, native) abstract fun read(sink: Buffer , byteCount: Long ): Long Removes at least 1, and up to byteCount bytes from this and appends them to sink . Returns the number of bytes read, or -1 if this source is exhausted.","title":"read"},{"location":"2.x/okio/okio/-source/timeout/","text":"okio / okio / Source / timeout timeout \u00b6 (js, jvm, native) abstract fun timeout(): Timeout Returns the timeout for this source.","title":"timeout - Okio"},{"location":"2.x/okio/okio/-source/timeout/#timeout","text":"(js, jvm, native) abstract fun timeout(): Timeout Returns the timeout for this source.","title":"timeout"},{"location":"2.x/okio/okio/-throttler/","text":"okio / okio / Throttler Throttler \u00b6 (jvm) class Throttler Enables limiting of Source and Sink throughput. Attach to this throttler via source and sink and set the desired throughput via bytesPerSecond . Multiple Sources and Sinks can be attached to a single Throttler and they will be throttled as a group, where their combined throughput will not exceed the desired throughput. The same Source or Sink can be attached to multiple Throttlers and its throughput will not exceed the desired throughput of any of the Throttlers. This class has these tuning parameters: bytesPerSecond : Maximum sustained throughput. Use 0 for no limit. waitByteCount : When the requested byte count is greater than this many bytes and isn\u2019t immediately available, only wait until we can allocate at least this many bytes. Use this to set the ideal byte count during sustained throughput. maxByteCount : Maximum number of bytes to allocate on any call. This is also the number of bytes that will be returned before any waiting. Constructors \u00b6 Name Summary (jvm) <init> Throttler() Functions \u00b6 Name Summary (jvm) bytesPerSecond Sets the rate at which bytes will be allocated. Use 0 for no limit. fun bytesPerSecond(bytesPerSecond: Long , waitByteCount: Long = this.waitByteCount, maxByteCount: Long = this.maxByteCount): Unit (jvm) sink Create a Sink which honors this Throttler. fun sink(sink: Sink ): Sink (jvm) source Create a Source which honors this Throttler. fun source(source: Source ): Source","title":"Throttler - Okio"},{"location":"2.x/okio/okio/-throttler/#throttler","text":"(jvm) class Throttler Enables limiting of Source and Sink throughput. Attach to this throttler via source and sink and set the desired throughput via bytesPerSecond . Multiple Sources and Sinks can be attached to a single Throttler and they will be throttled as a group, where their combined throughput will not exceed the desired throughput. The same Source or Sink can be attached to multiple Throttlers and its throughput will not exceed the desired throughput of any of the Throttlers. This class has these tuning parameters: bytesPerSecond : Maximum sustained throughput. Use 0 for no limit. waitByteCount : When the requested byte count is greater than this many bytes and isn\u2019t immediately available, only wait until we can allocate at least this many bytes. Use this to set the ideal byte count during sustained throughput. maxByteCount : Maximum number of bytes to allocate on any call. This is also the number of bytes that will be returned before any waiting.","title":"Throttler"},{"location":"2.x/okio/okio/-throttler/#constructors","text":"Name Summary (jvm) <init> Throttler()","title":"Constructors"},{"location":"2.x/okio/okio/-throttler/#functions","text":"Name Summary (jvm) bytesPerSecond Sets the rate at which bytes will be allocated. Use 0 for no limit. fun bytesPerSecond(bytesPerSecond: Long , waitByteCount: Long = this.waitByteCount, maxByteCount: Long = this.maxByteCount): Unit (jvm) sink Create a Sink which honors this Throttler. fun sink(sink: Sink ): Sink (jvm) source Create a Source which honors this Throttler. fun source(source: Source ): Source","title":"Functions"},{"location":"2.x/okio/okio/-throttler/-init-/","text":"okio / okio / Throttler / <init> <init> \u00b6 (jvm) Throttler()","title":" init "},{"location":"2.x/okio/okio/-throttler/-init-/#init","text":"(jvm) Throttler()","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-throttler/bytes-per-second/","text":"okio / okio / Throttler / bytesPerSecond bytesPerSecond \u00b6 (jvm) @JvmOverloads fun bytesPerSecond(bytesPerSecond: Long , waitByteCount: Long = this.waitByteCount, maxByteCount: Long = this.maxByteCount): Unit Sets the rate at which bytes will be allocated. Use 0 for no limit.","title":"bytesPerSecond - Okio"},{"location":"2.x/okio/okio/-throttler/bytes-per-second/#bytespersecond","text":"(jvm) @JvmOverloads fun bytesPerSecond(bytesPerSecond: Long , waitByteCount: Long = this.waitByteCount, maxByteCount: Long = this.maxByteCount): Unit Sets the rate at which bytes will be allocated. Use 0 for no limit.","title":"bytesPerSecond"},{"location":"2.x/okio/okio/-throttler/sink/","text":"okio / okio / Throttler / sink sink \u00b6 (jvm) fun sink(sink: Sink ): Sink Create a Sink which honors this Throttler.","title":"sink - Okio"},{"location":"2.x/okio/okio/-throttler/sink/#sink","text":"(jvm) fun sink(sink: Sink ): Sink Create a Sink which honors this Throttler.","title":"sink"},{"location":"2.x/okio/okio/-throttler/source/","text":"okio / okio / Throttler / source source \u00b6 (jvm) fun source(source: Source ): Source Create a Source which honors this Throttler.","title":"source - Okio"},{"location":"2.x/okio/okio/-throttler/source/#source","text":"(jvm) fun source(source: Source ): Source Create a Source which honors this Throttler.","title":"source"},{"location":"2.x/okio/okio/-timeout/","text":"okio / okio / Timeout Timeout \u00b6 (js, jvm, native) open class Timeout A policy on how much time to spend on a task before giving up. When a task times out, it is left in an unspecified state and should be abandoned. For example, if reading from a source times out, that source should be closed and the read should be retried later. If writing to a sink times out, the same rules apply: close the sink and retry later. Timeouts and Deadlines \u00b6 This class offers two complementary controls to define a timeout policy. Timeouts specify the maximum time to wait for a single operation to complete. Timeouts are typically used to detect problems like network partitions. For example, if a remote peer doesn\u2019t return any data for ten seconds, we may assume that the peer is unavailable. Deadlines specify the maximum time to spend on a job, composed of one or more operations. Use deadlines to set an upper bound on the time invested on a job. For example, a battery-conscious app may limit how much time it spends pre-loading content. Constructors \u00b6 Name Summary (js, jvm, native) <init> <init>() Functions \u00b6 Name Summary (jvm) clearDeadline Clears the deadline. open fun clearDeadline(): Timeout (jvm) clearTimeout Clears the timeout. Operating system timeouts may still apply. open fun clearTimeout(): Timeout (jvm) deadline Set a deadline of now plus duration time. fun deadline(duration: Long , unit: TimeUnit ): Timeout (jvm) deadlineNanoTime Returns the nano time when the deadline will be reached. open fun deadlineNanoTime(): Long Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. open fun deadlineNanoTime(deadlineNanoTime: Long ): Timeout (jvm) hasDeadline Returns true if a deadline is enabled. open fun hasDeadline(): Boolean (jvm) intersectWith Applies the minimum intersection between this timeout and other , run block , then finally rollback this timeout\u2019s values. fun intersectWith(other: Timeout , block: () -> Unit ): Unit (jvm) throwIfReached Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. open fun throwIfReached(): Unit (jvm) timeout Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail. open fun timeout(timeout: Long , unit: TimeUnit ): Timeout (jvm) timeoutNanos Returns the timeout in nanoseconds, or 0 for no timeout. open fun timeoutNanos(): Long (jvm) waitUntilNotified Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor . fun waitUntilNotified(monitor: Any ): Unit Companion Object Properties \u00b6 Name Summary (js, jvm, native) NONE An empty timeout that neither tracks nor detects timeouts. Use this when timeouts aren\u2019t necessary, such as in implementations whose operations do not block. val NONE: Timeout Companion Object Functions \u00b6 Name Summary (jvm) minTimeout fun minTimeout(aNanos: Long , bNanos: Long ): Long Inheritors \u00b6 Name Summary (jvm) AsyncTimeout This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. open class AsyncTimeout : Timeout (jvm) ForwardingTimeout A Timeout which forwards calls to another. Useful for subclassing. open class ForwardingTimeout : Timeout","title":"Timeout - Okio"},{"location":"2.x/okio/okio/-timeout/#timeout","text":"(js, jvm, native) open class Timeout A policy on how much time to spend on a task before giving up. When a task times out, it is left in an unspecified state and should be abandoned. For example, if reading from a source times out, that source should be closed and the read should be retried later. If writing to a sink times out, the same rules apply: close the sink and retry later.","title":"Timeout"},{"location":"2.x/okio/okio/-timeout/#timeouts-and-deadlines","text":"This class offers two complementary controls to define a timeout policy. Timeouts specify the maximum time to wait for a single operation to complete. Timeouts are typically used to detect problems like network partitions. For example, if a remote peer doesn\u2019t return any data for ten seconds, we may assume that the peer is unavailable. Deadlines specify the maximum time to spend on a job, composed of one or more operations. Use deadlines to set an upper bound on the time invested on a job. For example, a battery-conscious app may limit how much time it spends pre-loading content.","title":"Timeouts and Deadlines"},{"location":"2.x/okio/okio/-timeout/#constructors","text":"Name Summary (js, jvm, native) <init> <init>()","title":"Constructors"},{"location":"2.x/okio/okio/-timeout/#functions","text":"Name Summary (jvm) clearDeadline Clears the deadline. open fun clearDeadline(): Timeout (jvm) clearTimeout Clears the timeout. Operating system timeouts may still apply. open fun clearTimeout(): Timeout (jvm) deadline Set a deadline of now plus duration time. fun deadline(duration: Long , unit: TimeUnit ): Timeout (jvm) deadlineNanoTime Returns the nano time when the deadline will be reached. open fun deadlineNanoTime(): Long Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. open fun deadlineNanoTime(deadlineNanoTime: Long ): Timeout (jvm) hasDeadline Returns true if a deadline is enabled. open fun hasDeadline(): Boolean (jvm) intersectWith Applies the minimum intersection between this timeout and other , run block , then finally rollback this timeout\u2019s values. fun intersectWith(other: Timeout , block: () -> Unit ): Unit (jvm) throwIfReached Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. open fun throwIfReached(): Unit (jvm) timeout Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail. open fun timeout(timeout: Long , unit: TimeUnit ): Timeout (jvm) timeoutNanos Returns the timeout in nanoseconds, or 0 for no timeout. open fun timeoutNanos(): Long (jvm) waitUntilNotified Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor . fun waitUntilNotified(monitor: Any ): Unit","title":"Functions"},{"location":"2.x/okio/okio/-timeout/#companion-object-properties","text":"Name Summary (js, jvm, native) NONE An empty timeout that neither tracks nor detects timeouts. Use this when timeouts aren\u2019t necessary, such as in implementations whose operations do not block. val NONE: Timeout","title":"Companion Object Properties"},{"location":"2.x/okio/okio/-timeout/#companion-object-functions","text":"Name Summary (jvm) minTimeout fun minTimeout(aNanos: Long , bNanos: Long ): Long","title":"Companion Object Functions"},{"location":"2.x/okio/okio/-timeout/#inheritors","text":"Name Summary (jvm) AsyncTimeout This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing. open class AsyncTimeout : Timeout (jvm) ForwardingTimeout A Timeout which forwards calls to another. Useful for subclassing. open class ForwardingTimeout : Timeout","title":"Inheritors"},{"location":"2.x/okio/okio/-timeout/-init-/","text":"okio / okio / Timeout / <init> <init> \u00b6 (js, jvm, native) <init>()","title":" init "},{"location":"2.x/okio/okio/-timeout/-init-/#init","text":"(js, jvm, native) <init>()","title":"&lt;init&gt;"},{"location":"2.x/okio/okio/-timeout/-n-o-n-e/","text":"okio / okio / Timeout / NONE NONE \u00b6 (js, jvm, native) val NONE: Timeout An empty timeout that neither tracks nor detects timeouts. Use this when timeouts aren\u2019t necessary, such as in implementations whose operations do not block.","title":"NONE - Okio"},{"location":"2.x/okio/okio/-timeout/-n-o-n-e/#none","text":"(js, jvm, native) val NONE: Timeout An empty timeout that neither tracks nor detects timeouts. Use this when timeouts aren\u2019t necessary, such as in implementations whose operations do not block.","title":"NONE"},{"location":"2.x/okio/okio/-timeout/clear-deadline/","text":"okio / okio / Timeout / clearDeadline clearDeadline \u00b6 (jvm) open fun clearDeadline(): Timeout Clears the deadline.","title":"clearDeadline - Okio"},{"location":"2.x/okio/okio/-timeout/clear-deadline/#cleardeadline","text":"(jvm) open fun clearDeadline(): Timeout Clears the deadline.","title":"clearDeadline"},{"location":"2.x/okio/okio/-timeout/clear-timeout/","text":"okio / okio / Timeout / clearTimeout clearTimeout \u00b6 (jvm) open fun clearTimeout(): Timeout Clears the timeout. Operating system timeouts may still apply.","title":"clearTimeout - Okio"},{"location":"2.x/okio/okio/-timeout/clear-timeout/#cleartimeout","text":"(jvm) open fun clearTimeout(): Timeout Clears the timeout. Operating system timeouts may still apply.","title":"clearTimeout"},{"location":"2.x/okio/okio/-timeout/deadline-nano-time/","text":"okio / okio / Timeout / deadlineNanoTime deadlineNanoTime \u00b6 (jvm) open fun deadlineNanoTime(): Long Returns the nano time when the deadline will be reached. Exceptions \u00b6 IllegalStateException - if no deadline is set.(jvm) open fun deadlineNanoTime(deadlineNanoTime: Long ): Timeout Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations.","title":"deadlineNanoTime - Okio"},{"location":"2.x/okio/okio/-timeout/deadline-nano-time/#deadlinenanotime","text":"(jvm) open fun deadlineNanoTime(): Long Returns the nano time when the deadline will be reached.","title":"deadlineNanoTime"},{"location":"2.x/okio/okio/-timeout/deadline-nano-time/#exceptions","text":"IllegalStateException - if no deadline is set.(jvm) open fun deadlineNanoTime(deadlineNanoTime: Long ): Timeout Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations.","title":"Exceptions"},{"location":"2.x/okio/okio/-timeout/deadline/","text":"okio / okio / Timeout / deadline deadline \u00b6 (jvm) fun deadline(duration: Long , unit: TimeUnit ): Timeout Set a deadline of now plus duration time.","title":"deadline - Okio"},{"location":"2.x/okio/okio/-timeout/deadline/#deadline","text":"(jvm) fun deadline(duration: Long , unit: TimeUnit ): Timeout Set a deadline of now plus duration time.","title":"deadline"},{"location":"2.x/okio/okio/-timeout/has-deadline/","text":"okio / okio / Timeout / hasDeadline hasDeadline \u00b6 (jvm) open fun hasDeadline(): Boolean Returns true if a deadline is enabled.","title":"hasDeadline - Okio"},{"location":"2.x/okio/okio/-timeout/has-deadline/#hasdeadline","text":"(jvm) open fun hasDeadline(): Boolean Returns true if a deadline is enabled.","title":"hasDeadline"},{"location":"2.x/okio/okio/-timeout/intersect-with/","text":"okio / okio / Timeout / intersectWith intersectWith \u00b6 (jvm) inline fun intersectWith(other: Timeout , block: () -> Unit ): Unit Applies the minimum intersection between this timeout and other , run block , then finally rollback this timeout\u2019s values.","title":"intersectWith - Okio"},{"location":"2.x/okio/okio/-timeout/intersect-with/#intersectwith","text":"(jvm) inline fun intersectWith(other: Timeout , block: () -> Unit ): Unit Applies the minimum intersection between this timeout and other , run block , then finally rollback this timeout\u2019s values.","title":"intersectWith"},{"location":"2.x/okio/okio/-timeout/min-timeout/","text":"okio / okio / Timeout / minTimeout minTimeout \u00b6 (jvm) fun minTimeout(aNanos: Long , bNanos: Long ): Long","title":"minTimeout - Okio"},{"location":"2.x/okio/okio/-timeout/min-timeout/#mintimeout","text":"(jvm) fun minTimeout(aNanos: Long , bNanos: Long ): Long","title":"minTimeout"},{"location":"2.x/okio/okio/-timeout/throw-if-reached/","text":"okio / okio / Timeout / throwIfReached throwIfReached \u00b6 (jvm) open fun throwIfReached(): Unit Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation.","title":"throwIfReached - Okio"},{"location":"2.x/okio/okio/-timeout/throw-if-reached/#throwifreached","text":"(jvm) open fun throwIfReached(): Unit Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation.","title":"throwIfReached"},{"location":"2.x/okio/okio/-timeout/timeout-nanos/","text":"okio / okio / Timeout / timeoutNanos timeoutNanos \u00b6 (jvm) open fun timeoutNanos(): Long Returns the timeout in nanoseconds, or 0 for no timeout.","title":"timeoutNanos - Okio"},{"location":"2.x/okio/okio/-timeout/timeout-nanos/#timeoutnanos","text":"(jvm) open fun timeoutNanos(): Long Returns the timeout in nanoseconds, or 0 for no timeout.","title":"timeoutNanos"},{"location":"2.x/okio/okio/-timeout/timeout/","text":"okio / okio / Timeout / timeout timeout \u00b6 (jvm) open fun timeout(timeout: Long , unit: TimeUnit ): Timeout Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail. If timeout == 0 , operations will run indefinitely. (Operating system timeouts may still apply.)","title":"timeout - Okio"},{"location":"2.x/okio/okio/-timeout/timeout/#timeout","text":"(jvm) open fun timeout(timeout: Long , unit: TimeUnit ): Timeout Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail. If timeout == 0 , operations will run indefinitely. (Operating system timeouts may still apply.)","title":"timeout"},{"location":"2.x/okio/okio/-timeout/wait-until-notified/","text":"okio / okio / Timeout / waitUntilNotified waitUntilNotified \u00b6 (jvm) fun waitUntilNotified(monitor: Any ): Unit Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor . Here\u2019s a sample class that uses waitUntilNotified() to await a specific state. Note that the call is made within a loop to avoid unnecessary waiting and to mitigate spurious notifications. class Dice { Random random = new Random(); int latestTotal; public synchronized void roll() { latestTotal = 2 + random.nextInt(6) + random.nextInt(6); System.out.println(\"Rolled \" + latestTotal); notifyAll(); } public void rollAtFixedRate(int period, TimeUnit timeUnit) { Executors.newScheduledThreadPool(0).scheduleAtFixedRate(new Runnable() { public void run() { roll(); } }, 0, period, timeUnit); } public synchronized void awaitTotal(Timeout timeout, int total) throws InterruptedIOException { while (latestTotal != total) { timeout.waitUntilNotified(this); } } }","title":"waitUntilNotified - Okio"},{"location":"2.x/okio/okio/-timeout/wait-until-notified/#waituntilnotified","text":"(jvm) fun waitUntilNotified(monitor: Any ): Unit Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor . Here\u2019s a sample class that uses waitUntilNotified() to await a specific state. Note that the call is made within a loop to avoid unnecessary waiting and to mitigate spurious notifications. class Dice { Random random = new Random(); int latestTotal; public synchronized void roll() { latestTotal = 2 + random.nextInt(6) + random.nextInt(6); System.out.println(\"Rolled \" + latestTotal); notifyAll(); } public void rollAtFixedRate(int period, TimeUnit timeUnit) { Executors.newScheduledThreadPool(0).scheduleAtFixedRate(new Runnable() { public void run() { roll(); } }, 0, period, timeUnit); } public synchronized void awaitTotal(Timeout timeout, int total) throws InterruptedIOException { while (latestTotal != total) { timeout.waitUntilNotified(this); } } }","title":"waitUntilNotified"},{"location":"2.x/okio/okio/java.io.-file/","text":"okio / okio / java.io.File Extensions for java.io.File \u00b6 Name Summary (jvm) appendingSink Returns a sink that writes to file . fun File .appendingSink(): Sink (jvm) sink Returns a sink that writes to file . fun File .sink(append: Boolean = false): Sink (jvm) source Returns a source that reads from file . fun File .source(): Source","title":"Extensions for java.io.File - Okio"},{"location":"2.x/okio/okio/java.io.-file/#extensions-for-javaiofile","text":"Name Summary (jvm) appendingSink Returns a sink that writes to file . fun File .appendingSink(): Sink (jvm) sink Returns a sink that writes to file . fun File .sink(append: Boolean = false): Sink (jvm) source Returns a source that reads from file . fun File .source(): Source","title":"Extensions for java.io.File"},{"location":"2.x/okio/okio/java.io.-file/appending-sink/","text":"okio / okio / java.io.File / appendingSink appendingSink \u00b6 (jvm) fun File .appendingSink(): Sink Returns a sink that writes to file .","title":"appendingSink - Okio"},{"location":"2.x/okio/okio/java.io.-file/appending-sink/#appendingsink","text":"(jvm) fun File .appendingSink(): Sink Returns a sink that writes to file .","title":"appendingSink"},{"location":"2.x/okio/okio/java.io.-file/sink/","text":"okio / okio / java.io.File / sink sink \u00b6 (jvm) @JvmOverloads fun File .sink(append: Boolean = false): Sink Returns a sink that writes to file .","title":"sink - Okio"},{"location":"2.x/okio/okio/java.io.-file/sink/#sink","text":"(jvm) @JvmOverloads fun File .sink(append: Boolean = false): Sink Returns a sink that writes to file .","title":"sink"},{"location":"2.x/okio/okio/java.io.-file/source/","text":"okio / okio / java.io.File / source source \u00b6 (jvm) fun File .source(): Source Returns a source that reads from file .","title":"source - Okio"},{"location":"2.x/okio/okio/java.io.-file/source/#source","text":"(jvm) fun File .source(): Source Returns a source that reads from file .","title":"source"},{"location":"2.x/okio/okio/java.io.-input-stream/","text":"okio / okio / java.io.InputStream Extensions for java.io.InputStream \u00b6 Name Summary (jvm) source Returns a source that reads from in . fun InputStream .source(): Source","title":"Extensions for java.io.InputStream - Okio"},{"location":"2.x/okio/okio/java.io.-input-stream/#extensions-for-javaioinputstream","text":"Name Summary (jvm) source Returns a source that reads from in . fun InputStream .source(): Source","title":"Extensions for java.io.InputStream"},{"location":"2.x/okio/okio/java.io.-input-stream/source/","text":"okio / okio / java.io.InputStream / source source \u00b6 (jvm) fun InputStream .source(): Source Returns a source that reads from in .","title":"source - Okio"},{"location":"2.x/okio/okio/java.io.-input-stream/source/#source","text":"(jvm) fun InputStream .source(): Source Returns a source that reads from in .","title":"source"},{"location":"2.x/okio/okio/java.io.-output-stream/","text":"okio / okio / java.io.OutputStream Extensions for java.io.OutputStream \u00b6 Name Summary (jvm) sink Returns a sink that writes to out . fun OutputStream .sink(): Sink","title":"Extensions for java.io.OutputStream - Okio"},{"location":"2.x/okio/okio/java.io.-output-stream/#extensions-for-javaiooutputstream","text":"Name Summary (jvm) sink Returns a sink that writes to out . fun OutputStream .sink(): Sink","title":"Extensions for java.io.OutputStream"},{"location":"2.x/okio/okio/java.io.-output-stream/sink/","text":"okio / okio / java.io.OutputStream / sink sink \u00b6 (jvm) fun OutputStream .sink(): Sink Returns a sink that writes to out .","title":"sink - Okio"},{"location":"2.x/okio/okio/java.io.-output-stream/sink/#sink","text":"(jvm) fun OutputStream .sink(): Sink Returns a sink that writes to out .","title":"sink"},{"location":"2.x/okio/okio/java.net.-socket/","text":"okio / okio / java.net.Socket Extensions for java.net.Socket \u00b6 Name Summary (jvm) sink Returns a sink that writes to socket . Prefer this over sink because this method honors timeouts. When the socket write times out, the socket is asynchronously closed by a watchdog thread. fun Socket .sink(): Sink (jvm) source Returns a source that reads from socket . Prefer this over source because this method honors timeouts. When the socket read times out, the socket is asynchronously closed by a watchdog thread. fun Socket .source(): Source","title":"Extensions for java.net.Socket - Okio"},{"location":"2.x/okio/okio/java.net.-socket/#extensions-for-javanetsocket","text":"Name Summary (jvm) sink Returns a sink that writes to socket . Prefer this over sink because this method honors timeouts. When the socket write times out, the socket is asynchronously closed by a watchdog thread. fun Socket .sink(): Sink (jvm) source Returns a source that reads from socket . Prefer this over source because this method honors timeouts. When the socket read times out, the socket is asynchronously closed by a watchdog thread. fun Socket .source(): Source","title":"Extensions for java.net.Socket"},{"location":"2.x/okio/okio/java.net.-socket/sink/","text":"okio / okio / java.net.Socket / sink sink \u00b6 (jvm) fun Socket .sink(): Sink Returns a sink that writes to socket . Prefer this over sink because this method honors timeouts. When the socket write times out, the socket is asynchronously closed by a watchdog thread.","title":"sink - Okio"},{"location":"2.x/okio/okio/java.net.-socket/sink/#sink","text":"(jvm) fun Socket .sink(): Sink Returns a sink that writes to socket . Prefer this over sink because this method honors timeouts. When the socket write times out, the socket is asynchronously closed by a watchdog thread.","title":"sink"},{"location":"2.x/okio/okio/java.net.-socket/source/","text":"okio / okio / java.net.Socket / source source \u00b6 (jvm) fun Socket .source(): Source Returns a source that reads from socket . Prefer this over source because this method honors timeouts. When the socket read times out, the socket is asynchronously closed by a watchdog thread.","title":"source - Okio"},{"location":"2.x/okio/okio/java.net.-socket/source/#source","text":"(jvm) fun Socket .source(): Source Returns a source that reads from socket . Prefer this over source because this method honors timeouts. When the socket read times out, the socket is asynchronously closed by a watchdog thread.","title":"source"},{"location":"2.x/okio/okio/java.nio.file.-path/","text":"okio / okio / java.nio.file.Path Extensions for java.nio.file.Path \u00b6 Name Summary (jvm) sink Returns a source that reads from path . fun Path.sink(vararg options: OpenOption): Sink (jvm) source Returns a sink that writes to path . fun Path.source(vararg options: OpenOption): Source","title":"Extensions for java.nio.file.Path - Okio"},{"location":"2.x/okio/okio/java.nio.file.-path/#extensions-for-javaniofilepath","text":"Name Summary (jvm) sink Returns a source that reads from path . fun Path.sink(vararg options: OpenOption): Sink (jvm) source Returns a sink that writes to path . fun Path.source(vararg options: OpenOption): Source","title":"Extensions for java.nio.file.Path"},{"location":"2.x/okio/okio/java.nio.file.-path/sink/","text":"okio / okio / java.nio.file.Path / sink sink \u00b6 (jvm) @IgnoreJRERequirement fun Path.sink(vararg options: OpenOption): Sink Returns a source that reads from path .","title":"sink - Okio"},{"location":"2.x/okio/okio/java.nio.file.-path/sink/#sink","text":"(jvm) @IgnoreJRERequirement fun Path.sink(vararg options: OpenOption): Sink Returns a source that reads from path .","title":"sink"},{"location":"2.x/okio/okio/java.nio.file.-path/source/","text":"okio / okio / java.nio.file.Path / source source \u00b6 (jvm) @IgnoreJRERequirement fun Path.source(vararg options: OpenOption): Source Returns a sink that writes to path .","title":"source - Okio"},{"location":"2.x/okio/okio/java.nio.file.-path/source/#source","text":"(jvm) @IgnoreJRERequirement fun Path.source(vararg options: OpenOption): Source Returns a sink that writes to path .","title":"source"},{"location":"2.x/okio/okio/kotlin.-string/","text":"okio / okio / kotlin.String Extensions for kotlin.String \u00b6 Name Summary (js, jvm) utf8Size Returns the number of bytes used to encode the slice of string as UTF-8 when using BufferedSink.writeUtf8 . fun String .utf8Size(beginIndex: Int = 0, endIndex: Int = length): Long","title":"Extensions for kotlin.String - Okio"},{"location":"2.x/okio/okio/kotlin.-string/#extensions-for-kotlinstring","text":"Name Summary (js, jvm) utf8Size Returns the number of bytes used to encode the slice of string as UTF-8 when using BufferedSink.writeUtf8 . fun String .utf8Size(beginIndex: Int = 0, endIndex: Int = length): Long","title":"Extensions for kotlin.String"},{"location":"2.x/okio/okio/kotlin.-string/utf8-size/","text":"okio / okio / kotlin.String / utf8Size utf8Size \u00b6 (js) @JvmOverloads @JvmName(\"size\") fun String .utf8Size(beginIndex: Int = 0, endIndex: Int = length): Long (jvm) @JvmOverloads @JvmName(\"size\") fun String .utf8Size(beginIndex: Int = 0, endIndex: Int = length): Long Returns the number of bytes used to encode the slice of string as UTF-8 when using BufferedSink.writeUtf8 .","title":"utf8Size - Okio"},{"location":"2.x/okio/okio/kotlin.-string/utf8-size/#utf8size","text":"(js) @JvmOverloads @JvmName(\"size\") fun String .utf8Size(beginIndex: Int = 0, endIndex: Int = length): Long (jvm) @JvmOverloads @JvmName(\"size\") fun String .utf8Size(beginIndex: Int = 0, endIndex: Int = length): Long Returns the number of bytes used to encode the slice of string as UTF-8 when using BufferedSink.writeUtf8 .","title":"utf8Size"}]}